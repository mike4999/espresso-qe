!
! Input/Output Tool Kit (IOTK)
! Copyright (C) 2004 Giovanni Bussi
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Lesser General Public
! License as published by the Free Software Foundation; either
! version 2.1 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Lesser General Public License for more details.
!
! You should have received a copy of the GNU Lesser General Public
! License along with this library; if not, write to the Free Software
! Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
!

! PLEASE DO NOT EDIT THIS FILE !
! THIS FILE HAS BEEN GENERATED AUTOMATICALLY WITH
! SPREP 0.1.0 ON Thu May 13 10:20:24 DFT 2004


!------------------------------------------------------------------------------!
! Input/Output Tool Kit (IOTK)
! version 0.2.4
!------------------------------------------------------------------------------!

!------------------------------------------------------------------------------!
! Inclusion of configuration file
#include "iotk_config.h"
!------------------------------------------------------------------------------!

! General configurations:

#define __SHAPE_0
#define __BOUNDS_0(X)

#define __SHAPE_1 (:)
#define __BOUNDS_1(X) (ubound(X,1))

#define __SHAPE_2 (:,:)
#define __BOUNDS_2(X) (ubound(X,1),ubound(X,2))

#define __SHAPE_3 (:,:,:)
#define __BOUNDS_3(X) (ubound(X,1),ubound(X,2),ubound(X,3))

#define __SHAPE_4 (:,:,:,:)
#define __BOUNDS_4(X) (ubound(X,1),ubound(X,2),ubound(X,3),ubound(X,4))

#define __SHAPE_5 (:,:,:,:,:)
#define __BOUNDS_5(X) (ubound(X,1),ubound(X,2),ubound(X,3),ubound(X,4),ubound(X,5))


!------------------------------------------------------------------------------!
! FORTRAN SOURCE
!------------------------------------------------------------------------------!
!
! NOTE: IF THE NAME OF THE PRESENT FILE IS iotk_module.PF,
! LOOPS SHOULD BE UNROLLED USING THE sprep COMMAND
! PRIOR TO FORTRAN COMPILATION.
!------------------------------------------------------------------------------!


module iotk_module
implicit none

! This line set the version string
character(100), parameter :: iotk_version = "0.2.4"

! This line set the binary_format string
character(100), parameter :: iotk_binary_format = __IOTK_BINARY_FORMAT

! All names are private ...
private
! ... except the names listed below
public :: iotk_write_begin, &
          iotk_write_end,   &
          iotk_write_pi,    &
          iotk_write_empty, &
          iotk_write_dat,   &
          iotk_write_attr,  &
          iotk_scan_begin,  &
          iotk_scan_end,    &
          iotk_scan_pi,     &
          iotk_scan_empty,  &
          iotk_scan_dat,    &
          iotk_scan_attr,   &
          iotk_taglenx,     &
          iotk_attlenx,     &
          iotk_vallenx,     &
          iotk_namlenx,     &
          iotk_index,       &
          iotk_header_kind, &
          iotk_last_iostat, &
          iotk_version,     &
          iotk_binary_format, &
          iotk_open_write,  &
          iotk_open_read,   &
          iotk_close_write, &
          iotk_close_read,  &
          iotk_copy_tag,    &
          iotk_unit_print,  &
          iotk_unit_get,    &
          iotk_free_unit

!          iotk_magic
! MAGIC REMOVED

#define __IOTK_T1 logical
#define __IOTK_T2 integer
#define __IOTK_T3 real
#define __IOTK_T4 complex
#define __IOTK_T5 character

character(10), parameter :: type_names(5) = &
  (/"logical  ",&
    "integer  ",&
    "real     ",&
    "complex  ",&
    "character" /)

#undef __IOTK_T1_K1
#ifdef __IOTK_LOGICAL1
#define __IOTK_T1_K1 __IOTK_LOGICAL1
#endif
#undef __IOTK_T2_K1
#ifdef __IOTK_INTEGER1
#define __IOTK_T2_K1 __IOTK_INTEGER1
#endif
#undef __IOTK_T3_K1
#undef __IOTK_T4_K1
#ifdef __IOTK_REAL1
#define __IOTK_T3_K1 __IOTK_REAL1
#define __IOTK_T4_K1 __IOTK_REAL1
#endif
#undef __IOTK_T1_K2
#ifdef __IOTK_LOGICAL2
#define __IOTK_T1_K2 __IOTK_LOGICAL2
#endif
#undef __IOTK_T2_K2
#ifdef __IOTK_INTEGER2
#define __IOTK_T2_K2 __IOTK_INTEGER2
#endif
#undef __IOTK_T3_K2
#undef __IOTK_T4_K2
#ifdef __IOTK_REAL2
#define __IOTK_T3_K2 __IOTK_REAL2
#define __IOTK_T4_K2 __IOTK_REAL2
#endif
#undef __IOTK_T1_K3
#ifdef __IOTK_LOGICAL3
#define __IOTK_T1_K3 __IOTK_LOGICAL3
#endif
#undef __IOTK_T2_K3
#ifdef __IOTK_INTEGER3
#define __IOTK_T2_K3 __IOTK_INTEGER3
#endif
#undef __IOTK_T3_K3
#undef __IOTK_T4_K3
#ifdef __IOTK_REAL3
#define __IOTK_T3_K3 __IOTK_REAL3
#define __IOTK_T4_K3 __IOTK_REAL3
#endif
#undef __IOTK_T1_K4
#ifdef __IOTK_LOGICAL4
#define __IOTK_T1_K4 __IOTK_LOGICAL4
#endif
#undef __IOTK_T2_K4
#ifdef __IOTK_INTEGER4
#define __IOTK_T2_K4 __IOTK_INTEGER4
#endif
#undef __IOTK_T3_K4
#undef __IOTK_T4_K4
#ifdef __IOTK_REAL4
#define __IOTK_T3_K4 __IOTK_REAL4
#define __IOTK_T4_K4 __IOTK_REAL4
#endif
!Only default characters are implemented
#define __IOTK_T5_K1
#undef  __IOTK_T5_K2
#undef  __IOTK_T5_K3
#undef  __IOTK_T5_K4
!If one wants to add other kinds, also the iotk_*_dat routines should be modified

! Max number of controls
integer, parameter :: iotk_ncontrol = 255 ! (2**8-1)

! Max length of info tag
integer, parameter :: iotk_taglenx =  65535 ! (2**16-1)
integer, parameter :: iotk_namlenx =  1024
integer, parameter :: iotk_attlenx =  iotk_taglenx - iotk_namlenx - 1 ! for space
integer, parameter :: iotk_vallenx =  4096
integer, parameter :: iotk_linlenx =  8192

! Kind for the header integer (number of digits in (iotk_ncontrol+1)*(iotk_taglenx+1))
integer, parameter :: iotk_header_kind = selected_int_kind(8)

! Variable where the last iostat is store
integer, save :: iostat = 0

! Map of controls into XML tags
! control = 1 <       >
! control = 2 </      >
! control = 3 <      />
! control = 4 <!--  -->
! control = 5 <?     ?>
! control = 128 is a special tag for binary files (continuation tag)

! Alphabet
character(26), parameter :: lowalphabet = "abcdefghijklmnopqrstuvwxyz"
character(26), parameter :: upalphabet  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
character(52), parameter :: alphabet    = lowalphabet//upalphabet
character(53), parameter :: alphabet_   = alphabet//"_"
character(10), parameter :: numbers     = "0123456789"

character(54), parameter :: iotk_namcharfirst = alphabet//"_:"
character(66), parameter :: iotk_namchar      = iotk_namcharfirst//numbers//".-"

type iotk_unit
  integer                     :: unit
  character (iotk_namlenx)    :: root
!  type (iotk_folder), pointer :: folder_stack
  type (iotk_unit),   pointer :: next
end type iotk_unit

!type iotk_folder
!  character (iotk_namlenx)    :: name
!  type (iotk_folder), pointer :: next
!end type iotk_folder

logical                   :: iotk_units_init = .false.
type (iotk_unit), pointer :: iotk_units


! Interfaces for multi-type, multi-kind or multi-rank procedures

interface iotk_index
  module procedure iotk_index_scal
  module procedure iotk_index_vec
end interface

interface iotk_write_attr
#ifdef __IOTK_T1_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_1_5
#endif
#endif
#ifdef __IOTK_T1_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_2_5
#endif
#endif
#ifdef __IOTK_T1_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_3_5
#endif
#endif
#ifdef __IOTK_T1_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_1_4_5
#endif
#endif
#ifdef __IOTK_T2_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_1_5
#endif
#endif
#ifdef __IOTK_T2_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_2_5
#endif
#endif
#ifdef __IOTK_T2_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_3_5
#endif
#endif
#ifdef __IOTK_T2_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_2_4_5
#endif
#endif
#ifdef __IOTK_T3_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_1_5
#endif
#endif
#ifdef __IOTK_T3_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_2_5
#endif
#endif
#ifdef __IOTK_T3_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_3_5
#endif
#endif
#ifdef __IOTK_T3_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_3_4_5
#endif
#endif
#ifdef __IOTK_T4_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_1_5
#endif
#endif
#ifdef __IOTK_T4_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_2_5
#endif
#endif
#ifdef __IOTK_T4_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_3_5
#endif
#endif
#ifdef __IOTK_T4_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_attr_4_4_5
#endif
#endif
#ifdef __IOTK_T5_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_attr_5_1_0
#endif
#endif
end interface

interface iotk_scan_attr
#ifdef __IOTK_T1_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_1_5
#endif
#endif
#ifdef __IOTK_T1_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_2_5
#endif
#endif
#ifdef __IOTK_T1_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_3_5
#endif
#endif
#ifdef __IOTK_T1_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_1_4_5
#endif
#endif
#ifdef __IOTK_T2_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_1_5
#endif
#endif
#ifdef __IOTK_T2_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_2_5
#endif
#endif
#ifdef __IOTK_T2_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_3_5
#endif
#endif
#ifdef __IOTK_T2_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_2_4_5
#endif
#endif
#ifdef __IOTK_T3_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_1_5
#endif
#endif
#ifdef __IOTK_T3_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_2_5
#endif
#endif
#ifdef __IOTK_T3_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_3_5
#endif
#endif
#ifdef __IOTK_T3_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_3_4_5
#endif
#endif
#ifdef __IOTK_T4_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_1_5
#endif
#endif
#ifdef __IOTK_T4_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_2_5
#endif
#endif
#ifdef __IOTK_T4_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_3_5
#endif
#endif
#ifdef __IOTK_T4_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_4_4_5
#endif
#endif
#ifdef __IOTK_T5_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_attr_5_1_0
#endif
#endif
end interface

interface iotk_write_dat
#ifdef __IOTK_T1_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_1_5
#endif
#endif
#ifdef __IOTK_T1_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_2_5
#endif
#endif
#ifdef __IOTK_T1_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_3_5
#endif
#endif
#ifdef __IOTK_T1_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_1_4_5
#endif
#endif
#ifdef __IOTK_T2_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_1_5
#endif
#endif
#ifdef __IOTK_T2_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_2_5
#endif
#endif
#ifdef __IOTK_T2_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_3_5
#endif
#endif
#ifdef __IOTK_T2_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_2_4_5
#endif
#endif
#ifdef __IOTK_T3_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_1_5
#endif
#endif
#ifdef __IOTK_T3_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_2_5
#endif
#endif
#ifdef __IOTK_T3_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_3_5
#endif
#endif
#ifdef __IOTK_T3_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_3_4_5
#endif
#endif
#ifdef __IOTK_T4_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_1_5
#endif
#endif
#ifdef __IOTK_T4_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_2_5
#endif
#endif
#ifdef __IOTK_T4_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_3_5
#endif
#endif
#ifdef __IOTK_T4_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_4_4_5
#endif
#endif
#ifdef __IOTK_T5_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_write_dat_5_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_write_dat_5_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_write_dat_5_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_write_dat_5_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_write_dat_5_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_write_dat_5_1_5
#endif
#endif
end interface

interface iotk_scan_dat
#ifdef __IOTK_T1_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_1_5
#endif
#endif
#ifdef __IOTK_T1_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_2_5
#endif
#endif
#ifdef __IOTK_T1_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_3_5
#endif
#endif
#ifdef __IOTK_T1_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_1_4_5
#endif
#endif
#ifdef __IOTK_T2_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_1_5
#endif
#endif
#ifdef __IOTK_T2_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_2_5
#endif
#endif
#ifdef __IOTK_T2_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_3_5
#endif
#endif
#ifdef __IOTK_T2_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_2_4_5
#endif
#endif
#ifdef __IOTK_T3_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_1_5
#endif
#endif
#ifdef __IOTK_T3_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_2_5
#endif
#endif
#ifdef __IOTK_T3_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_3_5
#endif
#endif
#ifdef __IOTK_T3_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_3_4_5
#endif
#endif
#ifdef __IOTK_T4_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_1_5
#endif
#endif
#ifdef __IOTK_T4_K2
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_2_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_2_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_2_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_2_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_2_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_2_5
#endif
#endif
#ifdef __IOTK_T4_K3
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_3_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_3_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_3_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_3_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_3_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_3_5
#endif
#endif
#ifdef __IOTK_T4_K4
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_4_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_4_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_4_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_4_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_4_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_4_4_5
#endif
#endif
#ifdef __IOTK_T5_K1
#if 0 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_5_1_0
#endif
#if 1 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_5_1_1
#endif
#if 2 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_5_1_2
#endif
#if 3 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_5_1_3
#endif
#if 4 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_5_1_4
#endif
#if 5 <= __IOTK_MAXRANK
module procedure iotk_scan_dat_5_1_5
#endif
#endif
end interface

contains

subroutine iotk_free_unit(unit,ierr)
! This subroutine sets 'unit' to the number of
! an I/O unit which is free (i.e. not already opened).
! The search is carried out starting from unit
! 'unitmin' in a range of 'nsearch' units.
! The starting unit for the search is increased at each
! call, so that a number of subsequent ask can be done
! obtaining different units.
  integer,           intent(out) :: unit
  integer, optional, intent(out) :: ierr
! parameters
  integer, parameter   :: unitmin = 10000 , &
                          nsearch = 100000
  integer, save :: offset = 0
  logical       :: opened,exist
  integer       :: isearch
  integer       :: ierrl
  ierrl = 0
  do isearch=0,nsearch-1
    unit = modulo(isearch+offset,nsearch) + unitmin
    inquire(unit=unit,opened=opened,exist=exist,iostat=iostat)
    if((.not.opened .and. exist) .or. iostat/=0) exit
  end do
  if(isearch>=nsearch .or. iostat/=0) ierrl= __LINE__
  offset = modulo(unit - unitmin + 1,nsearch)
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_free_unit

function type_number(type)
  integer                  :: type_number
  character(*), intent(in) :: type
  integer :: i
  do i = 1 , 5
    if(type==type_names(i)) exit
  end do
  if(i==6) i = -1
  type_number = i
end function type_number

subroutine iotk_unit_print(unit)
  integer, intent(in) :: unit
  type (iotk_unit), pointer :: this
  this => iotk_units
  do
    if(.not. associated(this)) exit
    write(unit,"(i8,a)") this%unit,":"//trim(this%root)
    this => this%next
  end do
end subroutine iotk_unit_print

subroutine iotk_unit_add(unit,root,ierr)
  integer,           intent(in)  :: unit
  character(*),      intent(in)  :: root
  integer, optional, intent(out) :: ierr
  type (iotk_unit), pointer :: this
  integer :: ierrl
  ierrl = 0
  if(.not. iotk_units_init) then
    iotk_units_init = .true.
    nullify(iotk_units)
  end if
  this => iotk_units
  do
    if(.not.associated(this)) exit
    if(this%unit == unit) then
      ierrl = __LINE__
      goto 1
    end if
    this => this%next
  end do
  allocate(this)
  this%unit = unit
  this%root = root
  this%next  => iotk_units
  iotk_units => this
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_unit_add

subroutine iotk_unit_del(unit,ierr)
  integer,           intent(in)  :: unit
  integer, optional, intent(out) :: ierr
  type (iotk_unit), pointer :: this,prev
  integer :: ierrl
  ierrl = 0
  if(.not. iotk_units_init) then
    iotk_units_init = .true.
    nullify(iotk_units)
  end if
  nullify(prev)
  this => iotk_units
  do
    if(.not.associated(this)) then
      ierrl = __LINE__
      goto 1
    end if
    if(this%unit == unit) exit
    prev => this
    this => this%next
  end do
  if(associated(prev)) then
    prev%next  => this%next
  else
    iotk_units => this%next
  end if
  deallocate(this)
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_unit_del

subroutine iotk_unit_get(unit,root,ierr)
  integer,                intent(in)  :: unit
  character(*), optional, intent(out) :: root
  integer,      optional, intent(out) :: ierr
  type (iotk_unit), pointer :: this
  integer :: ierrl
  ierrl = 0
  if(.not. iotk_units_init) then
    iotk_units_init = .true.
    nullify(iotk_units)
  end if
  this => iotk_units
  do
    if(.not.associated(this)) then
      ierrl = __LINE__
      goto 1
    end if
    if(this%unit == unit) exit
    this => this%next
  end do
  if(present(root)) root = this%root
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_unit_get

subroutine iotk_inquire(unit,binary,ierr)
  integer,           intent(in)  :: unit
  logical, optional, intent(out) :: binary
  integer, optional, intent(out) :: ierr
  character(50) :: form,access,pad,blank
  logical :: opened,binaryl
  integer :: ierrl
  ierrl = 0
  inquire(unit=unit,form=form,iostat=iostat,access=access,pad=pad,blank=blank,opened=opened)
  if(iostat/=0) ierrl = __LINE__
  if(ierrl==0) then
    if(opened .and. uppercase(form)=="UNFORMATTED") then
      binaryl = .true.
    else
      binaryl = .false.
    end if
  end if
  if(ierrl==0 .and. opened .and. uppercase(access)/="SEQUENTIAL") ierr = __LINE__
  if(ierrl==0 .and. .not. binaryl) then
    if(opened .and. uppercase(blank)/="NULL") ierr = __LINE__
    if(opened .and. uppercase(pad)  /="YES")  ierr = __LINE__
  end if
  if(present(binary)) binary = binaryl
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_inquire

subroutine append(large,small,space,ierr)
  character(len=*), intent(inout) :: large
  character(len=*), intent(in)    :: small
  logical,          intent(in)    :: space
  integer,          intent(out)   :: ierr
  integer :: len_small,len_large
  character(len=len(small)) :: small_tmp
  small_tmp = adjustl(small)
  ierr = 0
  len_small = verify(small_tmp," ",back=.true.)
  len_large = verify(large," ",back=.true.)
  if(space .and. len_large>0) len_large = len_large+1
  if(len_small+len_large>len(large)) ierr = 1
  large(len_large+1:len_large+len_small) = small_tmp(1:len_small)
end subroutine append

!subroutine appendl(large,small,ierr)
!  character(len=*), intent(inout) :: large
!  character(len=*), intent(in)    :: small
!  integer,          intent(out)   :: ierr
!  integer :: len_small,len_large
!  character(len=len(small)) :: small_tmp
!  small_tmp = adjustl(small)
!  ierr = 0
!  len_small = 
!  len_large = len_trim(large)
!  if(len_small+len_large>len(large)) ierr = 1
!  if(ierr==0) ctmp(1:len_large) = large(1:len_large)
!  if(ierr==0) large(1:len_small) = small(1:len_small)
!  if(ierr==0) large(len_small+1:len_small+len_large) = ctmp(1:len_large)
!end subroutine appendl

function check_name(name)
  character(*), intent(in) :: name
  logical                  :: check_name
! Checks a single name
  integer :: len_name
  check_name = .true.
  len_name = len_trim(name)
  if(len_name>iotk_namlenx) check_name = .false.
  if(verify(name(1:1),iotk_namcharfirst)/=0) check_name = .false.
  if(len_name>1) then
    if(verify(name(2:len_name),iotk_namchar)/=0) check_name = .false.
  end if
end function check_name

function check_val(val)
  character(*), intent(in) :: val
  logical                  :: check_val
! Checks a value
  check_val = .true.
  if(len_trim(val)>iotk_vallenx) check_val = .false.
! Add a check on allowed characters
end function check_val

function check_attr(attr)
  logical :: check_attr
  character(*), intent(in) :: attr
! Checks an attribute string
  check_attr = .true.
  if(len_trim(attr)>iotk_attlenx) check_attr = .false.
! Add a check on allowed characters
end function check_attr

function version_number(version,iswitch)
  character(*), intent(in) :: version
  integer,      intent(in) :: iswitch
! Extract version numbers from version string
! iswitch = 1 (major), 2 (minor) or 3 (patch)
  integer :: version_number
  integer :: iiostat
  integer :: pos1,pos2,itmp
  version_number = -1
  pos1 = scan(version,".")
  if(pos1==0) return
  pos2 = scan(version(pos1+1:),".") + pos1
  if(pos2<=pos1) return
  iostat = 0
  select case(iswitch)
  case(1)
    read(version(1:pos1-1),"(i10)",iostat=iiostat) itmp
  case(2)
    read(version(pos1+1:pos2-1),"(i10)",iostat=iiostat) itmp
  case(3)
    read(version(pos2+1:),"(i10)",iostat=iiostat) itmp
  end select
  if(iiostat/=0) return
  version_number = itmp
end function version_number

#if 0
subroutine iotk_magic(file,binary,ierr)
  character(len=*),  intent(in)  :: file
  logical, optional, intent(out) :: binary
  integer, optional, intent(out) :: ierr
  integer :: ierrl,unit,ierrl1
  logical :: opened
  ierrl = 0
  if(present(binary)) then
    call iotk_free_unit(unit,ierr=ierrl)
    if(ierrl/=0) goto 1
    call iotk_open_read(unit,file=file,binary=.false.,ierr=ierrl1)
    inquire(unit=unit,opened=opened)
    if(opened) close(unit)
    if(ierrl1==0) then
      binary = .false.
      goto 1
    end if
    iostat = 0
    call iotk_open_read(unit,file=file,binary=.true., ierr=ierrl1)
    inquire(unit=unit,opened=opened)
    if(opened) close(unit)
    if(ierrl1==0) then
      binary = .true.
      goto 1
    end if
    ierrl = __LINE__
  end if
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_magic
#endif

subroutine iotk_open_write(unit,file,binary,new,root,ierr)
  integer,                intent(in)  :: unit
  character(*), optional, intent(in)  :: file
  logical,      optional, intent(in)  :: binary
  logical,      optional, intent(in)  :: new
  character(*), optional, intent(in)  :: root
  integer,      optional, intent(out) :: ierr
! Opens a file properly
  character(50) :: status,form
  character(iotk_namlenx) :: lroot
  character(iotk_attlenx) :: attr
  integer :: ierrl
  logical :: lbinary
  ierrl = 0
  if(present(file)) then
    form = "formatted"
    if(present(binary)) then
      if(binary) form = "unformatted"
    end if
    status = "unknown"
    if(present(new)) then
      if(new) status = "new"
    end if
    open(unit=unit,file=file,status=status,form=form, &
         position="rewind",iostat=iostat,action="write")
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) goto 1
  end if
  call iotk_inquire(unit,binary=lbinary,ierr=ierrl)
  if(ierrl/=0) goto 1
  if(.not. lbinary) write(unit,"(a)") '<?xml version="1.0"?>'
  call iotk_write_attr(attr,"version",iotk_version,first=.true.,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_write_pi(unit,"iotk",attr,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_write_attr(attr,"binary",lbinary,first=.true.,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_write_pi(unit,"iotk",attr,ierr=ierrl)
  if(ierrl/=0) goto 1
  if(lbinary) then
    call iotk_write_attr(attr,"binary_format",iotk_binary_format,first=.true.,ierr=ierrl)
    if(ierrl/=0) goto 1
    if(ierrl/=0) goto 1
    call iotk_write_pi(unit,"iotk",attr,ierr=ierrl)
  end if
  lroot = "Root"
  if(present(root)) lroot = root
  call iotk_write_begin(unit,lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_unit_add(unit,root=lroot,ierr=ierrl)
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_open_write

subroutine iotk_close_write(unit,ierr)
  integer,                intent(in)  :: unit
  integer,      optional, intent(out) :: ierr
! Closes a file properly
  character(iotk_namlenx) :: lroot
  logical :: binary
  integer :: ierrl
  ierrl = 0
  call iotk_unit_get(unit,root=lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_write_end(unit,lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_inquire(unit,binary,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary) write(unit,*,iostat=iostat)
  if(iostat/=0) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_unit_del(unit,ierr=ierrl)
  if(ierrl/=0) goto 1
  close(unit,iostat=iostat)
  if(iostat/=0) ierrl = __LINE__
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_close_write

recursive subroutine iotk_open_read(unit,file,binary,root,ierr)
  integer,                intent(in)  :: unit
  character(*), optional, intent(in)  :: file
  logical,      optional, intent(in)  :: binary
  character(*), optional, intent(out) :: root
  integer,      optional, intent(out) :: ierr
  character(50)           :: status,form
  character(iotk_attlenx) :: attr
  character(iotk_taglenx) :: tag
  character(iotk_namlenx) :: lroot
  integer                 :: ierrl,control
  logical                 :: lbinary,rbinary,iotk
  ierrl = 0
  if(present(file)) then
    if(present(binary)) then
      lbinary = binary
    else
      lbinary = .false.
    end if
    form = "formatted"
    if(lbinary) form = "unformatted"
    open(unit=unit,file=file,status="old",form=form,position="rewind",iostat=iostat,action="read")
    if(iostat/=0) ierrl = __LINE__
  end if
  if(ierrl/=0) goto 1
  call iotk_inquire(unit,binary=lbinary,ierr=ierrl)
  if(ierrl/=0) goto 1
  do
    call scan_tag(unit,+1,control,tag,lbinary,ierrl)
    if(ierrl/=0) goto 1
    select case(control)
    case(1)
      exit
    case(2:3)
      goto 1
    case(5)
      call tag_parse(tag,lroot,attr,ierrl)
      if(ierrl/=0) goto 1
      if(lroot=="iotk") call check_iotk_attr(unit,attr,ierrl)
      if(ierrl/=0) goto 1
    end select
  end do
  if(ierrl/=0) goto 1
  call tag_parse(tag,lroot,attr,ierrl)
  if(ierrl/=0) goto 1
  if(present(root)) root = lroot
  call iotk_unit_add(unit,lroot,ierr=ierrl)
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_open_read

subroutine iotk_close_read(unit,ierr)
  integer,                intent(in)  :: unit
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: lroot
  integer                 :: ierrl
  ierrl = 0
  call iotk_unit_get(unit,root=lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_scan_end(unit,lroot,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_unit_del(unit,ierr=ierrl)
  if(ierrl/=0) goto 1
  close(unit,iostat=iostat)
  if(iostat/=0) ierrl=__LINE__
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_close_read

function iotk_last_iostat()
  integer :: iotk_last_iostat
  iotk_last_iostat = iostat
end function iotk_last_iostat

function iotk_index_scal(index)
  integer,           intent(in) :: index
  character(len=range(index)+3) :: iotk_index_scal
  character(len=range(index)+3) :: number
  character(10) :: fmt
  integer :: iiostat
  write(fmt,"(i10)") len(iotk_index_scal)
  fmt = "(i"//trim(adjustl(fmt))//")"
  write(number,fmt,iostat=iiostat) index
  iotk_index_scal = "."//trim(adjustl(number))
  if(iiostat/=0) iotk_index_scal="ERR"
end function iotk_index_scal

function iotk_index_vec(index)
  integer,                         intent(in) :: index(:)
  character(len=(range(index)+3)*size(index)) :: iotk_index_vec
  integer :: i,ierr
  iotk_index_vec = " "
  do i = 1,size(index)
    call append(iotk_index_vec,trim(iotk_index_scal(index(i))),.false.,ierr)
!    iotk_index_vec(len_trim(iotk_index_vec)+1:) = trim(iotk_index_scal(index(i)))
  end do
  if(ierr/=0) call iotk_error(-1,ierr)
end function iotk_index_vec

function uppercase(str)
  character(len=*), intent(in) :: str
  character(len=len(str))      :: uppercase
  integer :: i,pos
  do i = 1,len(str)
    pos=scan(lowalphabet,str(i:i))
    if(pos==0) then
      uppercase(i:i) = str(i:i)
    else
      uppercase(i:i) = upalphabet(pos:pos)
    end if
  end do
end function uppercase

function iotk_i2c(i)
  integer,       intent(in) :: i
  character(len=range(i)+3) :: iotk_i2c
  character(10) :: fmt
  integer       :: iiostat
  write(fmt,"(i10)") len(iotk_i2c)
  fmt = "(i"//trim(adjustl(fmt))//")"
  write(iotk_i2c,fmt,iostat=iiostat) i
  iotk_i2c = adjustl(iotk_i2c)
  if(iiostat/=0) iotk_i2c="ERR"
end function iotk_i2c

function iotk_c2i(c)
  character(len=*), intent(in) :: c
  integer                      :: iotk_c2i
  character(10) :: fmt
  integer :: iiostat
  write(fmt,"(i10)") len(c)
  fmt = "(i"//trim(adjustl(fmt))//")"
  read(c,fmt,iostat=iiostat) iotk_c2i
  if(iiostat/=0) iotk_c2i = huge(iotk_c2i)
end function iotk_c2i

subroutine iotk_error(unit,ierr)
  integer, intent(in) :: unit
  integer, intent(in) :: ierr
  character(1000) :: filename
#ifdef __IOTK_MPI_ABORT
  include 'mpif.h'
  integer :: ierrx
#endif
  logical :: named
  if(ierr==0) return
  inquire(unit=unit,named=named,name=filename)
  if(.not.named) filename="unnamed file"
  write(0,*) "#################################"
  write(0,*) "Error in Input/Output Tool Kit, version " // "0.2.4"
  write(0,*) "Code        : ",ierr
  write(0,*) "Unit        : ",unit
  write(0,*) "File        : "//trim(filename)
  write(0,*) "Last iostat : ",iostat
  write(0,*) "#################################"
#ifdef __IOTK_MPI_ABORT
  call MPI_Abort(MPI_COMM_WORLD,ierr,ierrx)
#else
  stop
#endif
end subroutine iotk_error

subroutine write_tag(unit,control,tag,binary,ierr)
  integer,                   intent(in)  :: unit
  integer,                   intent(in)  :: control
  character(iotk_taglenx),   intent(in)  :: tag
  logical,                   intent(in)  :: binary
  integer,                   intent(out) :: ierr
  integer(iotk_header_kind) :: header,header2
  integer :: taglen
  character(4) :: begin,end
  ierr = 0
  taglen = len_trim(tag)
  if(binary) then
    header  = control + taglen*(iotk_ncontrol+1)
    header2 = 128     + taglen*(iotk_ncontrol+1)
    write(unit,iostat=iostat) header
    write(unit,iostat=iostat) header2,tag(1:taglen)
  else
    select case(control)
    case(1)
      begin = "<"
      end   = ">"
    case(2)
      begin = "</"
      end   = ">"
    case(3)
      begin = "<"
      end   = "/>"
    case(4)
      begin = "<!--"
      end   = "-->"
    case(5)
      begin = "<?"
      end   = "?>"
    end select
    write(unit,"(a)",iostat=iostat) trim(begin)//tag(1:taglen)//trim(end)
  end if
  if(iostat/=0) ierr = __LINE__
end subroutine write_tag

subroutine scan_tag(unit,direction,control,tag,binary,ierr)
  integer,                 intent(in)  :: unit
  integer,                 intent(in)  :: direction
  integer,                 intent(out) :: control
  character(iotk_taglenx), intent(out) :: tag
  logical,                 intent(in)  :: binary
  integer,                 intent(out) :: ierr

  integer(iotk_header_kind) :: header
  integer :: taglen,pos,pos1,res
  character(2) :: begin,end
  character(iotk_linlenx) :: line
  logical :: found
  ierr = 0
  tag  = " "
  if(binary) then
    found = .false.
    do
      if(direction<0) then
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
      end if
      read(unit,iostat=iostat) header
      if(iostat/=0) then
        ierr = __LINE__
        return
      end if
      control = modulo(header,iotk_ncontrol+1)
      if(control/=0 .and. control/=128) then
        found = .true.
        taglen  = modulo(header/(iotk_ncontrol+1),iotk_taglenx+1)
        read(unit,iostat=iostat) header,tag(1:taglen)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
      end if
      if(direction<0) then
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
      end if
      if(found) exit
    end do
    if(direction<0) then
      backspace(unit,iostat=iostat)
      if(iostat/=0) then
        ierr = __LINE__
        return
      end if
    end if
  else
! RISISTEMARE IN MODO CHE SI POSSA AVERE NELLA TAG ANCHE < e >
    tag = " "
    if(direction>=0) then
      do
        read(unit,"(a)",iostat=iostat) line
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        pos = scan(line,"<")
        if(pos/=0) exit
      end do
      do
        pos1 = scan(line(pos+1:),">") + pos
        if(pos1/=pos) exit
!        tag(len_trim(tag)+2:) = trim(adjustl(line(pos+1:)))
!        tag(len_trim(tag)+2:) = trim(adjustl(line(pos:)))
        call append(tag,trim(adjustl(line(pos+1:))),.true.,ierr)
        if(ierr/=0) return
        pos = 0
        read(unit,"(a)",iostat=iostat) line
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
      end do
!      tag(len_trim(tag)+2:) = trim(adjustl(line(pos+1:pos1-1)))
!      tag(len_trim(tag)+2:) = trim(adjustl(line(pos:pos1)))
      call append(tag,trim(adjustl(line(pos+1:pos1-1))),.true.,ierr)
      if(ierr/=0) return
      res = len_trim(line(pos1+1:))
      if(res>0) then
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        read(unit,"(a)",iostat=iostat) line
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        res = len_trim(line)-res
        read(unit,"(a)",iostat=iostat,advance='no') line(1:res)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
      end if
    else
      read(unit,"(a)",iostat=iostat) line
      if(iostat/=0) then
        ierr = __LINE__
        return
      end if
      res = len_trim(line)
      do
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        read(unit,"(a)",iostat=iostat) line
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        pos = len_trim(line) - res
        pos = scan(line(1:pos),">",back=.true.)
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        if(pos/=0) exit
        res = 0
      end do
      do
        pos1 = scan(line(1:pos-1),"<",back=.true.)
        res = verify(tag," ")
        if(res==0) res=len(tag)
        if(pos1>0) exit
        tag(res-pos:res-2) = line(1:pos-1)
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        read(unit,"(a)",iostat=iostat) line
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        backspace(unit,iostat=iostat)
        if(iostat/=0) then
          ierr = __LINE__
          return
        end if
        pos = len_trim(line)+1
      end do
      read(unit,"(a)",iostat=iostat,advance="no") line(1:pos1-1)
      if(iostat/=0) then
        ierr = __LINE__
        return
      end if
      tag(res-pos+pos1:res-2) = line(pos1+1:pos-1)
      tag = adjustl(tag)
    end if
    pos = verify(tag," ")
    pos1 = len_trim(tag)
! UNA VOLTA RISISTEMATO SOPRA, FARE CONTROLLI PIU' STRINGENTI QUI
    if(tag(pos:pos)=="/" .and. tag(pos1:pos1)/="/") then
      control = 2
      tag = tag(pos+1:pos1)
    else if(tag(pos:pos)/="/" .and. tag(pos1:pos1)=="/") then
      control = 3
      tag = tag(pos:pos1-1)
    else if(tag(pos:pos)=="?" .and. tag(pos1:pos1)=="?") then
      control = 5
      tag = tag(pos+1:pos1-1)
    else if(tag(pos:pos+2)=="!--" .and. tag(pos1-1:pos1)=="--") then
      control = 4
      tag = tag(pos+3:pos1-2)
    else
      control = 1
      tag = tag(pos:pos1)
    end if
!    write(0,*) "**",control,trim(tag)
  end if
end subroutine scan_tag

subroutine tag_parse(tag,name,attr,ierr)
  character(iotk_taglenx), intent(in)  :: tag
  character(iotk_namlenx), intent(out) :: name
  character(iotk_attlenx), intent(out) :: attr
  integer,                 intent(out) :: ierr
  integer :: pos,lenatt
  ierr = 0
  if(verify(tag(1:1),iotk_namcharfirst)/=0) ierr= __LINE__
  if(ierr/=0) return
  pos = scan(tag," ")
  if(pos==0.or.pos>len(name)+1) ierr= __LINE__
  if(ierr/=0) return
  name = tag(1:pos-1)
  lenatt = len_trim(tag(pos:))
  if(lenatt>iotk_attlenx) ierr= __LINE__
  if(ierr/=0) return
  if(lenatt>0) then
    attr = tag(pos:pos+lenatt-1)
  else
    attr = " "
  end if
end subroutine tag_parse

subroutine check_iotk_attr(unit,attr,ierr)
  integer,                 intent(in)  :: unit
  character(iotk_attlenx), intent(in)  :: attr
  integer,                 intent(out) :: ierr
  character(iotk_vallenx) :: version,binary_format
  logical :: binary,rbinary
  ierr = 0
  call iotk_scan_attr(attr,"version",version,ierr=ierr)
  if(ierr==0) then
    if(version_number(version,1)<0 .or. version_number(version,2)<0 &
       .or. version_number(version,3)<0) ierr= __LINE__
    if(version_number(version,1)> version_number(iotk_version,1) .or. &
       version_number(version,1)==version_number(iotk_version,1) .and. &
       version_number(version,2)> version_number(iotk_version,2)) ierr= __LINE__
  else if(ierr<0) then
    ierr = 0
  end if
  if(ierr==0) then
    call iotk_scan_attr(attr,"binary",rbinary,ierr=ierr)
    if(ierr==0) then
      call iotk_inquire(unit,binary,ierr=ierr)
      if(ierr/=0) return
      if(rbinary .neqv. binary) ierr= __LINE__
    else if(ierr<0) then
      ierr = 0
    end if
  end if
  if(ierr==0) then
    call iotk_scan_attr(attr,"binary_format",binary_format,ierr=ierr)
    if(ierr==0) then
      if(binary_format/=iotk_binary_format) ierr=__LINE__
    else if(ierr<0) then
      ierr = 0
    end if
  end if
end subroutine check_iotk_attr

subroutine iotk_scan(unit,direction,control,name,attr,binary,ierr)
  integer,                 intent(in)  :: unit
  integer,                 intent(in)  :: direction
  integer,                 intent(in)  :: control
  character(iotk_namlenx), intent(in)  :: name
  character(iotk_attlenx), intent(out) :: attr
  logical,                 intent(in)  :: binary
  integer,                 intent(out) :: ierr

  character(iotk_taglenx) :: tag
  character(iotk_namlenx) :: r_name
  integer :: level,r_control,pos,pos1
  logical :: lall,match

  if(control==2 .and. direction<0) then
    ierr=__LINE__
    return
  end if
  level = 0
  ierr = 0
  do
    lall=.false.
    if(direction>=0 .and. level==0) lall=.true.
    if(direction<0  .and. level==0 .and. control/=1) lall=.true.
    if(direction<0  .and. level==1 .and. control==1) lall=.true.
    call scan_tag(unit,direction,r_control,tag,binary,ierr)
    if(ierr/=0) return
    if(r_control==4) cycle
    if(lall .or. r_control==5) call tag_parse(tag,r_name,attr,ierr)
    if(ierr/=0) return
    match = lall .and. r_control==control .and. r_name==name
    if(r_control==5) then
      if(r_name=="iotk") call check_iotk_attr(unit,attr,ierr)
      if(ierr/=0) return
    end if
    select case(direction)
    case(0:)
      select case(r_control)
      case(1)
        if(level==0 .and. match) exit
        level = level + 1
      case(2)
        if(level==0 .and. match) exit
        if(level==0) then
          call scan_tag(unit,-1,r_control,tag,binary,ierr)
          if(ierr==0) ierr=-1
          return
        end if
        level = level - 1
      case(3)
        if(level==0 .and. match) exit
      case(5)
        if(level==0 .and. match) exit
      end select
    case(:-1)
      select case(r_control)
      case(2)
        level = level + 1
      case(1)
        if(level==1 .and. match) exit
        if(level==0) then
          call scan_tag(unit,+1,r_control,tag,binary,ierr)
          if(ierr==0) ierr=-1
          return
        end if
        level = level - 1
      case(3)
        if(level==0 .and. match) exit
      case(5)
        if(level==0 .and. match) exit
      end select
    end select
  end do
  if(direction<0) then
    call scan_tag(unit,+1,r_control,tag,binary,ierr)
    return
  end if
end subroutine iotk_scan

subroutine iotk_write_begin(unit,name,attr,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(in)  :: attr
  integer,      optional, intent(out) :: ierr
  character(iotk_taglenx) :: tag
  logical :: binary
  integer :: ierrl
  ierrl = 0
  if(.not.check_name(name)) ierrl=__LINE__
  if(present(attr)) then
    if(.not.check_attr(attr)) ierrl=__LINE__
  end if
  if(ierrl==0 .and. present(attr)) then
    tag = trim(name)//" "//trim(attr)
  else
    tag = trim(name)
  end if
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl==0) call write_tag(unit,1,tag,binary,ierrl)
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_begin
    
subroutine iotk_write_end(unit,name,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  integer,      optional, intent(out) :: ierr
  character(iotk_taglenx) :: tag
  logical :: binary
  integer :: ierrl
  ierrl = 0
  if(.not.check_name(name)) ierrl=__LINE__
  tag = trim(name)
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl==0) call write_tag(unit,2,tag,binary,ierrl)
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_end
    
subroutine iotk_write_pi(unit,name,attr,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(in)  :: attr
  integer,      optional, intent(out) :: ierr
  character(iotk_taglenx) :: tag
  logical :: binary
  integer :: ierrl
  ierrl = 0
  if(.not.check_name(name)) ierrl=__LINE__
  if(present(attr)) then
    if(.not.check_attr(attr)) ierrl=__LINE__
  end if
  if(present(attr)) then
    tag = trim(name)//" "//trim(attr)
  else
    tag = trim(name)
  end if
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl==0) call write_tag(unit,5,tag,binary,ierrl)
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_pi

subroutine iotk_write_empty(unit,name,attr,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(in)  :: attr
  integer,      optional, intent(out) :: ierr
  character(iotk_taglenx) :: tag
  logical :: binary
  integer :: ierrl
  ierrl = 0
  if(.not.check_name(name)) ierrl=2
  if(present(attr)) then
    if(.not.check_attr(attr)) ierrl=2
  end if
  if(present(attr)) then
    tag = trim(name)//" "//trim(attr)
  else
    tag = trim(name)
  end if
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl==0) call write_tag(unit,3,tag,binary,ierrl)
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_empty

subroutine iotk_scan_begin(unit,name,attr,found,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(out) :: attr
  logical,      optional, intent(out) :: found
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: namel
  character(iotk_attlenx) :: attrl
  logical :: binary
  integer :: ierrl
  namel = name
  ierrl = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl==0) call iotk_scan(unit, 1,1,namel,attrl,binary,ierrl)
  if(ierrl<0)  call iotk_scan(unit,-1,1,namel,attrl,binary,ierrl)
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(ierrl==0 .and. present(attr)) then
    if(len(attr)>=len_trim(attrl)) then
      attr=attrl
    else
      attr=" "
      ierrl = __LINE__
    end if
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. .not.present(found)) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_scan_begin

subroutine iotk_scan_end(unit,name,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: namel
  logical :: binary
  character(iotk_attlenx) :: attrl
  integer :: ierrl
  namel = name
  ierrl = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl==0) call iotk_scan(unit,1,2,namel,attrl,binary,ierrl)
  if(ierrl==0 .and. len_trim(attrl)/=0) ierrl=3
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_scan_end

subroutine iotk_scan_pi(unit,name,attr,found,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(out) :: attr
  logical,      optional, intent(out) :: found
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: namel
  character(iotk_attlenx) :: attrl
  logical :: binary
  integer :: ierrl
  namel = name
  ierrl = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl==0) call iotk_scan(unit,1,5,namel,attrl,binary,ierrl)
  if(ierrl<0) call iotk_scan(unit,-1,5,namel,attrl,binary,ierrl)
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(ierrl==0 .and. present(attr)) then
    if(len(attr)>=len_trim(attrl)) then
      attr=attrl
    else
      attr=" "
      ierrl = __LINE__
    end if
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. .not.present(found)) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_scan_pi

subroutine iotk_scan_empty(unit,name,attr,found,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  character(*), optional, intent(out) :: attr
  logical,      optional, intent(out) :: found
  integer,      optional, intent(out) :: ierr
  character(iotk_namlenx) :: namel
  character(iotk_attlenx) :: attrl
  logical :: binary
  integer :: ierrl
  namel = name
  ierrl = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl==0) call iotk_scan(unit,1,3,namel,attrl,binary,ierrl)
  if(ierrl<0) call iotk_scan(unit,-1,3,namel,attrl,binary,ierrl)
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(ierrl==0 .and. present(attr)) then
    if(len(attr)>=len_trim(attrl)) then
      attr=attrl
    else
      attr=" "
      ierrl = __LINE__
    end if
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. .not.present(found)) call iotk_error(unit,ierrl)
  end if
end subroutine iotk_scan_empty

subroutine write_dat_begin_aux(unit,name,type,kind,size,len,binary,fmt,ierr)
  integer,      intent(in)  :: unit
  character(*), intent(in)  :: name
  integer,      intent(in)  :: type
  integer,      intent(in)  :: kind
  integer,      intent(in)  :: size
  integer,      intent(in)  :: len
  logical,      intent(in)  :: binary
  character(*), intent(in)  :: fmt
  integer,      intent(out) :: ierr
  character(iotk_attlenx) :: attr
  ierr = 0
  call iotk_write_attr(attr,"type",type_names(type),first=.true.,ierr=ierr)
  if(ierr/=0) return
  call iotk_write_attr(attr,"size",size,ierr=ierr)
  if(ierr/=0) return
  if(binary) call iotk_write_attr(attr,"kind",kind,ierr=ierr)
  if(ierr/=0) return
  if(type==5) call iotk_write_attr(attr,"len",len,ierr=ierr)
  if(ierr/=0) return
  if(.not.binary) then
    if(fmt/="!") call iotk_write_attr(attr,"fmt",trim(fmt))
  end if
  if(ierr/=0) return
  call iotk_write_begin(unit,name,attr,ierr)
end subroutine write_dat_begin_aux

subroutine iotk_copy_dat(source,dest,source_binary,dest_binary,name,attr,maxsize,ierr)
  integer,      intent(in)  :: source
  integer,      intent(in)  :: dest
  logical,      intent(in)  :: source_binary
  logical,      intent(in)  :: dest_binary
  character(*), intent(in)  :: name
  character(*), intent(in)  :: attr
  integer,      intent(in)  :: maxsize
  integer,      intent(out) :: ierr
  integer :: type,kind,size,len
  character(iotk_vallenx) :: fmt
  character(iotk_attlenx) :: attr1
  ierr = 0
  call iotk_parse_dat(attr,source_binary,type,kind,size,len,fmt,ierr)
  if(type==-1) ierr = __LINE__
  if(ierr/=0) return
  if(size==-1) ierr = __LINE__
  if(ierr/=0) return
  if(len==-1 .and. type==5) ierr = __LINE__
  if(ierr/=0) return
  if(size<=maxsize .or. maxsize==-1 .or. dest_binary) then
    call iotk_copy_dat_aux(source,dest,source_binary,dest_binary,name, &
              type,kind,size,len,fmt,ierr)
  else
    attr1 = attr
    call iotk_write_attr (attr1,"trunc",.true.,ierr=ierr)
    if(ierr/=0) return
    call iotk_write_empty(dest,name,attr=attr1,ierr=ierr)
  end if
end subroutine iotk_copy_dat

subroutine iotk_copy_dat_aux(source,dest,source_binary,dest_binary,name, &
              type,kind,size,len,fmt,ierr)
  integer,      intent(in)  :: source
  integer,      intent(in)  :: dest
  logical,      intent(in)  :: source_binary
  logical,      intent(in)  :: dest_binary
  character(*), intent(in)  :: name
  integer,      intent(in)  :: type
  integer,      intent(in)  :: kind
  integer,      intent(in)  :: size
  integer,      intent(in)  :: len
  character(*), intent(in)  :: fmt
  integer,      intent(out) :: ierr

  logical  (__IOTK_T1_K1), allocatable :: dat_lo(:)
  integer  (__IOTK_T2_K1), allocatable :: dat_in(:)
  real     (__IOTK_T3_K1), allocatable :: dat_re(:)
  complex  (__IOTK_T4_K1), allocatable :: dat_co(:)
  character(len=len),      allocatable :: dat_ch(:)

  ierr = 0
  select case(type)
  case(1)
    allocate(dat_lo(size))
    call iotk_scan_dat_aux_1_1_1(source,dat_lo,kind,len,source_binary,fmt,ierr)
    if(ierr/=0) return
    call iotk_write_dat(dest,name,dat_lo,ierr=ierr)
    if(ierr/=0) return
    deallocate(dat_lo)
  case(2)
    allocate(dat_in(size))
    call iotk_scan_dat_aux_2_1_1(source,dat_in,kind,len,source_binary,fmt,ierr)
    if(ierr/=0) return
    call iotk_write_dat(dest,name,dat_in,ierr=ierr)
    if(ierr/=0) return
    deallocate(dat_in)
  case(3)
    allocate(dat_re(size))
    call iotk_scan_dat_aux_3_1_1(source,dat_re,kind,len,source_binary,fmt,ierr)
    if(ierr/=0) return
    call iotk_write_dat(dest,name,dat_re,ierr=ierr)
    if(ierr/=0) return
    deallocate(dat_re)
  case(4)
    allocate(dat_co(size))
    call iotk_scan_dat_aux_4_1_1(source,dat_co,kind,len,source_binary,fmt,ierr)
    if(ierr/=0) return
    call iotk_write_dat(dest,name,dat_co,ierr=ierr)
    if(ierr/=0) return
    deallocate(dat_co)
  case(5)
    allocate(dat_ch(size))
    call iotk_scan_dat_aux_5_1_1(source,dat_ch,kind,len,source_binary,fmt,ierr)
    if(ierr/=0) return
    call iotk_write_dat(dest,name,dat_ch,ierr=ierr)
    if(ierr/=0) return
    deallocate(dat_ch)
  end select
end subroutine iotk_copy_dat_aux

subroutine iotk_parse_dat(attr,binary,type,kind,size,len,fmt,ierr)
  character(*), intent(in)  :: attr
  logical,      intent(in)  :: binary
  integer,      intent(out) :: type
  integer,      intent(out) :: kind
  integer,      intent(out) :: size
  integer,      intent(out) :: len
  character(*), intent(out) :: fmt
  integer,      intent(out) :: ierr
  character(iotk_vallenx) :: typename
  call iotk_scan_attr(attr,"type",typename,ierr=ierr)
  if(ierr<0) then
    type = -1
    ierr = 0
  else if(ierr>0) then
    return
  else
    type = type_number(typename)
  end if
  if(binary) then
    call iotk_scan_attr(attr,"kind",kind,ierr=ierr)
    if(ierr<0) then
      kind = -1
      ierr = 0
    else if(ierr>0) then
      return
    end if
  else
    kind = -1
  end if
  call iotk_scan_attr(attr,"size",size,ierr=ierr)
  if(ierr<0) then
    size = -1
    ierr = 0
  else if(ierr>0) then
    return
  end if
  call iotk_scan_attr(attr,"len", len, ierr=ierr)
  if(ierr<0) then
    len = -1
    ierr = 0
  else if(ierr>0) then
    return
  end if
  if(.not. binary) then
    call iotk_scan_attr(attr,"fmt", fmt, ierr=ierr)
    if(ierr<0) then
      fmt = "!"
      ierr = 0
    else if(ierr>0) then
      return
    end if
  else
    fmt = "!"
  end if
end subroutine iotk_parse_dat

subroutine scan_dat_begin_aux(unit,name,type,kind,size,len,binary,fmt,ierr)
  integer,      intent(in)  :: unit
  character(*), intent(in)  :: name
  integer,      intent(out) :: type
  integer,      intent(out) :: kind
  integer,      intent(out) :: size
  integer,      intent(out) :: len
  logical,      intent(in)  :: binary
  character(*), intent(out) :: fmt
  integer,      intent(out) :: ierr
  integer :: ierrl
  character(iotk_attlenx) :: attr
  ierr = 0
  call iotk_scan_begin(unit,name,attr,ierr=ierr)
  if(ierr/=0) return
  call iotk_parse_dat(attr,binary,type,kind,size,len,fmt,ierr)
  if(ierr/=0) then
    call iotk_scan_end(unit,name,ierr=ierrl)
    return
  end if
end subroutine scan_dat_begin_aux

#ifdef __IOTK_T1
#define __TYPE __IOTK_T1
#ifdef __IOTK_T1_K1
#define __KIND kind=__IOTK_T1_K1
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_1_1_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_1_0

subroutine iotk_scan_dat_aux_1_1_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2) :: dat2
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3) :: dat3
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_1_0

subroutine iotk_scan_dat_1_1_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_1_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_1_0


subroutine iotk_write_attr_1_1_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_1_0

subroutine iotk_scan_attr_1_1_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_1_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_1_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_1_1

subroutine iotk_scan_dat_aux_1_1_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_1_1

subroutine iotk_scan_dat_1_1_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_1_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_1_1


subroutine iotk_write_attr_1_1_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_1_1

subroutine iotk_scan_attr_1_1_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_1_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_1_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_1_2

subroutine iotk_scan_dat_aux_1_1_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_1_2

subroutine iotk_scan_dat_1_1_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_1_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_1_2


subroutine iotk_write_attr_1_1_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_1_2

subroutine iotk_scan_attr_1_1_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_1_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_1_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_1_3

subroutine iotk_scan_dat_aux_1_1_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_1_3

subroutine iotk_scan_dat_1_1_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_1_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_1_3


subroutine iotk_write_attr_1_1_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_1_3

subroutine iotk_scan_attr_1_1_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_1_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_1_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_1_4

subroutine iotk_scan_dat_aux_1_1_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_1_4

subroutine iotk_scan_dat_1_1_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_1_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_1_4


subroutine iotk_write_attr_1_1_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_1_4

subroutine iotk_scan_attr_1_1_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_1_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_1_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_1_5

subroutine iotk_scan_dat_aux_1_1_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_1_5

subroutine iotk_scan_dat_1_1_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_1_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_1_5


subroutine iotk_write_attr_1_1_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_1_5

subroutine iotk_scan_attr_1_1_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_1_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T1_K2
#define __KIND kind=__IOTK_T1_K2
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_1_2_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_2_0

subroutine iotk_scan_dat_aux_1_2_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1) :: dat1
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3) :: dat3
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_2_0

subroutine iotk_scan_dat_1_2_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_2_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_2_0


subroutine iotk_write_attr_1_2_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_2_0

subroutine iotk_scan_attr_1_2_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_2_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_2_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_2_1

subroutine iotk_scan_dat_aux_1_2_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_2_1

subroutine iotk_scan_dat_1_2_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_2_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_2_1


subroutine iotk_write_attr_1_2_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_2_1

subroutine iotk_scan_attr_1_2_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_2_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_2_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_2_2

subroutine iotk_scan_dat_aux_1_2_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_2_2

subroutine iotk_scan_dat_1_2_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_2_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_2_2


subroutine iotk_write_attr_1_2_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_2_2

subroutine iotk_scan_attr_1_2_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_2_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_2_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_2_3

subroutine iotk_scan_dat_aux_1_2_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_2_3

subroutine iotk_scan_dat_1_2_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_2_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_2_3


subroutine iotk_write_attr_1_2_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_2_3

subroutine iotk_scan_attr_1_2_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_2_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_2_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_2_4

subroutine iotk_scan_dat_aux_1_2_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_2_4

subroutine iotk_scan_dat_1_2_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_2_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_2_4


subroutine iotk_write_attr_1_2_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_2_4

subroutine iotk_scan_attr_1_2_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_2_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_2_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_2_5

subroutine iotk_scan_dat_aux_1_2_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_2_5

subroutine iotk_scan_dat_1_2_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_2_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_2_5


subroutine iotk_write_attr_1_2_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_2_5

subroutine iotk_scan_attr_1_2_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_2_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T1_K3
#define __KIND kind=__IOTK_T1_K3
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_1_3_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_3_0

subroutine iotk_scan_dat_aux_1_3_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1) :: dat1
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2) :: dat2
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_3_0

subroutine iotk_scan_dat_1_3_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_3_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_3_0


subroutine iotk_write_attr_1_3_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_3_0

subroutine iotk_scan_attr_1_3_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_3_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_3_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_3_1

subroutine iotk_scan_dat_aux_1_3_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_3_1

subroutine iotk_scan_dat_1_3_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_3_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_3_1


subroutine iotk_write_attr_1_3_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_3_1

subroutine iotk_scan_attr_1_3_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_3_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_3_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_3_2

subroutine iotk_scan_dat_aux_1_3_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_3_2

subroutine iotk_scan_dat_1_3_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_3_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_3_2


subroutine iotk_write_attr_1_3_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_3_2

subroutine iotk_scan_attr_1_3_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_3_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_3_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_3_3

subroutine iotk_scan_dat_aux_1_3_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_3_3

subroutine iotk_scan_dat_1_3_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_3_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_3_3


subroutine iotk_write_attr_1_3_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_3_3

subroutine iotk_scan_attr_1_3_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_3_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_3_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_3_4

subroutine iotk_scan_dat_aux_1_3_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_3_4

subroutine iotk_scan_dat_1_3_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_3_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_3_4


subroutine iotk_write_attr_1_3_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_3_4

subroutine iotk_scan_attr_1_3_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_3_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_3_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_3_5

subroutine iotk_scan_dat_aux_1_3_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T1_K4
  __TYPE (__IOTK_T1_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_3_5

subroutine iotk_scan_dat_1_3_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_3_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_3_5


subroutine iotk_write_attr_1_3_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_3_5

subroutine iotk_scan_attr_1_3_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_3_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T1_K4
#define __KIND kind=__IOTK_T1_K4
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_1_4_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_4_0

subroutine iotk_scan_dat_aux_1_4_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1) :: dat1
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2) :: dat2
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3) :: dat3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_4_0

subroutine iotk_scan_dat_1_4_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_4_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_4_0


subroutine iotk_write_attr_1_4_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_4_0

subroutine iotk_scan_attr_1_4_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_4_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_4_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_4_1

subroutine iotk_scan_dat_aux_1_4_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_4_1

subroutine iotk_scan_dat_1_4_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_4_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_4_1


subroutine iotk_write_attr_1_4_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_4_1

subroutine iotk_scan_attr_1_4_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_4_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_4_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_4_2

subroutine iotk_scan_dat_aux_1_4_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_4_2

subroutine iotk_scan_dat_1_4_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_4_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_4_2


subroutine iotk_write_attr_1_4_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_4_2

subroutine iotk_scan_attr_1_4_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_4_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_4_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_4_3

subroutine iotk_scan_dat_aux_1_4_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_4_3

subroutine iotk_scan_dat_1_4_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_4_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_4_3


subroutine iotk_write_attr_1_4_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_4_3

subroutine iotk_scan_attr_1_4_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_4_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_4_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_4_4

subroutine iotk_scan_dat_aux_1_4_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_4_4

subroutine iotk_scan_dat_1_4_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_4_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_4_4


subroutine iotk_write_attr_1_4_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_4_4

subroutine iotk_scan_attr_1_4_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_4_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_1_4_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(1,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,1,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_1_4_5

subroutine iotk_scan_dat_aux_1_4_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T1_K1
  __TYPE (__IOTK_T1_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T1_K2
  __TYPE (__IOTK_T1_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T1_K3
  __TYPE (__IOTK_T1_K3), allocatable :: dat3 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T1_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T1_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T1_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(1,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_1_4_5

subroutine iotk_scan_dat_1_4_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 1
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 1) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_1_4_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_1_4_5


subroutine iotk_write_attr_1_4_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(1,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_1_4_5

subroutine iotk_scan_attr_1_4_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"l100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_1_4_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#undef __COMPLEX_FACTOR
#undef __TYPE
#endif
#ifdef __IOTK_T2
#define __TYPE __IOTK_T2
#ifdef __IOTK_T2_K1
#define __KIND kind=__IOTK_T2_K1
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_2_1_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_1_0

subroutine iotk_scan_dat_aux_2_1_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2) :: dat2
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3) :: dat3
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_1_0

subroutine iotk_scan_dat_2_1_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_1_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_1_0


subroutine iotk_write_attr_2_1_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_1_0

subroutine iotk_scan_attr_2_1_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_1_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_1_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_1_1

subroutine iotk_scan_dat_aux_2_1_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_1_1

subroutine iotk_scan_dat_2_1_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_1_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_1_1


subroutine iotk_write_attr_2_1_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_1_1

subroutine iotk_scan_attr_2_1_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_1_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_1_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_1_2

subroutine iotk_scan_dat_aux_2_1_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_1_2

subroutine iotk_scan_dat_2_1_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_1_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_1_2


subroutine iotk_write_attr_2_1_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_1_2

subroutine iotk_scan_attr_2_1_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_1_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_1_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_1_3

subroutine iotk_scan_dat_aux_2_1_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_1_3

subroutine iotk_scan_dat_2_1_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_1_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_1_3


subroutine iotk_write_attr_2_1_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_1_3

subroutine iotk_scan_attr_2_1_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_1_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_1_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_1_4

subroutine iotk_scan_dat_aux_2_1_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_1_4

subroutine iotk_scan_dat_2_1_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_1_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_1_4


subroutine iotk_write_attr_2_1_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_1_4

subroutine iotk_scan_attr_2_1_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_1_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_1_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_1_5

subroutine iotk_scan_dat_aux_2_1_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_1_5

subroutine iotk_scan_dat_2_1_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_1_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_1_5


subroutine iotk_write_attr_2_1_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_1_5

subroutine iotk_scan_attr_2_1_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_1_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T2_K2
#define __KIND kind=__IOTK_T2_K2
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_2_2_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_2_0

subroutine iotk_scan_dat_aux_2_2_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1) :: dat1
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3) :: dat3
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_2_0

subroutine iotk_scan_dat_2_2_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_2_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_2_0


subroutine iotk_write_attr_2_2_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_2_0

subroutine iotk_scan_attr_2_2_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_2_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_2_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_2_1

subroutine iotk_scan_dat_aux_2_2_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_2_1

subroutine iotk_scan_dat_2_2_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_2_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_2_1


subroutine iotk_write_attr_2_2_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_2_1

subroutine iotk_scan_attr_2_2_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_2_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_2_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_2_2

subroutine iotk_scan_dat_aux_2_2_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_2_2

subroutine iotk_scan_dat_2_2_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_2_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_2_2


subroutine iotk_write_attr_2_2_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_2_2

subroutine iotk_scan_attr_2_2_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_2_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_2_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_2_3

subroutine iotk_scan_dat_aux_2_2_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_2_3

subroutine iotk_scan_dat_2_2_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_2_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_2_3


subroutine iotk_write_attr_2_2_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_2_3

subroutine iotk_scan_attr_2_2_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_2_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_2_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_2_4

subroutine iotk_scan_dat_aux_2_2_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_2_4

subroutine iotk_scan_dat_2_2_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_2_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_2_4


subroutine iotk_write_attr_2_2_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_2_4

subroutine iotk_scan_attr_2_2_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_2_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_2_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_2_5

subroutine iotk_scan_dat_aux_2_2_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_2_5

subroutine iotk_scan_dat_2_2_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_2_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_2_5


subroutine iotk_write_attr_2_2_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_2_5

subroutine iotk_scan_attr_2_2_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_2_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T2_K3
#define __KIND kind=__IOTK_T2_K3
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_2_3_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_3_0

subroutine iotk_scan_dat_aux_2_3_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1) :: dat1
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2) :: dat2
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_3_0

subroutine iotk_scan_dat_2_3_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_3_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_3_0


subroutine iotk_write_attr_2_3_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_3_0

subroutine iotk_scan_attr_2_3_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_3_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_3_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_3_1

subroutine iotk_scan_dat_aux_2_3_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_3_1

subroutine iotk_scan_dat_2_3_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_3_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_3_1


subroutine iotk_write_attr_2_3_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_3_1

subroutine iotk_scan_attr_2_3_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_3_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_3_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_3_2

subroutine iotk_scan_dat_aux_2_3_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_3_2

subroutine iotk_scan_dat_2_3_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_3_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_3_2


subroutine iotk_write_attr_2_3_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_3_2

subroutine iotk_scan_attr_2_3_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_3_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_3_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_3_3

subroutine iotk_scan_dat_aux_2_3_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_3_3

subroutine iotk_scan_dat_2_3_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_3_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_3_3


subroutine iotk_write_attr_2_3_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_3_3

subroutine iotk_scan_attr_2_3_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_3_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_3_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_3_4

subroutine iotk_scan_dat_aux_2_3_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_3_4

subroutine iotk_scan_dat_2_3_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_3_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_3_4


subroutine iotk_write_attr_2_3_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_3_4

subroutine iotk_scan_attr_2_3_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_3_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_3_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_3_5

subroutine iotk_scan_dat_aux_2_3_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T2_K4
  __TYPE (__IOTK_T2_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_3_5

subroutine iotk_scan_dat_2_3_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_3_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_3_5


subroutine iotk_write_attr_2_3_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_3_5

subroutine iotk_scan_attr_2_3_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_3_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T2_K4
#define __KIND kind=__IOTK_T2_K4
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_2_4_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_4_0

subroutine iotk_scan_dat_aux_2_4_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1) :: dat1
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2) :: dat2
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3) :: dat3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_4_0

subroutine iotk_scan_dat_2_4_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_4_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_4_0


subroutine iotk_write_attr_2_4_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_4_0

subroutine iotk_scan_attr_2_4_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_4_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_4_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_4_1

subroutine iotk_scan_dat_aux_2_4_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_4_1

subroutine iotk_scan_dat_2_4_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_4_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_4_1


subroutine iotk_write_attr_2_4_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_4_1

subroutine iotk_scan_attr_2_4_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_4_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_4_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_4_2

subroutine iotk_scan_dat_aux_2_4_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_4_2

subroutine iotk_scan_dat_2_4_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_4_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_4_2


subroutine iotk_write_attr_2_4_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_4_2

subroutine iotk_scan_attr_2_4_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_4_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_4_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_4_3

subroutine iotk_scan_dat_aux_2_4_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_4_3

subroutine iotk_scan_dat_2_4_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_4_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_4_3


subroutine iotk_write_attr_2_4_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_4_3

subroutine iotk_scan_attr_2_4_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_4_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_4_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_4_4

subroutine iotk_scan_dat_aux_2_4_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_4_4

subroutine iotk_scan_dat_2_4_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_4_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_4_4


subroutine iotk_write_attr_2_4_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_4_4

subroutine iotk_scan_attr_2_4_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_4_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_2_4_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(2,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,2,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_2_4_5

subroutine iotk_scan_dat_aux_2_4_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T2_K1
  __TYPE (__IOTK_T2_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T2_K2
  __TYPE (__IOTK_T2_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T2_K3
  __TYPE (__IOTK_T2_K3), allocatable :: dat3 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T2_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T2_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T2_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(2,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_2_4_5

subroutine iotk_scan_dat_2_4_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 2
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 2) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_2_4_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_2_4_5


subroutine iotk_write_attr_2_4_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(2,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_2_4_5

subroutine iotk_scan_attr_2_4_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"i100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_2_4_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#undef __COMPLEX_FACTOR
#undef __TYPE
#endif
#ifdef __IOTK_T3
#define __TYPE __IOTK_T3
#ifdef __IOTK_T3_K1
#define __KIND kind=__IOTK_T3_K1
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_3_1_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_1_0

subroutine iotk_scan_dat_aux_3_1_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2) :: dat2
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3) :: dat3
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_1_0

subroutine iotk_scan_dat_3_1_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_1_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_1_0


subroutine iotk_write_attr_3_1_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_1_0

subroutine iotk_scan_attr_3_1_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_1_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_1_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_1_1

subroutine iotk_scan_dat_aux_3_1_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_1_1

subroutine iotk_scan_dat_3_1_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_1_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_1_1


subroutine iotk_write_attr_3_1_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_1_1

subroutine iotk_scan_attr_3_1_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_1_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_1_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_1_2

subroutine iotk_scan_dat_aux_3_1_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_1_2

subroutine iotk_scan_dat_3_1_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_1_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_1_2


subroutine iotk_write_attr_3_1_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_1_2

subroutine iotk_scan_attr_3_1_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_1_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_1_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_1_3

subroutine iotk_scan_dat_aux_3_1_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_1_3

subroutine iotk_scan_dat_3_1_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_1_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_1_3


subroutine iotk_write_attr_3_1_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_1_3

subroutine iotk_scan_attr_3_1_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_1_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_1_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_1_4

subroutine iotk_scan_dat_aux_3_1_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_1_4

subroutine iotk_scan_dat_3_1_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_1_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_1_4


subroutine iotk_write_attr_3_1_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_1_4

subroutine iotk_scan_attr_3_1_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_1_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_1_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_1_5

subroutine iotk_scan_dat_aux_3_1_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_1_5

subroutine iotk_scan_dat_3_1_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_1_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_1_5


subroutine iotk_write_attr_3_1_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_1_5

subroutine iotk_scan_attr_3_1_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_1_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T3_K2
#define __KIND kind=__IOTK_T3_K2
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_3_2_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_2_0

subroutine iotk_scan_dat_aux_3_2_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1) :: dat1
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3) :: dat3
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_2_0

subroutine iotk_scan_dat_3_2_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_2_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_2_0


subroutine iotk_write_attr_3_2_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_2_0

subroutine iotk_scan_attr_3_2_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_2_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_2_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_2_1

subroutine iotk_scan_dat_aux_3_2_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_2_1

subroutine iotk_scan_dat_3_2_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_2_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_2_1


subroutine iotk_write_attr_3_2_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_2_1

subroutine iotk_scan_attr_3_2_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_2_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_2_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_2_2

subroutine iotk_scan_dat_aux_3_2_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_2_2

subroutine iotk_scan_dat_3_2_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_2_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_2_2


subroutine iotk_write_attr_3_2_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_2_2

subroutine iotk_scan_attr_3_2_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_2_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_2_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_2_3

subroutine iotk_scan_dat_aux_3_2_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_2_3

subroutine iotk_scan_dat_3_2_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_2_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_2_3


subroutine iotk_write_attr_3_2_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_2_3

subroutine iotk_scan_attr_3_2_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_2_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_2_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_2_4

subroutine iotk_scan_dat_aux_3_2_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_2_4

subroutine iotk_scan_dat_3_2_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_2_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_2_4


subroutine iotk_write_attr_3_2_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_2_4

subroutine iotk_scan_attr_3_2_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_2_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_2_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_2_5

subroutine iotk_scan_dat_aux_3_2_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_2_5

subroutine iotk_scan_dat_3_2_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_2_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_2_5


subroutine iotk_write_attr_3_2_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_2_5

subroutine iotk_scan_attr_3_2_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_2_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T3_K3
#define __KIND kind=__IOTK_T3_K3
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_3_3_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_3_0

subroutine iotk_scan_dat_aux_3_3_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1) :: dat1
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2) :: dat2
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_3_0

subroutine iotk_scan_dat_3_3_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_3_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_3_0


subroutine iotk_write_attr_3_3_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_3_0

subroutine iotk_scan_attr_3_3_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_3_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_3_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_3_1

subroutine iotk_scan_dat_aux_3_3_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_3_1

subroutine iotk_scan_dat_3_3_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_3_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_3_1


subroutine iotk_write_attr_3_3_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_3_1

subroutine iotk_scan_attr_3_3_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_3_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_3_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_3_2

subroutine iotk_scan_dat_aux_3_3_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_3_2

subroutine iotk_scan_dat_3_3_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_3_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_3_2


subroutine iotk_write_attr_3_3_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_3_2

subroutine iotk_scan_attr_3_3_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_3_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_3_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_3_3

subroutine iotk_scan_dat_aux_3_3_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_3_3

subroutine iotk_scan_dat_3_3_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_3_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_3_3


subroutine iotk_write_attr_3_3_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_3_3

subroutine iotk_scan_attr_3_3_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_3_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_3_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_3_4

subroutine iotk_scan_dat_aux_3_3_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_3_4

subroutine iotk_scan_dat_3_3_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_3_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_3_4


subroutine iotk_write_attr_3_3_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_3_4

subroutine iotk_scan_attr_3_3_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_3_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_3_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_3_5

subroutine iotk_scan_dat_aux_3_3_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T3_K4
  __TYPE (__IOTK_T3_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_3_5

subroutine iotk_scan_dat_3_3_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_3_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_3_5


subroutine iotk_write_attr_3_3_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_3_5

subroutine iotk_scan_attr_3_3_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_3_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T3_K4
#define __KIND kind=__IOTK_T3_K4
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_3_4_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_4_0

subroutine iotk_scan_dat_aux_3_4_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1) :: dat1
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2) :: dat2
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3) :: dat3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_4_0

subroutine iotk_scan_dat_3_4_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_4_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_4_0


subroutine iotk_write_attr_3_4_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_4_0

subroutine iotk_scan_attr_3_4_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_4_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_4_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_4_1

subroutine iotk_scan_dat_aux_3_4_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_4_1

subroutine iotk_scan_dat_3_4_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_4_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_4_1


subroutine iotk_write_attr_3_4_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_4_1

subroutine iotk_scan_attr_3_4_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_4_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_4_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_4_2

subroutine iotk_scan_dat_aux_3_4_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_4_2

subroutine iotk_scan_dat_3_4_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_4_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_4_2


subroutine iotk_write_attr_3_4_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_4_2

subroutine iotk_scan_attr_3_4_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_4_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_4_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_4_3

subroutine iotk_scan_dat_aux_3_4_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_4_3

subroutine iotk_scan_dat_3_4_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_4_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_4_3


subroutine iotk_write_attr_3_4_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_4_3

subroutine iotk_scan_attr_3_4_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_4_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_4_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_4_4

subroutine iotk_scan_dat_aux_3_4_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_4_4

subroutine iotk_scan_dat_3_4_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_4_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_4_4


subroutine iotk_write_attr_3_4_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_4_4

subroutine iotk_scan_attr_3_4_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_4_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_3_4_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(3,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,3,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_3_4_5

subroutine iotk_scan_dat_aux_3_4_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T3_K1
  __TYPE (__IOTK_T3_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T3_K2
  __TYPE (__IOTK_T3_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T3_K3
  __TYPE (__IOTK_T3_K3), allocatable :: dat3 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T3_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T3_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T3_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(3,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_3_4_5

subroutine iotk_scan_dat_3_4_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 3
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 3) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_3_4_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_3_4_5


subroutine iotk_write_attr_3_4_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(3,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_3_4_5

subroutine iotk_scan_attr_3_4_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_3_4_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#undef __COMPLEX_FACTOR
#undef __TYPE
#endif
#ifdef __IOTK_T4
#define __TYPE __IOTK_T4
#ifdef __IOTK_T4_K1
#define __KIND kind=__IOTK_T4_K1
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_4_1_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_1_0

subroutine iotk_scan_dat_aux_4_1_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2) :: dat2
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3) :: dat3
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_1_0

subroutine iotk_scan_dat_4_1_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_1_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_1_0


subroutine iotk_write_attr_4_1_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_1_0

subroutine iotk_scan_attr_4_1_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_1_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_1_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_1_1

subroutine iotk_scan_dat_aux_4_1_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_1_1

subroutine iotk_scan_dat_4_1_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_1_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_1_1


subroutine iotk_write_attr_4_1_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_1_1

subroutine iotk_scan_attr_4_1_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_1_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_1_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_1_2

subroutine iotk_scan_dat_aux_4_1_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_1_2

subroutine iotk_scan_dat_4_1_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_1_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_1_2


subroutine iotk_write_attr_4_1_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_1_2

subroutine iotk_scan_attr_4_1_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_1_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_1_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_1_3

subroutine iotk_scan_dat_aux_4_1_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_1_3

subroutine iotk_scan_dat_4_1_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_1_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_1_3


subroutine iotk_write_attr_4_1_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_1_3

subroutine iotk_scan_attr_4_1_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_1_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_1_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_1_4

subroutine iotk_scan_dat_aux_4_1_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_1_4

subroutine iotk_scan_dat_4_1_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_1_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_1_4


subroutine iotk_write_attr_4_1_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_1_4

subroutine iotk_scan_attr_4_1_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_1_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_1_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_1_5

subroutine iotk_scan_dat_aux_4_1_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_1_5

subroutine iotk_scan_dat_4_1_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_1_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_1_5


subroutine iotk_write_attr_4_1_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_1_5

subroutine iotk_scan_attr_4_1_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_1_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T4_K2
#define __KIND kind=__IOTK_T4_K2
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_4_2_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_2_0

subroutine iotk_scan_dat_aux_4_2_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1) :: dat1
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3) :: dat3
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_2_0

subroutine iotk_scan_dat_4_2_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_2_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_2_0


subroutine iotk_write_attr_4_2_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_2_0

subroutine iotk_scan_attr_4_2_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_2_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_2_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_2_1

subroutine iotk_scan_dat_aux_4_2_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_2_1

subroutine iotk_scan_dat_4_2_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_2_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_2_1


subroutine iotk_write_attr_4_2_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_2_1

subroutine iotk_scan_attr_4_2_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_2_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_2_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_2_2

subroutine iotk_scan_dat_aux_4_2_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_2_2

subroutine iotk_scan_dat_4_2_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_2_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_2_2


subroutine iotk_write_attr_4_2_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_2_2

subroutine iotk_scan_attr_4_2_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_2_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_2_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_2_3

subroutine iotk_scan_dat_aux_4_2_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_2_3

subroutine iotk_scan_dat_4_2_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_2_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_2_3


subroutine iotk_write_attr_4_2_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_2_3

subroutine iotk_scan_attr_4_2_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_2_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_2_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_2_4

subroutine iotk_scan_dat_aux_4_2_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_2_4

subroutine iotk_scan_dat_4_2_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_2_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_2_4


subroutine iotk_write_attr_4_2_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_2_4

subroutine iotk_scan_attr_4_2_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_2_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_2_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_2_5

subroutine iotk_scan_dat_aux_4_2_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_2_5

subroutine iotk_scan_dat_4_2_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_2_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_2_5


subroutine iotk_write_attr_4_2_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_2_5

subroutine iotk_scan_attr_4_2_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_2_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T4_K3
#define __KIND kind=__IOTK_T4_K3
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_4_3_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_3_0

subroutine iotk_scan_dat_aux_4_3_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1) :: dat1
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2) :: dat2
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_3_0

subroutine iotk_scan_dat_4_3_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_3_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_3_0


subroutine iotk_write_attr_4_3_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_3_0

subroutine iotk_scan_attr_4_3_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_3_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_3_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_3_1

subroutine iotk_scan_dat_aux_4_3_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_3_1

subroutine iotk_scan_dat_4_3_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_3_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_3_1


subroutine iotk_write_attr_4_3_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_3_1

subroutine iotk_scan_attr_4_3_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_3_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_3_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_3_2

subroutine iotk_scan_dat_aux_4_3_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_3_2

subroutine iotk_scan_dat_4_3_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_3_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_3_2


subroutine iotk_write_attr_4_3_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_3_2

subroutine iotk_scan_attr_4_3_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_3_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_3_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_3_3

subroutine iotk_scan_dat_aux_4_3_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_3_3

subroutine iotk_scan_dat_4_3_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_3_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_3_3


subroutine iotk_write_attr_4_3_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_3_3

subroutine iotk_scan_attr_4_3_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_3_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_3_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_3_4

subroutine iotk_scan_dat_aux_4_3_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_3_4

subroutine iotk_scan_dat_4_3_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_3_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_3_4


subroutine iotk_write_attr_4_3_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_3_4

subroutine iotk_scan_attr_4_3_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_3_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_3_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_3_5

subroutine iotk_scan_dat_aux_4_3_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T4_K4
  __TYPE (__IOTK_T4_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_3_5

subroutine iotk_scan_dat_4_3_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_3_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_3_5


subroutine iotk_write_attr_4_3_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_3_5

subroutine iotk_scan_attr_4_3_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_3_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#ifdef __IOTK_T4_K4
#define __KIND kind=__IOTK_T4_K4
#define __LEN(X) -1
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_4_4_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_4_0

subroutine iotk_scan_dat_aux_4_4_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1) :: dat1
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2) :: dat2
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3) :: dat3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_4_0

subroutine iotk_scan_dat_4_4_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_4_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_4_0


subroutine iotk_write_attr_4_4_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_4_0

subroutine iotk_scan_attr_4_4_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_4_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_4_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_4_1

subroutine iotk_scan_dat_aux_4_4_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_1
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_4_1

subroutine iotk_scan_dat_4_4_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_4_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_4_1


subroutine iotk_write_attr_4_4_1(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_1
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_4_1

subroutine iotk_scan_attr_4_4_1(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_1
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_4_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_4_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_4_2

subroutine iotk_scan_dat_aux_4_4_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_2
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_4_2

subroutine iotk_scan_dat_4_4_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_4_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_4_2


subroutine iotk_write_attr_4_4_2(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_2
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_4_2

subroutine iotk_scan_attr_4_4_2(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_2
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_4_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_4_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_4_3

subroutine iotk_scan_dat_aux_4_4_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_3
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_4_3

subroutine iotk_scan_dat_4_4_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_4_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_4_3


subroutine iotk_write_attr_4_4_3(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_3
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_4_3

subroutine iotk_scan_attr_4_4_3(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_3
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_4_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_4_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_4_4

subroutine iotk_scan_dat_aux_4_4_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_4
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_4_4

subroutine iotk_scan_dat_4_4_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_4_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_4_4


subroutine iotk_write_attr_4_4_4(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_4
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_4_4

subroutine iotk_scan_attr_4_4_4(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_4
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_4_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_4_4_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(4,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,4,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_4_4_5

subroutine iotk_scan_dat_aux_4_4_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T4_K1
  __TYPE (__IOTK_T4_K1), allocatable :: dat1 __SHAPE_5
#endif
#ifdef __IOTK_T4_K2
  __TYPE (__IOTK_T4_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T4_K3
  __TYPE (__IOTK_T4_K3), allocatable :: dat3 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        read(unit,iostat=iostat) idummy,dat
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T4_K1
        case(kind(dat1))
          allocate(dat1 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat1
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat1
          deallocate(dat1)
#endif
#ifdef __IOTK_T4_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T4_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(4,fmt)
      if(fmt1=="*") then
        read(unit,fmt=*,  iostat=iostat) dat
      else
        read(unit,fmt=fmt1,iostat=iostat) dat
      end if
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_4_4_5

subroutine iotk_scan_dat_4_4_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 4
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 4) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_4_4_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_4_4_5


subroutine iotk_write_attr_4_4_5(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_5
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(4,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_4_4_5

subroutine iotk_scan_attr_4_4_5(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_5
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "("//trim(iotk_i2c(2*__SIZE(val)))//"G100.100)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_4_4_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#undef __COMPLEX_FACTOR
#undef __TYPE
#endif
#ifdef __IOTK_T5
#define __TYPE __IOTK_T5
#ifdef __IOTK_T5_K1
#define __KIND len=*
#define __LEN(X) len(X)
#if 0 <= __IOTK_MAXRANK

#define __SIZE(X) 1

subroutine iotk_write_dat_5_1_0(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_0
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(5,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,5,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_5_1_0

subroutine iotk_scan_dat_aux_5_1_0(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T5_K2
  __TYPE (__IOTK_T5_K2) :: dat2
#endif
#ifdef __IOTK_T5_K3
  __TYPE (__IOTK_T5_K3) :: dat3
#endif
#ifdef __IOTK_T5_K4
  __TYPE (__IOTK_T5_K4) :: dat4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        call read_char_1_0(unit,binary,dat,rlen,fmt,idummy,iostat)
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T5_K2
        case(kind(dat2))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
#endif
#ifdef __IOTK_T5_K3
        case(kind(dat3))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
#endif
#ifdef __IOTK_T5_K4
        case(kind(dat4))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(5,fmt)
        call read_char_1_0(unit,binary,dat,rlen,fmt1,idummy,iostat)
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_5_1_0

subroutine iotk_scan_dat_5_1_0(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_0
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 5
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 5) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_5_1_0(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_5_1_0

subroutine read_char_1_0(unit,binary,dat,wlen,fmt,idummy,iostat)
  integer, intent(in) :: unit
  logical, intent(in) :: binary
  __TYPE (__KIND), intent(out) :: dat __SHAPE_0
  integer, intent(in) :: wlen
  character(*), intent(in) :: fmt
  integer(iotk_header_kind), intent(out) :: idummy
  integer, intent(out) :: iostat
  __TYPE (kind=kind(dat), len=wlen) :: &
    dattmp __BOUNDS_0(dat)
  if(binary) then
    read(unit,iostat=iostat) idummy,dattmp
  else
    idummy = 0
    if(fmt=="*") then
      read(unit,fmt=*,  iostat=iostat) dattmp
    else
      read(unit,fmt=fmt,iostat=iostat) dattmp
    end if
  end if
  if(iostat/=0 .or. idummy/=0) return
  if(wlen <= len(dat)) then
    dat __SHAPE_0 = dattmp __SHAPE_0
  else
    dat __SHAPE_0 = dattmp __SHAPE_0 (1:len(dat))
  end if
end subroutine read_char_1_0

subroutine iotk_write_attr_5_1_0(attr,name,val,first,ierr)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  __TYPE(__KIND), intent(in)  :: val __SHAPE_0
  logical, optional, intent(in)  :: first
  integer, optional, intent(out) :: ierr
  integer :: ierrl,iiostat
  character(iotk_vallenx) :: valc
  character(1000) :: fmt
  ierrl = 0
  if(present(first)) then
    if(first) attr=" "
  end if
  if(.not.check_name(name)) ierrl = __LINE__
  fmt = "!"
  fmt = iotk_wfmt(5,kind(val),__SIZE(val),__LEN(val),fmt)
!write(0,*) "FMT:"//trim(fmt)
  write(valc,trim(fmt),iostat=iiostat) val
  if(iiostat/=0) ierrl=__LINE__
  call iotk_write_attr_char(attr,name,trim(adjustl(valc)))
  if(.not.check_attr(attr)) ierrl = __LINE__
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_write_attr_5_1_0

subroutine iotk_scan_attr_5_1_0(attr,name,val,found,default,ierr)
  character(*),             intent(in)  :: attr
  character(*),             intent(in)  :: name
  __TYPE(__KIND),           intent(out) :: val __SHAPE_0
  logical,        optional, intent(out) :: found
  __TYPE(__KIND), optional, intent(in)  :: default __SHAPE_0
  integer,        optional, intent(out) :: ierr

  integer :: ierrl
  logical :: foundl
  character(1000) :: valc,fmt
  ierrl = 0
  call iotk_scan_attr_char(attr,name,valc,foundl,ierrl)
  if(ierrl==0) then
    valc = adjustl(valc)
  fmt = "(a)"
!write(0,*) "FMT--:"//trim(fmt)
    read(valc,fmt,iostat=iostat) val
    if(iostat/=0) ierrl=1
  end if
  if(present(found)) then
    found = .false.
    if(ierrl==0 .and. foundl) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) val = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_5_1_0


#undef __SIZE

#endif
#if 1 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_5_1_1(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_1
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(5,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,5,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_5_1_1

subroutine iotk_scan_dat_aux_5_1_1(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T5_K2
  __TYPE (__IOTK_T5_K2), allocatable :: dat2 __SHAPE_1
#endif
#ifdef __IOTK_T5_K3
  __TYPE (__IOTK_T5_K3), allocatable :: dat3 __SHAPE_1
#endif
#ifdef __IOTK_T5_K4
  __TYPE (__IOTK_T5_K4), allocatable :: dat4 __SHAPE_1
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        call read_char_1_1(unit,binary,dat,rlen,fmt,idummy,iostat)
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T5_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T5_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T5_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_1(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(5,fmt)
        call read_char_1_1(unit,binary,dat,rlen,fmt1,idummy,iostat)
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_5_1_1

subroutine iotk_scan_dat_5_1_1(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_1
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_1
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 5
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 5) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_5_1_1(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_5_1_1

subroutine read_char_1_1(unit,binary,dat,wlen,fmt,idummy,iostat)
  integer, intent(in) :: unit
  logical, intent(in) :: binary
  __TYPE (__KIND), intent(out) :: dat __SHAPE_1
  integer, intent(in) :: wlen
  character(*), intent(in) :: fmt
  integer(iotk_header_kind), intent(out) :: idummy
  integer, intent(out) :: iostat
  __TYPE (kind=kind(dat), len=wlen) :: &
    dattmp __BOUNDS_1(dat)
  if(binary) then
    read(unit,iostat=iostat) idummy,dattmp
  else
    idummy = 0
    if(fmt=="*") then
      read(unit,fmt=*,  iostat=iostat) dattmp
    else
      read(unit,fmt=fmt,iostat=iostat) dattmp
    end if
  end if
  if(iostat/=0 .or. idummy/=0) return
  if(wlen <= len(dat)) then
    dat __SHAPE_1 = dattmp __SHAPE_1
  else
    dat __SHAPE_1 = dattmp __SHAPE_1 (1:len(dat))
  end if
end subroutine read_char_1_1


#undef __SIZE

#endif
#if 2 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_5_1_2(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_2
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(5,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,5,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_5_1_2

subroutine iotk_scan_dat_aux_5_1_2(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T5_K2
  __TYPE (__IOTK_T5_K2), allocatable :: dat2 __SHAPE_2
#endif
#ifdef __IOTK_T5_K3
  __TYPE (__IOTK_T5_K3), allocatable :: dat3 __SHAPE_2
#endif
#ifdef __IOTK_T5_K4
  __TYPE (__IOTK_T5_K4), allocatable :: dat4 __SHAPE_2
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        call read_char_1_2(unit,binary,dat,rlen,fmt,idummy,iostat)
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T5_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T5_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T5_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_2(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(5,fmt)
        call read_char_1_2(unit,binary,dat,rlen,fmt1,idummy,iostat)
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_5_1_2

subroutine iotk_scan_dat_5_1_2(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_2
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_2
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 5
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 5) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_5_1_2(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_5_1_2

subroutine read_char_1_2(unit,binary,dat,wlen,fmt,idummy,iostat)
  integer, intent(in) :: unit
  logical, intent(in) :: binary
  __TYPE (__KIND), intent(out) :: dat __SHAPE_2
  integer, intent(in) :: wlen
  character(*), intent(in) :: fmt
  integer(iotk_header_kind), intent(out) :: idummy
  integer, intent(out) :: iostat
  __TYPE (kind=kind(dat), len=wlen) :: &
    dattmp __BOUNDS_2(dat)
  if(binary) then
    read(unit,iostat=iostat) idummy,dattmp
  else
    idummy = 0
    if(fmt=="*") then
      read(unit,fmt=*,  iostat=iostat) dattmp
    else
      read(unit,fmt=fmt,iostat=iostat) dattmp
    end if
  end if
  if(iostat/=0 .or. idummy/=0) return
  if(wlen <= len(dat)) then
    dat __SHAPE_2 = dattmp __SHAPE_2
  else
    dat __SHAPE_2 = dattmp __SHAPE_2 (1:len(dat))
  end if
end subroutine read_char_1_2


#undef __SIZE

#endif
#if 3 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_5_1_3(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_3
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(5,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,5,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_5_1_3

subroutine iotk_scan_dat_aux_5_1_3(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T5_K2
  __TYPE (__IOTK_T5_K2), allocatable :: dat2 __SHAPE_3
#endif
#ifdef __IOTK_T5_K3
  __TYPE (__IOTK_T5_K3), allocatable :: dat3 __SHAPE_3
#endif
#ifdef __IOTK_T5_K4
  __TYPE (__IOTK_T5_K4), allocatable :: dat4 __SHAPE_3
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        call read_char_1_3(unit,binary,dat,rlen,fmt,idummy,iostat)
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T5_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T5_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T5_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_3(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(5,fmt)
        call read_char_1_3(unit,binary,dat,rlen,fmt1,idummy,iostat)
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_5_1_3

subroutine iotk_scan_dat_5_1_3(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_3
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_3
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 5
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 5) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_5_1_3(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_5_1_3

subroutine read_char_1_3(unit,binary,dat,wlen,fmt,idummy,iostat)
  integer, intent(in) :: unit
  logical, intent(in) :: binary
  __TYPE (__KIND), intent(out) :: dat __SHAPE_3
  integer, intent(in) :: wlen
  character(*), intent(in) :: fmt
  integer(iotk_header_kind), intent(out) :: idummy
  integer, intent(out) :: iostat
  __TYPE (kind=kind(dat), len=wlen) :: &
    dattmp __BOUNDS_3(dat)
  if(binary) then
    read(unit,iostat=iostat) idummy,dattmp
  else
    idummy = 0
    if(fmt=="*") then
      read(unit,fmt=*,  iostat=iostat) dattmp
    else
      read(unit,fmt=fmt,iostat=iostat) dattmp
    end if
  end if
  if(iostat/=0 .or. idummy/=0) return
  if(wlen <= len(dat)) then
    dat __SHAPE_3 = dattmp __SHAPE_3
  else
    dat __SHAPE_3 = dattmp __SHAPE_3 (1:len(dat))
  end if
end subroutine read_char_1_3


#undef __SIZE

#endif
#if 4 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_5_1_4(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_4
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(5,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,5,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_5_1_4

subroutine iotk_scan_dat_aux_5_1_4(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T5_K2
  __TYPE (__IOTK_T5_K2), allocatable :: dat2 __SHAPE_4
#endif
#ifdef __IOTK_T5_K3
  __TYPE (__IOTK_T5_K3), allocatable :: dat3 __SHAPE_4
#endif
#ifdef __IOTK_T5_K4
  __TYPE (__IOTK_T5_K4), allocatable :: dat4 __SHAPE_4
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        call read_char_1_4(unit,binary,dat,rlen,fmt,idummy,iostat)
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T5_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T5_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T5_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_4(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(5,fmt)
        call read_char_1_4(unit,binary,dat,rlen,fmt1,idummy,iostat)
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_5_1_4

subroutine iotk_scan_dat_5_1_4(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_4
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_4
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 5
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 5) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_5_1_4(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_5_1_4

subroutine read_char_1_4(unit,binary,dat,wlen,fmt,idummy,iostat)
  integer, intent(in) :: unit
  logical, intent(in) :: binary
  __TYPE (__KIND), intent(out) :: dat __SHAPE_4
  integer, intent(in) :: wlen
  character(*), intent(in) :: fmt
  integer(iotk_header_kind), intent(out) :: idummy
  integer, intent(out) :: iostat
  __TYPE (kind=kind(dat), len=wlen) :: &
    dattmp __BOUNDS_4(dat)
  if(binary) then
    read(unit,iostat=iostat) idummy,dattmp
  else
    idummy = 0
    if(fmt=="*") then
      read(unit,fmt=*,  iostat=iostat) dattmp
    else
      read(unit,fmt=fmt,iostat=iostat) dattmp
    end if
  end if
  if(iostat/=0 .or. idummy/=0) return
  if(wlen <= len(dat)) then
    dat __SHAPE_4 = dattmp __SHAPE_4
  else
    dat __SHAPE_4 = dattmp __SHAPE_4 (1:len(dat))
  end if
end subroutine read_char_1_4


#undef __SIZE

#endif
#if 5 <= __IOTK_MAXRANK

#define __SIZE(X) size(X)

subroutine iotk_write_dat_5_1_5(unit,name,dat,fmt,ierr)
  integer,                intent(in)  :: unit
  character(*),           intent(in)  :: name
  __TYPE (__KIND),        intent(in)  :: dat __SHAPE_5
  character(*), optional, intent(in)  :: fmt
  integer,      optional, intent(out) :: ierr
  integer :: ierrl,wsize,wkind,wlength
  logical :: binary
  integer(iotk_header_kind), parameter :: idummy=0
  character(300) :: usefmt,usefmt1
  ierrl = 0
  do
    call iotk_inquire(unit,binary=binary,ierr=ierrl)
    if(ierrl/=0) exit
    wsize = __SIZE(dat)
    if(.not.binary) then
      usefmt1="!"
      if(present(fmt)) usefmt1 = fmt
      if(.not.binary) usefmt = iotk_wfmt(5,kind(dat),1,-1,usefmt1)
    end if
    wkind = kind(dat)
    wlength = __LEN(dat)
    call write_dat_begin_aux(unit,name,5,wkind,wsize,wlength, &
           binary,usefmt1,ierrl)
    if(ierrl/=0) exit
    if(binary) then
      write(unit,iostat=iostat) idummy,dat
    else
      if(usefmt=="*") then
        write(unit,*,iostat=iostat) dat
      else
        write(unit,fmt=usefmt,iostat=iostat) dat
      end if
    end if
    if(iostat/=0) ierrl = __LINE__
    if(ierrl/=0) exit
    call iotk_write_end(unit,name,ierr=ierrl)
    exit
  end do
  if(present(ierr)) then
    ierr = ierrl
  else
    call iotk_error(unit,ierrl)
  end if
end subroutine iotk_write_dat_5_1_5

subroutine iotk_scan_dat_aux_5_1_5(unit,dat,rkind,rlen,binary,fmt,ierr)
  integer,         intent(in)  :: unit
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer,         intent(in)  :: rkind
  integer,         intent(in)  :: rlen
  logical,         intent(in)  :: binary
  character(*),    intent(in)  :: fmt
  integer,         intent(out) :: ierr
  integer(iotk_header_kind) :: idummy
  character(len(fmt)) :: fmt1
#ifdef __IOTK_T5_K2
  __TYPE (__IOTK_T5_K2), allocatable :: dat2 __SHAPE_5
#endif
#ifdef __IOTK_T5_K3
  __TYPE (__IOTK_T5_K3), allocatable :: dat3 __SHAPE_5
#endif
#ifdef __IOTK_T5_K4
  __TYPE (__IOTK_T5_K4), allocatable :: dat4 __SHAPE_5
#endif
    if(binary) then
      if(kind(dat)==rkind) then
        call read_char_1_5(unit,binary,dat,rlen,fmt,idummy,iostat)
        if(iostat/=0) ierr = __LINE__
        if(idummy/=0) ierr = __LINE__
      else
        select case(rkind)
#ifdef __IOTK_T5_K2
        case(kind(dat2))
          allocate(dat2 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat2
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat2
          deallocate(dat2)
#endif
#ifdef __IOTK_T5_K3
        case(kind(dat3))
          allocate(dat3 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat3
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat3
          deallocate(dat3)
#endif
#ifdef __IOTK_T5_K4
        case(kind(dat4))
          allocate(dat4 &
  __BOUNDS_5(dat))
          read(unit,iostat=iostat) idummy,dat4
          if(iostat/=0) ierr = __LINE__
          if(idummy/=0) ierr = __LINE__
          dat = dat4
          deallocate(dat4)
#endif
        case default
          ierr = __LINE__
        end select
      end if
    else
      fmt1 = iotk_rfmt(5,fmt)
        call read_char_1_5(unit,binary,dat,rlen,fmt1,idummy,iostat)
      if(iostat/=0) ierr = 1
    end if
end subroutine iotk_scan_dat_aux_5_1_5

subroutine iotk_scan_dat_5_1_5(unit,name,dat,found,default,ierr)
  integer,                   intent(in)  :: unit
  character(*),              intent(in)  :: name
  __TYPE (__KIND),           intent(out) :: dat __SHAPE_5
  logical,         optional, intent(out) :: found
  __TYPE (__KIND), optional, intent(in)  :: default __SHAPE_5
  integer,         optional, intent(out) :: ierr
  integer :: ierrl,ierrl2
  integer :: rtype,rkind,rsize,rlen
  logical :: binary
  character(300) :: fmt
  ierrl = 0
  ierrl2 = 0
  call iotk_inquire(unit,binary=binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call scan_dat_begin_aux(unit,name,rtype,rkind,rsize,rlen, &
   binary,fmt,ierrl)
  if(ierrl/=0) goto 1
  if(.not. binary .and. rtype==-1) rtype = 5
  if(.not. binary)                 rkind = kind(dat)
  if(.not. binary .and. rsize==-1) rsize = __SIZE(dat)
  if(.not. binary .and. rlen ==-1) rlen  = __LEN(dat)
  if(rtype /= 5) ierrl = __LINE__
  if(ierrl/=0) goto 1
  if(rsize /= __SIZE(dat)) ierrl = __LINE__
  if(ierrl/=0) goto 1
  call iotk_scan_dat_aux_5_1_5(unit,dat,rkind,rlen,binary,fmt,ierrl)
  call iotk_scan_end(unit,name,ierr=ierrl2)
  if(ierrl2/=0) ierrl=ierrl2
1 continue
  if(present(found)) then
    found = .false.
    if(ierrl==0) found = .true.
  end if
  if(present(default)) then
    if(ierrl/=0) dat = default
  end if
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. (.not.present(found) .and. .not.present(default))) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_dat_5_1_5

subroutine read_char_1_5(unit,binary,dat,wlen,fmt,idummy,iostat)
  integer, intent(in) :: unit
  logical, intent(in) :: binary
  __TYPE (__KIND), intent(out) :: dat __SHAPE_5
  integer, intent(in) :: wlen
  character(*), intent(in) :: fmt
  integer(iotk_header_kind), intent(out) :: idummy
  integer, intent(out) :: iostat
  __TYPE (kind=kind(dat), len=wlen) :: &
    dattmp __BOUNDS_5(dat)
  if(binary) then
    read(unit,iostat=iostat) idummy,dattmp
  else
    idummy = 0
    if(fmt=="*") then
      read(unit,fmt=*,  iostat=iostat) dattmp
    else
      read(unit,fmt=fmt,iostat=iostat) dattmp
    end if
  end if
  if(iostat/=0 .or. idummy/=0) return
  if(wlen <= len(dat)) then
    dat __SHAPE_5 = dattmp __SHAPE_5
  else
    dat __SHAPE_5 = dattmp __SHAPE_5 (1:len(dat))
  end if
end subroutine read_char_1_5


#undef __SIZE

#endif

#undef __KIND
#undef __LEN
#endif
#undef __COMPLEX_FACTOR
#undef __TYPE
#endif

subroutine iotk_copy_tag(source,dest,maxsize,ierr)
  integer,           intent(in)  :: source
  integer,           intent(in)  :: dest
  integer, optional, intent(in)  :: maxsize
  integer, optional, intent(out) :: ierr
  logical :: source_binary,dest_binary
  integer :: ierrl,control,maxsizel
  character(iotk_taglenx) :: tag
  character(iotk_namlenx) :: name,root
  character(iotk_attlenx) :: attr
  character(iotk_vallenx) :: type
  maxsizel = -1
  if(present(maxsize)) maxsizel = maxsize
  call iotk_inquire(source,binary=source_binary,ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_inquire(dest  ,binary=dest_binary,  ierr=ierrl)
  if(ierrl/=0) goto 1
  call iotk_unit_get(source,root=root,ierr=ierrl)
  if(ierrl/=0) goto 1
  do
    call scan_tag(source,+1,control,tag,source_binary,ierrl)
    if(ierrl/=0) goto 1
    call tag_parse(tag,name,attr,ierrl)
    if(ierrl/=0) goto 1
    if(name == root) then
      call scan_tag(source,-1,control,tag,source_binary,ierrl)
      if(ierrl/=0) goto 1
      return
    end if
    call iotk_scan_attr(attr,"type",type,ierr=ierrl)
    if(ierrl/=0) then
      ierrl = 0
      type = " "
    end if
    if((type=="real" .or. type=="integer" .or. type=="logical" &
  .or. type=="character" .or. type=="complex") .and. control==1) then
      call iotk_copy_dat(source,dest,source_binary,dest_binary,name,attr,maxsize=maxsizel,ierr=ierrl)
      if(ierrl/=0) goto 1
      call scan_tag(source,+1,control,tag,source_binary,ierrl)
      if(ierrl/=0) goto 1
    else
      call write_tag(dest,control,tag,dest_binary,ierrl)
      if(ierrl/=0) goto 1
    end if
  end do
1 continue
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl/=0) call iotk_error(0,ierrl)
  end if
end subroutine iotk_copy_tag

subroutine iotk_write_attr_char(attr,name,val)
  character(*), intent(inout) :: attr
  character(*), intent(in)    :: name
  character(*), intent(in)    :: val
  integer :: pos,ierr
  ierr = 0
  call append(attr,name//'="'//trim(val)//'"',.true.,ierr)
  if(ierr/=0) call iotk_error(-1,ierr)
end subroutine iotk_write_attr_char

subroutine iotk_scan_attr_char(attr,name,val,found,ierr)
  character(*),      intent(in)  :: attr
  character(*),      intent(in)  :: name
  character(*),      intent(out) :: val
  logical, optional, intent(out) :: found
  integer, optional, intent(out) :: ierr
  integer :: equal,pos,pos1,ierrl
  logical :: foundl
  equal = 0
  foundl = .false.
  ierrl = 0
  do
    pos = scan(attr(equal+1:),"=")
    if(pos<=0) exit
    equal = equal + pos
    pos  = verify(attr(1:equal-1)," ",back=.true.)
    pos1 = scan(attr(1:pos)," ",back=.true.)
    if(attr(pos1+1:pos)==name) then
      foundl = .true.
      exit
    end if
  end do
  if(.not.foundl) ierrl = -1
  if(foundl) then
    pos  = scan(attr(equal+1:),'"') + equal
    pos1 = scan(attr(pos+1:),'"') + pos
    if(pos==pos1) ierrl = 1
    val = attr(pos+1:pos1-1)
  end if
  if(present(found)) found = foundl
  if(present(ierr)) then
    ierr = ierrl
  else
    if(ierrl>0 .or. .not.present(found)) call iotk_error(0,ierrl)
  end if
end subroutine iotk_scan_attr_char

function iotk_basefmt(type,kind,len)
  character(100) :: iotk_basefmt
  integer,          intent(in)  :: type,kind,len
  integer :: nexp,exp,ndig,baselen
  character(100) :: base
#ifdef __IOTK_T2_K1
  __IOTK_T2 (__IOTK_T2_K1) :: example_T2_K1
#endif
#ifdef __IOTK_T3_K1
  __IOTK_T3 (__IOTK_T3_K1) :: example_T3_K1
#endif
#ifdef __IOTK_T2_K2
  __IOTK_T2 (__IOTK_T2_K2) :: example_T2_K2
#endif
#ifdef __IOTK_T3_K2
  __IOTK_T3 (__IOTK_T3_K2) :: example_T3_K2
#endif
#ifdef __IOTK_T2_K3
  __IOTK_T2 (__IOTK_T2_K3) :: example_T2_K3
#endif
#ifdef __IOTK_T3_K3
  __IOTK_T3 (__IOTK_T3_K3) :: example_T3_K3
#endif
#ifdef __IOTK_T2_K4
  __IOTK_T2 (__IOTK_T2_K4) :: example_T2_K4
#endif
#ifdef __IOTK_T3_K4
  __IOTK_T3 (__IOTK_T3_K4) :: example_T3_K4
#endif

  select case(type)
  case(1)
    base = "(l1)"
  case(2)
    select case(kind)
#ifdef __IOTK_T2_K1
    case(__IOTK_T2_K1)
      baselen = range(example_T2_K1) + 1
#endif
#ifdef __IOTK_T2_K2
    case(__IOTK_T2_K2)
      baselen = range(example_T2_K2) + 1
#endif
#ifdef __IOTK_T2_K3
    case(__IOTK_T2_K3)
      baselen = range(example_T2_K3) + 1
#endif
#ifdef __IOTK_T2_K4
    case(__IOTK_T2_K4)
      baselen = range(example_T2_K4) + 1
#endif
    end select
    base = "(i"//trim(iotk_i2c(baselen))//")"
  case(3)
    select case(kind)
#ifdef __IOTK_T3_K1
    case(__IOTK_T3_K1)
      ndig = precision(example_T3_K1)+1
      exp = range(example_T3_K1)+1
#endif
#ifdef __IOTK_T3_K2
    case(__IOTK_T3_K2)
      ndig = precision(example_T3_K2)+1
      exp = range(example_T3_K2)+1
#endif
#ifdef __IOTK_T3_K3
    case(__IOTK_T3_K3)
      ndig = precision(example_T3_K3)+1
      exp = range(example_T3_K3)+1
#endif
#ifdef __IOTK_T3_K4
    case(__IOTK_T3_K4)
      ndig = precision(example_T3_K4)+1
      exp = range(example_T3_K4)+1
#endif
    end select
    nexp = 1
    do 
      if(exp < 10) exit
      exp = exp / 10
      nexp = nexp + 1
    end do
    baselen = nexp+ndig-1+5
    base = "(ES"//trim(iotk_i2c(baselen))//"." &
                //trim(iotk_i2c(ndig-1))//"E"//trim(iotk_i2c(nexp))//")"
  case(4)
    select case(kind)
#ifdef __IOTK_T3_K1
    case(__IOTK_T3_K1)
      ndig = precision(example_T3_K1)+1
      exp = range(example_T3_K1)+1
#endif
#ifdef __IOTK_T3_K2
    case(__IOTK_T3_K2)
      ndig = precision(example_T3_K2)+1
      exp = range(example_T3_K2)+1
#endif
#ifdef __IOTK_T3_K3
    case(__IOTK_T3_K3)
      ndig = precision(example_T3_K3)+1
      exp = range(example_T3_K3)+1
#endif
#ifdef __IOTK_T3_K4
    case(__IOTK_T3_K4)
      ndig = precision(example_T3_K4)+1
      exp = range(example_T3_K4)+1
#endif
    end select
    nexp = 1
    do 
      if(exp < 10) exit
      exp = exp / 10
      nexp = nexp + 1
    end do
    baselen = nexp+ndig-1+5
    base = "(ES"//trim(iotk_i2c(baselen))//"." &
                //trim(iotk_i2c(ndig-1))//"E"//trim(iotk_i2c(nexp))//")"
    base = "("//trim(base)//",',',"//trim(base)//")"
  case(5)
    if(len>=0) then
      base = "(a"//trim(iotk_i2c(len))//")"
    else
      base = "(a)"
    end if
  end select
  iotk_basefmt = base
end function iotk_basefmt

function iotk_wfmt(type,kind,size,len,fmt)
  integer,       intent(in)  :: type,kind
  integer,       intent(in)  :: size
  integer,       intent(in)  :: len
  character(*),  intent(in)  :: fmt
  character(100)             :: iotk_wfmt
  if(fmt/="!") then
    iotk_wfmt = fmt
    return
  end if
  if(size==1) then
    iotk_wfmt = "("//trim(iotk_basefmt(type,kind,len))//")"
  else
    iotk_wfmt = "("//trim(iotk_i2c(size))//"("//trim(iotk_basefmt(type,kind,len)) &
                //",:,','))"
  end if
!write(0,*) "FMT:"//trim(iotk_wfmt)
end function iotk_wfmt

function iotk_rfmt(type,fmt)
  integer,       intent(in)  :: type
  character(*),  intent(in)  :: fmt
  character(100)             :: iotk_rfmt
  if(fmt/="!") then
    iotk_rfmt = fmt
    return
  end if
  select case(type)
  case(1)
    iotk_rfmt = "(l100)"
  case(2)
    iotk_rfmt = "(i100.100)"
  case(3)
    iotk_rfmt = "(G100.100)"
  case(4)
    iotk_rfmt = "(2G100.100)"
  case(5)
    iotk_rfmt = "(a)"
  end select
end function iotk_rfmt

end module iotk_module




