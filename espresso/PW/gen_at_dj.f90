!
! Copyright (C) 2002-2003 PWSCF group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
!----------------------------------------------------------------------
subroutine gen_at_dj ( kpoint, natw, lmax_wfc, dwfcat )
   !----------------------------------------------------------------------
   !
   ! This routine calculates the atomic wfc generated by the derivative
   ! (with respect to the q vector) of the bessel function. This vector
   ! is needed in computing the internal stress tensor.
   !
#include "machine.h"
   use pwcom
   implicit none
   !
   !  I/O variables
   !
   integer :: kpoint, natw, lmax_wfc
   complex (kind=DP) :: dwfcat(npwx,natw)
   !
   ! local variables
   !
   integer :: l, na, nt, nb, iatw, iig, i, ig, i0, m, lm
   real (kind=DP) :: jl(ndm), jlm1(ndm), eps, dv, qt, arg
   parameter (eps=1.0e-8)
   complex (kind=DP) :: phase, pref
   real (kind=DP), allocatable :: gk(:,:), q(:), ylm(:,:), djl(:,:,:)
   !          gk(3,npw), q(npw),
   !          ylm(npw,(lmax_wfc+1)**2),
   !          djl(npw,nchix,ntyp)
   complex (kind=DP), allocatable :: sk(:)
   !          sk(npw)

   allocate ( ylm (npw,(lmax_wfc+1)**2) , djl (npw,nchix,ntyp) )
   allocate ( gk(3,npw), q (npw) )

   do ig = 1, npw
      gk (1,ig) = xk(1, kpoint) + g(1, igk(ig) )
      gk (2,ig) = xk(2, kpoint) + g(2, igk(ig) )
      gk (3,ig) = xk(3, kpoint) + g(3, igk(ig) )
      q (ig) = gk(1, ig)**2 +  gk(2, ig)**2 + gk(3, ig)**2
   enddo

   !
   !  ylm = spherical harmonics
   !
   call ylmr2 ((lmax_wfc+1)**2, npw, gk, q, ylm)

   q(:) = dsqrt ( q(:) )

   do nt=1,ntyp
      do nb=1,nchi(nt)
         l =lchi(nb,nt)
         do ig=1, npw
            qt=q(ig)*tpiba
            if (qt.lt.eps) then
               if (l.ne.1) then
                  do i=1, msh(nt)
                     jl(i) = 0.0d0
                  end do
               else
                  ! Note that dj_1/dx (x=0) = 1/3
                  do i=1, msh(nt)
                     jl(i) = 1.0d0/3.d0
                  end do
               end if
            else
               !
               ! in order to avoid a division by zero i0 is defined as the first
               ! non-zero point in the radial mesh
               !
               i0 = 1
               if ( r(1,nt) .lt. eps ) i0 = 2

               call sph_bes(msh(nt)+1-i0,r(i0,nt),qt,l  ,jl(i0)  )
               call sph_bes(msh(nt)+1-i0,r(i0,nt),qt,l-1,jlm1(i0))
               ! recurrence relation for jl
               do i = i0, msh(nt)
                  jl(i) = jlm1(i) - (l+1)/(qt*r(i,nt)) * jl(i)
               end do
               if (i0.eq.2) jl(1) = jl(2)
            end if
            ! jl is now the derivative of the Bessel functions
            do i=1,msh(nt)
               jlm1(i) = jl(i) * chi(i,nb,nt) * r(i,nt)**2
            end do
            call simpson (msh(nt),jlm1,rab(1,nt),dv)
            djl(ig,nb,nt) =dv*fpi/dsqrt(omega)
         end do
      end do
   end do
   deallocate ( gk, q )

   allocate ( sk(npw) )

   iatw = 0
   do na=1,nat
      nt=ityp(na)
      arg = ( xk(1,kpoint) * tau(1,na) + &
              xk(2,kpoint) * tau(2,na) + &
              xk(3,kpoint) * tau(3,na) ) * tpi
      phase=DCMPLX(cos(arg),-sin(arg))
      do ig =1,npw
         iig = igk(ig)
         sk(ig) = eigts1(ig1(iig),na) *      &
                  eigts2(ig2(iig),na) *      &
                  eigts3(ig3(iig),na) * phase
      end do
      do nb = 1,nchi(nt)
         if (.not.newpseudo(nt).or.oc(nb,nt).gt.0.d0) then
            l  = lchi(nb,nt)
            pref = (1.d0,0.d0)**l
            pref = (0.d0,1.d0)**l
            do m = 1,2*l+1
               lm = l*l+m
               iatw = iatw+1
               do ig=1,npw
                  dwfcat(ig,iatw)= djl(ig,nb,nt)*sk(ig)*ylm(ig,lm)*pref
               end do
            enddo
         end if
      enddo
   enddo

   if (iatw.ne.natw) then
      write(6,*) 'iatw =',iatw,'natw =',natw
      call errore('gen_at_dj','unexpected error',1)
   end if

   deallocate ( sk )
   deallocate ( ylm , djl )

   return
end subroutine gen_at_dj
