Input data format: { } = optional, [ ] = it depends

All quantities whose dimensions are not explicitly specified are in
HARTREE ATOMIC UNITS

===============================================================================
&CONTROL
  ...
/
&SYSTEM
 ...
/
&ELECTRONS
...
/
[ &IONS
  ...
 / ]
[ &CELL
  ...
 / ]
[ &WANNIER
  ...
 / ]
ATOMIC_SPECIES
 X  Mass_X  PseudoPot_X
 Y  Mass_Y  PseudoPot_Y
 Z  Mass_Z  PseudoPot_Z
ATOMIC_POSITIONS { alat | bohr | crystal | angstrom }
in all cases except calculation = 'neb' or 'smd' :
  X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
  Y 0.5  0.0  0.0
  Z O.0  0.2  0.2
if calculation = 'neb' .OR. 'smd' :
  first_image
  X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
  Y 0.5  0.0  0.0
  Z O.0  0.2  0.2
  { intermediate_image 1
    X 0.0  0.0  0.0
    Y 0.9  0.0  0.0
    Z O.0  0.2  0.2
    intermediate_image ...
    X 0.0  0.0  0.0
    Y 0.9  0.0  0.0
    Z O.0  0.2  0.2 }
  last_image
  X 0.0  0.0  0.0
  Y 0.7  0.0  0.0
  Z O.0  0.5  0.2 
[ CELL_PARAMETERS { cubic | hexagonal }
   a(1,1) a(2,1) a(3,1)
   a(1,2) a(2,2) a(3,2)
   a(1,3) a(2,3) a(3,3) ]
[ OCCUPATIONS
   f_inp(1,1)  f_inp(2,1)  f_inp(3,1) ... f_inp(10,1)
   f_inp(11,1) f_inp(12,1) ... f_inp(nbnd,1)
 [ f_inp(1,2)  f_inp(2,2)  f_inp(3,2) ... f_inp(10,2)
   f_inp(11,2) f_inp(12,2) ... f_inp(nbnd,2) ] ]
[ CLIMBING_IMAGES
   list of images, separated by a comma ]   
[ CONSTRAINTS
   nconstr   { constr_tol }
   constr_type(.)   constr(1,.)   constr(2,.) { constr_target(.) } ]

===============================================================================
NAMELIST &CONTROL

calculation    CHARACTER ( default = 'cp' )
               a string describing the task to be performed:
               'cp', 'scf', 'nscf', 'relax', 'vc-relax', 'vc-cp', 'neb', 
               'smd', 'cp-wf', 'fpmd', 'metadyn'
               where :               
               cp       = Car-Parrinello MD (includes cases 'scf' and 'relax')
               scf      = electron minimization
               nscf     = non-selfconsistent calculation of KS states:
                          reads the charge density previously saved to disk,
                          sets occupancies to a bogus nonzero value
               relax    = ionic minimization
               vc-relax = ionic + cell minimization
               vc-cp    = variable-cell Car-Parrinello (-Rahman) dynamics
               neb      = Nudged Elastc Band method
               smd      = String Method Dynamics
               cp-wf    = Car-Parrinello MD with Wannier functions
               fpmd     = CP works in FPMD compatibility mode, with all FPMD
                          features not yet ported in CP, but works only for
                          norm-conserving pseudopotentials
               metadyn  = Laio-Parrinello meta-dynamics

title          CHARACTER ( default = 'MD Simulation' )
               reprinted on output.

restart_mode   CHARACTER ( default = 'restart' )
               from_scratch    = from scratch
	                         NEB only: the starting path is obtained
                                 with a linear interpolation between the images
                                 specified in the ATOMIC_POSITIONS card.
			         Note that in the linear interpolation
                                 periodic boundary conditions ARE NON USED.
               restart         = continue a previous simulation,
                                 and performs  "nstep" new steps,
               reset_counters  = continue a previous simulation,
                                 performs  "nstep" new steps, resetting
                                 the counter and averages
               upto            = continue a previous simulation and stops 
                                 when the counter value is equal "nstep"

nstep          INTEGER                         
               number of ionic + electronic steps
               default =    1 if calculation = 'scf', 'nscf'
	               =    0 if calculation = 'neb', 'smd'
                       =   50 for the other cases

tstress        LOGICAL ( default = .FALSE. )
               This flag controls the printing of the stress, always .TRUE.
               when the cell is moving.
               .TRUE.    = write the stress tensor to standard output 
                           every "iprint" steps.
               .FALSE.   = do not write the stress tensor stdout.

tprnfor        LOGICAL ( default = .FALSE. )
               This flag controls the printing of the interatomic forces, 
               always .TRUE. when the ions are moving.
               .TRUE.    =  write the atomic forces to standard output every 
                            "iprint" steps.
               .FALSE.   =   do not write atomic forces to stdout.

dt             REAL ( default = 1.D0 )
               time step for molecular dynamics, in Hartree atomic units.
               ( 1 a.u. of time = 2.4189 * 10^-17 s )

ekin_conv_thr  REAL ( default = 1.D-6 )
               convergence criterion for electron minimization:
               convergence is achieved when "ekin < ekin_conv_thr".
               See also etot_conv_thr - both criteria must be satisfied.

etot_conv_thr  REAL ( default = 1.D-4 )
               convergence criteria for ion minimization:
               "etot(n+1)-etot(n) < etot_conv_thr", where "n" is the step 
               index, and "etot" the DFT energy.
               See also ekin_conv_thr for electron minimization and 
               forc_conv_thr for ion minimization - both criteria must be 
               satisfied.

forc_conv_thr  REAL ( default = 1.D-3 )
               "MAXVAL(fion) < forc_conv_thr", where fion are the atomic 
               forces.
               See also etot_conv_thr - both criteria must be satisfied.

max_seconds    REAL ( default = 1.D+7 )
               smoothly terminate program after the specified number of seconds
               this parameter is typically used to prevent an hard kill from
               the queuing system.

tefield        LOGICAL ( default = .FALSE.)
               If .TRUE. perform calculations with a finite electric field 
               which is described through the modern theory of the polarization

iprint         INTEGER ( default = 10 )
               Number of steps between successive writings of relevant 
               physical quantities to standard output and to files "fort.3?" 
               or "prefix.???" depending on "prefix" parameter

isave          INTEGER ( default = 100 )
               Number of steps between successive savings of
               information needed to restart the run ( see also ndr, ndw ).

prefix         CHARACTER ( default = 'cp' )
               basename prepended to input/output filenames. 
               
verbosity      CHARACTER
               'high' | 'default' | 'low' | 'minimal'

outdir         CHARACTER ( default = current directory ('./') )
               input, temporary, output files are found in this directory.

disk_io        CHARACTER
               'high', 'default', 'low', 'minimal'

pseudo_dir     CHARACTER ( default = current directory ('./') )
               directory containing pseudopotential files.

ndr, ndw       INTEGER ( default = 50 )
               Units for input and output restart file.

===============================================================================
NAMELIST &SYSTEM

ibrav          INTEGER
               bravais-lattice index (must be specified)
               see at the end of this file

celldm(i)      REAL, DIMENSION(6)                        
               crystallographic constants - see at the end of this file
               alat = celldm(1) is the lattice parameter "a" (in BOHR)
               only needed celldm (depending on ibrav) must be specified

a, b, c, cosab, cosac, cosbc: 
               REAL
	       traditional crystallographic constants (a,b,c in ANGSTROM)
               specify either these or celldm  but not both
 
nat            INTEGER
               number of atoms in the unit cell - must be specified

ntyp           INTEGER
               number of types of atoms in the unit cell - must be specified

ecutwfc        REAL
               kinetic energy cutoff (Ry) for wavefunctions
               (must be specified)
	       
ecutrho        REAL ( default = 4 * ecutwfc )
               kinetic energy cutoff (Ry) for charge density and potential
               May be larger ( for ultrasoft PP ) or somewhat smaller 
               ( but not much smaller ) than the default value

nelec          INTEGER
               number of electron in the unit cell. If not specified it is
               read from the pseudopotential

tot_charge     INTEGER ( default = 0 )
               total system charge. Used only if nelec is unspecified,
               otherwise it is ignored.

nbnd           INTEGER ( default = nelec / 2 )
               number of electronic states (bands) to be calculated.

xc_type        CHARACTER ( default = read from pseudopot )
               can be used to force a given functional 
               'BLYP'  use Becke-Lee-Yang-Parr GCC-XC Functional
               'BP'    use Becke-Perdew GCC-XC Functionals
               'PBE'   use Perdew-Burke-Ernzerhof GCC-XC Functionals
               'PZ'    use Slater X, and Perdew-Zunger C Functionals
               'PW'    use Slater X, and Perdew-Wang C Functionals
               'LDA'   use LDA xc functional: the xc potential is
                       calculated through an interpolation table

occupations    CHARACTER
               a string describing the occupation of the electronic states.
               In the case of conjugate gradient style of minimization
               of the electronic states, if occupations is set to 'ensemble',  
               this allows ensemble DFT calculations for metallic systems 
                                                                                                                             
smearing       CHARACTER
               a string describing the kind of occupations for electronic states
               in the case of ensemble DFT (occupations == 'ensemble' );
               now only Fermi-Dirac ('fd') case is implemented
                                                                                                                             
degauss        REAL ( default = 0.D0 )
               parameter for the smearing function, only used for ensemble DFT
               calculations

nspin          INTEGER ( default = 1 )
               nspin = 1 :   non-polarized calculation
               nspin = 2 :  spin-polarized calculation

nelup, neldw   REAL
               number of spin-up and spin-down electrons, respectively.
               The sum must yield nelec that must also be specified
               explicitly in this case.

multiplicity   INTEGER ( default = 0 [unspecified] )
               spin multiplicity (2s+1). 1 is singlet, 2 for doublet etc.
               if unspecified or a non-zero value is specified in nelup/neldw
               then multiplicity variable is ignored.

tot_magnetization INTEGER ( default = -1 [unspecified] )
               majority spin - minority spin (nelup - neldw).
               if unspecified or a non-zero value is specified in nelup/neldw
               then tot_magnetization variable is ignored.
               YES, there is redundancy! nelup/neldw are enough to specify
               the spin state. However these variables are not very convenient
               and will be eliminated from the input in future versions.
	       It is recommended to use either 'multiplicity' or equivalently
               'tot_magnetization' to specify the spin state.

ecfixed        REAL ( default = 0.0 )
qcutz          REAL ( default = 0.0 )
q2sigma        REAL ( default = 0.1 )
               parameters for modified functional to be used in
               variable-cell molecular dynamics (or in stress calculation).
               "ecfixed" is the value (in Rydberg) of the constant-cutoff; 
               "qcutz" and "q2sigma" are the height and the width (in Rydberg) 
               of the energy step for reciprocal vectors whose square modulus 
               is greater than "ecfixed". In the kinetic energy, G^2 is
               replaced by G^2 + qcutz * (1 + erf ( (G^2 - ecfixed)/q2sigma) )
               See: M. Bernasconi et al, J. Phys. Chem. Solids 56, 501 (1995)

nr1,nr2,nr3    INTEGER
               three-dimensional FFT mesh (hard grid) for charge
               density (and scf potential). If not specified
               the grid is calculated based on the cutoff for
               charge density (see also "ecutrho")

nr1s,nr2s,nr3s INTEGER
               three-dimensional mesh for wavefunction FFT and for the smooth 
               part of charge density ( smooth grid ). 
               Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )


nr1b, nr2b, nr3b 
               INTEGER
               dimensions of the "box" grid for Ultrasoft pseudopotentials
               must be specified if Ultrasoft PP are present



===============================================================================
NAMELIST &ELECTRONS

electron_maxstep  
               INTEGER ( default = 100 )
               maximum number of iterations in a scf step

electron_dynamics 
               CHARACTER ( default = 'none' )
               set how electrons should be moved
               none    = electronic degrees of freedom (d.o.f.) are kept fixed 
               sd      = steepest descent algorithm is used to minimize 
                         electronic d.o.f. 
               damp    = damped dynamics is used to propagate electronic d.o.f. 
               verlet  = standard Verlet algorithm is used to propagate 
                         electronic d.o.f. 
               cg      = conjugate gradient is used to converge the 
                         wavefunction at each ionic step. 'cg' can be used 
                         interchangeably with 'verlet' for a couple of ionic
                         steps in order to "cool down" the electrons and
                         return them back to the Born-Oppenheimer surface.
                         Then 'verlet' can be restarted again. This procedure 
                         is useful when electronic adiabaticity in CP is lost
                         yet the ionic velocities need to be preserved.

emass          REAL ( default = 400.D0 )
               effective electron mass in the CP Lagrangian, in atomic units 
               ( 1 a.u. of mass = 1/1822.9 a.m.u. = 9.10939 * 10^-31 kg )

emass_cutoff   REAL ( default = 2.5D0 )
               mass cut-off (in Rydberg) for the Fourier acceleration
               effective mass is rescaled for "G" vector components with 
               kinetic energy above "emass_cutoff" 

orthogonalization 
               CHARACTER ( default = 'ortho' )
               selects the orthonormalization method for electronic wave 
               functions
               ortho         = use iterative algorithm - if it doesn't converge, 
                               reduce the timestep, or use options ortho_max 
                               and ortho_eps, or use Gram-Schmidt instead just 
                               to start the simulation
               Gram-Schmidt  = use Gram-Schmidt algorithm - to be used ONLY in 
                               the first few steps. 
                               YIELDS INCORRECT ENERGIES AND EIGENVALUES.

ortho_eps      REAL ( default = 1.D-8 )
               tolerance for iterative orthonormalization
               meaningful only if orthogonalization = 'ortho'
            
ortho_max      INTEGER ( default = 20 )
               maximum number of iterations for orthonormalization
               meaningful only if orthogonalization = 'ortho'

electron_damping 
               REAL ( default = 0.1D0 )
               damping frequency times delta t, optimal values could be
               calculated with the formula :
                        SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) )
               where E1, E2, E3 are successive values of the DFT total energy 
               in a steepest descent simulations.
               meaningful only if " electron_dynamics = 'damp' "

electron_velocities
               CHARACTER
               zero      = restart setting electronic velocities to zero
               default   = restart using electronic velocities of the 
                           previous run

electron_temperature
               CHARACTER ( default = 'not_controlled' )
               nose            = control electronic temperature using Nose 
                                 thermostat. see parameter "fnosee" and "ekincw"
               rescaling       = control electronic temperature via velocities 
                                 rescaling 
               not_controlled  = electronic temperature is not controlled

ekincw         REAL ( default = 0.001D0 )
               value of the average kinetic energy (in atomic units) forced
               by the temperature control
               meaningful only with " electron_temperature /= 'not_controlled' "

fnosee         REAL ( default = 1.D0 )
               oscillation frequency of the nose thermostat (in terahertz) 
               meaningful only with " electron_temperature = 'nose' "

startingwfc    CHARACTER ( default = 'random' )
               random  = randomize electronic wave functions ( see "ampre" )
               atomic  = from superposition of atomic state 
                         (NOT YET IMPLEMENTED)

ampre          REAL ( default = 0.D0 )
               amplitude of the randomization ( allowed values: 0.0 - 1.0 )
               meaningful only if " startingwfc = 'random' "

grease         REAL ( default = 1.D0 )
               a number <= 1, very close to 1: the damping in electronic
               damped dynamics is multiplied at each time step by "grease"
               (avoids overdamping close to convergence: Obsolete ?)
               grease = 1 : normal damped dynamics

tcg            LOGICAL ( default = .FALSE. )
               if .TRUE. perform a conjugate gradient minimization of the
               electronic states for every ionic step.
               It requires Gram-Schmidt orthogonalization of the electronic
               states.

maxiter        INTEGER ( default = 100 )
               maximum number of conjugate gradient iterations for
               conjugate gradient minimizations of electronic states

etresh         REAL ( default = 1.D-5 )
               convergence criterion for energy in the case of
               conjugate gradient minimization of the electronic states
               
passop         REAL ( default =  0.3D0 )
               small step used in the  conjugate gradient minimization 
               of the electronic states. 

n_inner        INTEGER ( default = 2 )
               number of internal cycles for every conjugate gradient 
               iteration only for ensemble DFT

epol           INTEGER ( default = 3 )
               direction of the finite electric field (only if tefield == .TRUE.)
               In the case of a PARALLEL calculation only the case epol==3
               is implemented

efield         REAL ( default = 0.d0 )
               intensity in a.u. of the finite electric field 
               (only if tefield == .TRUE.)


===============================================================================
NAMELIST &IONS  ( only if calculation = 'cp', 'relax',
                                        'vc-relax', 'vc-cp', 'neb', 'smd' )

ion_dynamics   CHARACTER ( default = 'none' )
               set how ions should be moved
               none    = ions are kept fixed 
               sd      = steepest descent algorithm is used to minimize ionic 
                         configuration
               cg      = conjugate gradient algorithm is used to minimize ionic 
                         configuration
               damp    = damped dynamics is used to propagate ions
               verlet  = standard Verlet algorithm is used to propagate ions

ion_nstepe     INTEGER ( default = 1 )
               number of electronic steps per ionic step.

ion_radius(i)  REAL ( default = 0.5D0 )
               pseudo-atomic radius of the i-th atomic species for Ewald 
               summation (one for each atomic type). 
               values between 0.5 and 2.0 are usually used.

ion_damping    REAL ( default = 0.1D0 )
               damping frequency times delta t, optimal values could be
               calculated with the formula:
                          SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) )
               where E1 E2 E3 are successive values of the DFT total energy 
               in a ionic steepest descent simulation.
               meaningful only if " ion_dynamics = 'damp' "

ion_positions  CHARACTER
               default     = restart the simulation with atomic positions read
                             from the restart file.
               from_input  = restart the simulation with atomic positions read
                             from standard input.
                             ( see also the card 'ATOMIC_POSITIONS' )

ion_velocities CHARACTER
               initial ionic velocities
               default     = restart the simulation with atomic velocities read
                             from the restart file
               random      = start the simulation with random atomic velocities
               from_input  = restart the simulation with atomic velocities read
                             from standard input 
                             ( see the card 'ATOMIC_VELOCITIES' )
               zero        = restart the simulation with atomic velocities set 
                             to zero

ion_temperature  
               CHARACTER ( default = 'not_controlled' )
               nose            = control ionic temperature using Nose-Hoover
                                 thermostat  see parameters "fnosep", "tempw",
                                 "nhpcl", "ndega", "nhptyp"
               rescaling       = control ionic temperature via velocities 
                                 rescaling. see parameter "tolp"
               not_controlled  = ionic temperature is not controlled


tempw          REAL ( default = 300.D0 )
               value of the ionic temperature (in Kelvin) forced by the 
               temperature control.
               meaningful only with " ion_temperature /= 'not_controlled' "
               "ndega" controls number of degrees of freedom used in 
               temperature calculation

fnosep         REAL ( default = 1.0D0 )
               oscillation frequency of the nose thermostat (in terahertz)
               [note that 3 terahertz = 100 cm^-1]
               meaningful only with " ion_temperature = 'nose' "
               for Nose-Hoover chain one can set frequencies of all thermostats
               ( fnosep = X Y Z etc. ) If only first is set, the defaults for 
               the others will be same.

nhpcl          INTEGER ( default = 1 )
               number of thermostats in the Nose-Hoover chain
               currently maximum allowed is 4

nhptyp         INTEGER ( default = 0 )
               type of the "massive" Nose-Hoover chain thermostat
               nhptyp=1 uses a NH chain per each atomic type
               nhptyp=2 uses a NH chain per atom, this one is useful
               for extremely rapid equipartitioning (equilibration is a 
               different beast)
               NOTE: if using more than 1 thermostat per system there will
               be a common thermostat added on top of them all, to disable
               this common thermostat specify nhptyp=-X instead of nhptyp=X

ndega          INTEGER ( default = 0 )
               number of degrees of freedom used for temperature calculation
               ndega <= 0 sets the number of degrees of freedom to 
               [3*nat-abs(ndega)], ndega > 0 is used as the target number

tolp           REAL ( default = 100.D0 )
               tolerance (in Kelvin) of the rescaling. When ionic temperature
               differs from "tempw" more than "tolp" apply rescaling.
               meaningful only with " ion_temperature = 'rescaling' "

tranp(i)       LOGICAL ( default = .FALSE. )
               If .TRUE. randomize ionic positions ( see "amprp" ) for the
               atomic type corresponding to the index i.

amprp(i)       REAL ( default = 0.D0 )
               amplitude of the randomization for the atomic type corresponding
               to the index i ( allowed values: 0.0 - 1.0 ).
               meaningful only if " tranp(i) = .TRUE.".

greasp         REAL ( default = 1.D0 )
               same as "grease", for ionic damped dynamics.

!
! ... keywords used only in NEB calculations
!

num_of_images  INTEGER ( default = 0 )
               number of points used to discretize the path 
               (it must be larger than 3)

opt_scheme     
               CHARACTER ( default = "quick-min" )
               specify the type of optimization scheme      
               "sd"         = steepest descent
               "broyden"    = quasi-Newton Broyden's second method (suggested)
	       "quick-min"  = a minimization algorithm based on
	                      molecular dynamics
               "damped-dyn" = damped molecular dynamics. See also the 
	                      keyword damp
               "mol-dyn"    = constant temperature molecular dynamics. See 
	                      also the keyword temp_req.
	                      Note that, in order to perform such molecular 
			      dynamics, spring forces are NOT projected 
			      along the path.
               "langevin"   = finite temperature langevin dynamics of the 
                              string (smd only). It is used to compute the
                              average path and the free-energy profile.

CI_scheme      CHARACTER. ( default = "no-CI" )
               specify the type of Climbing Image scheme
               "no-CI"      = climbing image is not used
               "highest-TS" = original CI scheme. The image highest in energy 
	                      does not feel the effect of springs and is 
			      allowed to climb along the path
               "manual"     = images that have to climb are manually selected. 
	                      See also CLIMBING_IMAGES card 

first_last_opt LOGICAL ( default = .FALSE. )
               also the first and the last configurations are optimised
               "on the fly" 
	       (these images do not feel the effect of the springs)

damp           REAL ( default = 1.D0 )
               Damping coefficient. Ignored when "opt_scheme" is different 
               from "damped-dyn"

temp_req       REAL ( default = 0.D0 Kelvin )
               temperature used for the langevin dynamics of the string.

ds             REAL ( default = 1.D0 )
               optimisation step length ( Hartree atomic units ).
               If opt_scheme="broyden" ds is used as a guess for the diagonal
               Jacobian matrix.
	              
k_max, k_min   REAL ( default = 0.1D0 Hartree atomic units )
               set them to use a Variable Elastic Constants scheme 
	       elastic constants are in the range [ k_min, k_max ] 
	       this is useful to rise the resolution around the saddle point

path_thr       REAL ( default = 0.05D0 eV / Angstrom )
               the simulation stops when the error ( the norm of the force 
	       orthogonal to the path in eV/A ) is less than path_thr.

use_fourier    LOGICAL ( default = .FALSE. )
               In the string method the path is described by its 
               Fourier components.

use_freezing   LOGICAL ( default = .FALSE. )
               if. TRUE. the images are optimised according to their error:
               only those images with an error larger than half of the largest
               are optimised. The other images are kept frozen.
               
free_energy    LOGICAL ( default = .FALSE. )
               Used in the evaluation of the free-energy profile with
               finite-temperature string dynamics.

!
! ... keywords used only in meta-dynamics calculations
!

fe_step(i)     REAL ( default = 0.04 )
               meta-dynamics step length (in principle different for each
               collective variable), defined using the same units used 
               to define the collective variables themselves (constraints).
               The step also defines the spread of the Gaussian-like bias
               potential.

g_amplitude    REAL ( default = 0.005 Hartree )
               Amplitude of the gaussians used in meta-dynamics.

fe_nstep       INTEGER ( default = 100 )
               Maximum number of steps used to evaluate the potential of
               mean force.

shake_nstep    INTEGER ( default = 10 )
               Number of steps used to switch to the new values of the
               collective variables (constraints).

===============================================================================
NAMELIST &CELL ( only if calculation = 'vc-relax', 'vc-cp' )

cell_parameters  
               CHARACTER
               default      = restart the simulation with cell parameters read
                              from the restart file or "celldm" if 
                              "restart = 'from_scratch'"
               from_input   = restart the simulation with cell parameters
                              from standard input.
                              ( see the card 'CELL_PARAMETERS' )

cell_dynamics  CHARACTER ( default = 'none' )
               set how cell should be moved
               none      = cell is kept fixed 
               sd        = steepest descent algorithm is used to optimise the 
                           cell
               damp-pr   = damped dynamics is used to optimise the cell 
                           ( Parrinello-Rahman method ).
               pr        = standard Verlet algorithm is used to propagate 
                           the cell ( Parrinello-Rahman method ).

cell_velocities
               CHARACTER
               zero      = restart setting cell velocity to zero
               default   = restart using cell velocity of the previous run

press          REAL ( default = 0.D0 )
               external pressure (in GPa: 1GPa = 10 kbar)

wmass          REAL ( default = 0.D0 )
               effective cell mass in the Parrinello-Rahman Lagrangian 
               (in atomic units) of the order of magnitude of the total atomic 
               mass (sum of the mass of the atoms) within the simulation cell.

cell_temperature  
               CHARACTER ( default = 'not_controlled )
               nose            = control cell temperature using Nose thermostat
                                 see parameters "fnoseh" and "temph".
               rescaling       = control cell temperature via velocities 
                                 rescaling.
               not_controlled  = cell temperature is not controlled.

temph          REAL ( default = 0.D0 )
               value of the cell temperature (in ???) forced
               by the temperature control.
               meaningful only with " cell_temperature /= 'not_controlled' "

fnoseh         REAL ( default = 1.D0 )
               oscillation frequency of the nose thermostat (in terahertz)
               meaningful only with " cell_temperature = 'nose' "

greash         REAL ( default = 1.D0 )
               same as "grease", for cell damped dynamics

cell_dofree    CHARACTER ( default = 'all' )
               select which of the cell parameters should be moved
               all     = all axis and angles are propagated
               volume  = the cell is simply rescaled, without changing the shape
               x       = only the x axis is moved
               y       = only the y axis is moved
               z       = only the z axis is moved
               xy      = only the x and y axis are moved, angles are unchanged
               xz      = only the x and z axis are moved, angles are unchanged
               yz      = only the y and z axis are moved, angles are unchanged
               xyz     = x, y and z axis are moved, angles are unchanged


===============================================================================
NAMELIST &WANNIER ( only if calculation = 'cp-wf' )

wf_efield      LOGICAL ( default = .FALSE. )
               If dynamics will be done in the presence of a field          

wf_switch      LOGICAL ( default = .FALSE. )
               Whether to turn on the field adiabatically (adiabatic switch)
               if true, then nbeg is set to 0.				  

sw_len         INTEGER ( default = 1 )
               No. of iterations over which the field will be turned on     
               to its final value. Starting value is 0.0                     
               If sw_len < 0, then it is set to 1. 			  
	       If you want to just optimize structures on the presence of a 
	       field, then you may set this to 1 and run a regular geometry 
 	       optimization.						  

efx0 efy0 efz0 REAL ( default = 0.D0 )
               Initial values of the field along x, y, and z directions  

efx1 efy1 efz1 REAL ( default = 0.D0 )
               Final values of the field along x, y, and z directions   

wfsd           LOGICAL ( default = .FALSE. )
               Whether to do Steepest-Descent / Conjugate-Gradient          
               localization for the Wannier function calculation            
               if TRUE, then yes, else damped dynamics.                     
               Remember, this is consistent with all the calwf options      
               as well as the tolw (see below).                            
               Not a good idea to Wannier dynamics with this if you are     
               using restart='from_scratch' option, since the spreads       
               converge fast in the beginning and ortho goes bananas.

wfdt           REAL ( default = 5.0D0 )
               The minimum step size to take in the SD/CG direction

maxwfdt        REAL ( default = 0.3D0 )
               The maximum step size to take in the SD/CG direction         
               The code calculates an optimum step size, but that may be    
               either too small (takes forever to converge)  or too large   
               (code goes crazy) . This option keeps the step size between  
               wfdt and maxwfdt. In my experience 0.1 and 0.5 work quite    
               well. (but don't blame me if it doesn't work for you           

nit            INTEGER ( default = 10 )
               Number of iterations to do for Wannier convergence.

nsd            INTEGER ( default = 10 )
               Out of a total of NIT iterations, NSD will be Steepest-Descent
               and ( nit - nsd ) will be Conjugate-Gradient.

wf_q	       REAL ( default = 1500.0D0 )
               Fictitious mass of the A matrix used for obtaining 	  
	       maximally localized Wannier functions. The unitary
	       transformation matrix U is written as exp(A) where 	  
	       A is a anti-hermitian matrix. The Damped-Dynamics is performed
	       in terms of the A matrix, and then U is computed from A.	  
	       Usually a value between 1500 and 2500 works fine, but should 
	       be tested.

wf_friction    REAL ( default = 0.3D0 )
               Damping coefficient for Damped-Dynamics.			  

nsteps         INTEGER ( default = 20 )
               Number of Damped-Dynamics steps to be performed per CP       
               iteration.

tolw           REAL ( default = 1.D-8 )
               Convergence criterion for localization.

adapt          LOGICAL ( default = .TRUE. )
               Whether to adapt the damping parameter dynamically.

calwf          INTEGER ( default = 3 )
               Wannier Function Options, can be 1,2,3,4,5
                                                                         
               1. Output the Wannier function density, nwf and wffort
                  are used for this option. see below.		          
               2. Output the Overlap matrix O_i,j=<w_i|exp{iGr}|w_j>. O is    
	          written to unit 38. For details on how O is constructed,    
                  see below.						  
               3. Perform nsteps of Wannier dynamics per CP iteration, the    
	          orbitals are now Wannier Functions, not Kohn-Sham orbitals. 
	          This is a Unitary transformation of the occupied subspace   
                  and does not leave the CP Lagrangian invariant. Expectation  
	          values remain the same. So you will **NOT** have a constant 
	          of motion during the run. Don't freak out, its normal.      
               4. This option starts for the KS states and does 1 CP iteration
                  and nsteps of Damped-Dynamics to generate  maximally         
 	          localized wannier functions. Its useful when you have the   
	          converged KS groundstate and want to get to the converged   
	          Wannier function groundstate in 1 CP Iteration.
               5. This option is similar to calwf 1, except that the output is
	          the Wannier function/wavefunction, and not the orbital      
                  density. See nwf below.
									  
nwf            INTEGER ( default = 0 )
               This option is used with calwf 1 and calwf 5. with calwf=1,  
	       it tells the code how many Orbital densities are to be       
 	       output. With calwf=5, set this to 1(i.e calwf=5 only writes  
	       one state during one run. so if you want 10 states, you have 
	       to run the code 10 times). With calwf=1, you can print many  
	       orbital densities in a single run.
               See also the PLOT_WANNIER card for specifying the states to 
               be printed.

wffort	       INTEGER ( default = 40 )
               This tells the code where to dump the orbital densities. Used
               only with CALWF=1. for e.g. if you want to print 2 orbital   
               densities, set calwf=1, nwf=2 and wffort to an appropriate   
               number (e.g. 40) then the first orbital density will be      
               output to fort.40, the second to fort.41 and so on. Note that
               in the current implementation, the following units are used  
               21,22,24,25,26,27,28,38,39,77,78 and whatever you define as  
               ndr and ndw. so use number other than these.                 

writev         LOGICAL ( default = .FALSE. )
               Output the charge density (g-space) and the list of g-vectors
               This is useful if you want to reconstruct the electrostatic  
               potential using the Poisson equation. If .TRUE. then the     
	       code will output the g-space charge density and the list     
               if G-vectors, and STOP.                                      
               Charge density is written to : CH_DEN_G_PARA.ispin (1 or 2   
               depending on the number of spin types) or CH_DEN_G_SERL.ispin
               depending on if the code is being run in parallel or serial  
               G-vectors are written to G_PARA or G_SERL.                   
                                                                         
Nota Bene 1:   For calwf = 5, wffort is not used. The 			  
	       Wannier/Wave(function) coefficients are written to unit 22 
	       and the corresponding g-vectors (basis vectors) are        
 	       written to unit 21. This option gives the g-vecs and       
	       their coeffs. in reciprocal space, and the coeffs. are     
               complex. You will have to convert them to real space       
               if you want to plot them for visualization. calwf=1 gives  
	       the orbital densities in real space, and this is usually   
               good enough for visualization.
									  
Output files used by Wannier Function options are the following

      fort.21: Used only when calwf=5, contains the full list of g-vecs. 
      fort.22: Used Only when calwf=5, contains the coeffs. corresponding
               to the g-vectors in fort.21				  
      fort.24: Used with calwf=3,contains the average spread 	          
      fort.25: Used with calwf=3, contains the individual Wannier        
               Function Spread of each state 		                  
      fort.26: Used with calwf=3, contains the wannier centers along a   
               trajectory.
      fort.27: Used with calwf=3 and 4,  contains some general runtime   
               information from ddyn, the subroutine that actually       
               does the localization of the orbitals.                    
      fort.28: Used only if efield=.TRUE. , contains the polarization    
               contribution to the total energy.			  
									  
Also, The center of mass is fixed during the Molecular Dynamics.        
									  
BEWARE : THIS WILL ONLY WORK IF THE NUMBER OF PROCESSORS IS LESS THAN OR
         EQUAL TO THE NUMBER OF STATES.                                 
                                                                         

===============================================================================
CARDS: { } = optional

-------------------------------------------------------------------------------

ATOMIC_SPECIES

Syntax:

ATOMIC_SPECIES
 X(1)     Mass_X(1)     PseudoPot_X(ntyp)
 X(2)     Mass_X(2)     PseudoPot_X(ntyp)
 ...
 X(ntyp)  Mass_X(ntyp)  PseudoPot_X(ntyp)

Description:
 X           CHARACTER : label of the atom
 Mass_X      REAL      : mass of the atomic species [amu: mass of C = 12]
                         not used if calculation='scf', 'nscf', 'phonon'
 PseudoPot_X CHARACTER:  file containing PP for this species

 The pseudopotential file is assumed to be in the new UPF format.
 If it doesn't work, the pseudopotential format is determined by
 the file name:
     *.vdb or *.van     Vanderbilt US pseudopotential code
     *.RRKJ3            Andrea Dal Corso's code (old format)
     none of the above  old PWscf norm-conserving format
 
-------------------------------------------------------------------------------

ATOMIC_POSITIONS { alat | bohr | crystal | angstrom }

   alat    : atomic positions are in units of alat
   bohr    : atomic positions are in a.u. (default)
   crystal : atomic positions are in crystal coordinates (see below)
   angstrom: atomic positions are in A

- in all cases EXCEPT calculation = 'neb' or 'smd' :

  There are "nat" cards like the following
     X  x y z   {if_pos(1) if_pos(2) if_pos(3)}
  where :
    X         Character: label of the atom as specified in ATOMIC_SPECIES
    x, y, z   Real: atomic positions 
    if_pos:   Integer, optional ( default = 1 ): component i of the force for 
              this atom is multiplied by if_pos(i), which must be either 0 or 1.
              Used to keep selected atoms and/or selected components fixed in 
              meta-dynamics, neb, smd, MD dynamics or structural optimization
              run.

- if calculation = 'neb' .OR. 'smd'

  There are at least two groups of cards, each group composed by an identifier
  followed by "nat" cards as specified above:
     identifier
     X  x y z   {if_pos(1) if_pos(2) if_pos(3)}
  The first group ( identifier="first_image" ) contains the first image,
  the last group  ( identifier="last_image" )  contains the last image.
  There is also the possibility of specifying intermediate images; in this case
  their coordinates must be set between the first_image and the last_image.
  ( identifier="intermediate_image", followed by "nat" position cards ). 

  Image configurations must be specified in the following order:
  
  first_image                                           <= mandatory
   X 0.0  0.0  0.0  { if_pos(1) if_pos(2) if_pos(3) }
   Y 0.5  0.0  0.0  { if_pos(1) if_pos(2) if_pos(3) }
   Z 0.0  0.2  0.2  { if_pos(1) if_pos(2) if_pos(3) }
  intermediate_image 1                                  <= optional
   X 0.0  0.0  0.0
   Y 0.9  0.0  0.0
   Z 0.0  0.2  0.2
  intermediate_image ...                                <= optional
   X 0.0  0.0  0.0
   Y 0.9  0.0  0.0
   Z 0.0  0.2  0.2
  last_image                                            <= mandatory
   X 0.0  0.0  0.0
   Y 0.7  0.0  0.0
   Z 0.0  0.5  0.2  
   
  IMPORTANT: the total number of configurations specified in the input file 
             must be less than num_of_images (as specified in &IONS).
             The initial path is obtained interpolating between the specified
             configurations so that all images are equispaced (only the
             coordinates of the first and last images are not changed). 

-------------------------------------------------------------------------------

ATOMIC_VELOCITIES

  optional card :  reads velocities (in atomic units) from standard input
  
  Syntax:
  
   ATOMIC_VELOCITIES
     label(1)  Vx(1) Vy(1) Vz(1)
     ....
     label(n)  Vx(n) Vy(n) Vz(n)

  Where:
  
     label                     CHARACTER(LEN=4) atomic label
     Vx(:), Vy(:) and Vz(:)    REAL             x, y and z components of the 
                                                ionic velocities

  IMPORTANT:  when starting with ion_velocities="from_input" is convenient
              to perform few steps (~5-10) with a smaller time step (0.5 a.u.)

-------------------------------------------------------------------------------

CELL_PARAMETERS

  optional card, needed only if ibrav = 0 is specified

  Syntax:
  
    CELL_PARAMETERS
      a(1,1) a(2,1) a(3,1)
      a(1,2) a(2,2) a(3,2)
      a(1,3) a(2,3) a(3,3)

  a(:,1) = crystal axis 1    alat units   if celldm(1) was specified
      2                 2    a.u.         if celldm(1)=0
      3                 3

-------------------------------------------------------------------------------

CLIMBING_IMAGES

  optional card, needed only if calculation = 'neb' and CI_scheme = 'manual'
  
  Syntax:
  
   CLIMBING_IMAGES
     index1, index2, ..., indexN
  
  where index1, index2, ..., indexN are the indices of the images to which 
  apply the Climbing Image procedure. If more than an image is specified they
  must be separated by a comma
       
-------------------------------------------------------------------------------

CONSTRAINTS

   Ionic Constraints

 Syntax:

    CONSTRAINTS
      nconstr   constr_tol
      constr_type(.)  constr(1,.)  constr(2,.) ... { constr_target(.) }

 Where:

      nconstr                      INTEGER, number of constraints

      constr_tol                   REAL,    tolerance for keeping the 
                                            constraints satisfied

      constr_type(.)               INTEGER, type of constrain :
                                       1,2: for fixed coordination numbers:
                                            four indexes must be specified
                                         3: for fixed distances: 
                                            two atom indexes must be specified 
                                         4: for fixed planar angles: 
                                            three atom indexes must be specified

      constr(1,.) constr(2,.) ...  REAL,    these variables have different 
                                            meanings for different constraint
                                            types:
                                         1: constr(1) is the first index of the
                                            atomic type involved
                                            constr(2) is the second index of the
                                            atomic type involved
                                            constr(3) is the cut-off radius for
                                            estimating the coordination
                                            constr(4) is a smoothing parameter     
                                         2: constr(1) is the atom index of the
                                            atom with constrained coordination
                                            constr(2) is the index of the atomic
                                            type involved in the coordination
                                            constr(3) is the cut-off radius for
                                            estimating the coordination
                                            constr(4) is a smoothing parameter
                                       3,4: atoms indices object of the 
                                            constraint, as they appear in 
                                            the 'POSITION' CARD
                                        
      constr_target                 REAL,   target for the constrain ( planar 
                                            angles are specified in degrees ).
                                            This variable is optional.

-------------------------------------------------------------------------------

PLOT_WANNIER

  Indices of the states that have to be printed (only for calf=1 and calf=5).

 Syntax:

    PLOT_WANNIER
      iwf(1)  iwf(2) ...

 Where:


      iwf(:)   INTEGER
               These are the indices of the state that you want to output.  
	       Also used with calwf = 1 and 5. If calwf = 1, then you need 
               nwf indices here (each in a new line). If CALWF=5, then just 
               one index in needed.     					  


-------------------------------------------------------------------------------

  ibrav is the structure index:

    ibrav        structure                   celldm(2)-celldm(6)

      0          "free", see above                 not used
      1          cubic P (sc)                      not used
      2          cubic F (fcc)                     not used   
      3          cubic I (bcc)                     not used
      4          Hexagonal and Trigonal P        celldm(3)=c/a
      5          Trigonal R                      celldm(4)=cos(aalpha)
      6          Tetragonal P (st)               celldm(3)=c/a
      7          Tetragonal I (bct)              celldm(3)=c/a
      8          Orthorhombic P                  celldm(2)=b/a,celldm(3)=c/a
      9          Orthorhombic base-centered(bco) celldm(2)=b/a,celldm(3)=c/a
     10          Orthorhombic face-centered      celldm(2)=b/a,celldm(3)=c/a
     11          Orthorhombic body-centered      celldm(2)=b/a,celldm(3)=c/a
     12          Monoclinic P                    celldm(2)=b/a,celldm(3)=c/a,
                                                 celldm(4)=cos(ab)
     13          Monoclinic base-centered        celldm(2)=b/a,celldm(3)=c/a,
                                                 celldm(4)=cos(ab)
     14          Triclinic P                     celldm(2)= b/a,
                                                 celldm(3)= c/a,
                                                 celldm(4)= cos(bc),
                                                 celldm(5)= cos(ac),
                                                 celldm(6)= cos(ab)

  The special axis is the z-axis, one basal-plane vector is along x, 
  and the other basal-plane vector is at angle beta for monoclinic 
  (beta is not actually used), at 120 degrees for trigonal and hexagonal(p)
  groups, and at 90 degrees for remaining groups, excepted fcc, bcc, 
  tetragonal(i), for which the crystallographic vectors are as follows:

  fcc bravais lattice.
  ====================

  a1=(a/2)(-1,0,1), a2=(a/2)(0,1,1), a3=(a/2)(-1,1,0).

  bcc bravais lattice.
  ====================

  a1=(a/2)(1,1,1), a2=(a/2)(-1,1,1), a3=(a/2)(-1,-1,1).

  tetragonal (i) bravais lattices.
  ================================
  a1=(a/2,a/2,c/2), a2=(a/2,-a/2,c/2), a3=(-a/2,-a/2,c/2).

  trigonal(r) groups.
  ===================

  for these groups, the z-axis is chosen as the 3-fold axis, but the
  crystallographic vectors form a three-fold star around the z-axis,
  and the primitive cell is a simple rhombohedron. if c is the cosine
  of the angle between any pair of crystallographic vectors, and if
  tx=sqrt((1-c)/2), ty=sqrt((1-c)/6), tz=sqrt((1+2c)/3), the crystal-
  lographic vectors are:

        a1=a(0,2ty,tz),  a2=a(tx,-ty,tz),  a3=a(-tx,-ty,tz).

  bco base centered orthorhombic
  =============================
  a1=(a/2,b/2,0), a2=(-a/2,b/2,0), a3=(0,0,c)
-------------------------------------------------------------------------------



FORMER FPMD INPUT


        CHARACTER(LEN=80) :: occupations
          ! occupations = 'smearing' | 'tetrahedra' | 'fixed'* | 'from_input'
          ! select the electronic states filling mode
          ! 'smearing'    smearing function is used around Fermi Level
          !               (see "ngauss" and "dgauss")
          !               NOT used in FPMD-N
          ! 'tetrahedra'  tetrahedron method
          !               NOT used in FPMD-N
          ! 'fixed'       fixed occupations automatically calculated
          ! 'from_input'  fixed occupations given in the input
          !               ( see card 'OCCUPATIONS' )


=----------------------------------------------------------------------------=!
  ELECTRONS Namelist Input Parameters
=----------------------------------------------------------------------------=!

        CHARACTER(LEN=80) :: electron_dynamics
          ! electron_dynamics = 'sd'* | 'cg' | 'damp' | 'md' | 'none' | 'diis'
          ! set how electrons should be moved
          ! 'none'   electronic degrees of freedom (d.o.f.) are kept fixed
          ! 'sd'     steepest descent algorithm is used to minimize electronic d.o.f.
          ! 'cg'     conjugate gradient algorithm is used to minimize electronic d.o.f.
          ! 'diis'   DIIS algorithm is used to minimize electronic d.o.f.
          ! 'damp'   damped dynamics is used to propagate electronic d.o.f.
          ! 'verlet' standard Verlet algorithm is used to propagate electronic d.o.f.

        CHARACTER(LEN=80) :: electron_dynamics_allowed(6)
        DATA electron_dynamics_allowed / 'sd', 'cg', 'damp', 'verlet', 'none', 'diis' /

        INTEGER :: empty_states_nbnd
          ! number of empty states to be calculated every iprint steps
          ! default value is zero

        INTEGER :: empty_states_maxstep
          ! meaningful only with "empty_states_nbnd > 0 "
          ! maximum number of iteration in the empty states calculation
          ! default is 100

        REAL(dbl) :: empty_states_delt
          ! meaningful only with "empty_states_nbnd > 0 "
          ! fictitious time step to be used in the empty states iteration
          ! default value is "dt"

        REAL(dbl) :: empty_states_emass
          ! meaningful only with "empty_states_nbnd > 0 "
          ! fictitious electronic mass to be used in the empty states iteration
          ! default value is "emass"

        REAL(dbl) :: empty_states_ethr
          ! meaningful only with "empty_states_nbnd > 0 "
          ! wave function gradient threshold, for convergence of empty states
          ! default value is ekin_conv_thr

        INTEGER :: diis_size
          ! meaningful only with " electron_dynamics = 'diis' "
          ! size of the matrix used for the inversion in the iterative subspace
          ! default is 4, allowed value 1-5

        INTEGER :: diis_nreset
          ! meaningful only with " electron_dynamics = 'diis' "
          ! number of steepest descendent step after a reset of the diis
          ! iteration, default value is 3

        REAL(dbl) :: diis_hcut
          ! meaningful only with " electron_dynamics = 'diis' "
          ! energy cutoff (a.u.), above which an approximate diagonal
          ! hamiltonian is used in finding the direction to the minimum
          ! default is "1.0"

        REAL(dbl) :: diis_wthr
          ! meaningful only with " electron_dynamics = 'diis' "
          ! convergence threshold for wave function
          ! this criterion is satisfied when the maximum change
          ! in the wave functions component between two diis steps
          ! is less than this threshold
          ! default value is ekin_conv_thr

        REAL(dbl) :: diis_delt
          ! meaningful only with " electron_dynamics = 'diis' "
          ! electronic time step used in the steepest descendent step
          ! default is "dt"

        INTEGER :: diis_maxstep
          ! meaningful only with " electron_dynamics = 'diis' "
          ! maximum number of iteration in the diis minimization
          ! default is electron_maxstep

        LOGICAL :: diis_rot
          ! meaningful only with " electron_dynamics = 'diis' "
          ! if "diis_rot = .TRUE." enable diis with charge mixing and rotations
          ! default is "diis_rot = .FALSE."

        REAL(dbl) :: diis_fthr
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! convergence threshold for ionic force
          ! this criterion is satisfied when the maximum change
          ! in the atomic force between two diis steps
          ! is less than this threshold
          ! default value is "0.0"

        REAL(dbl) :: diis_temp
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! electronic temperature, significant only if ???

        REAL(dbl) :: diis_achmix
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! "A" parameter in the charge mixing formula
          ! chmix = A * G^2 / (G^2 + G0^2) , G represents reciprocal lattice vectors

        REAL(dbl) :: diis_g0chmix
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! "G0^2" parameter in the charge mixing formula

        INTEGER :: diis_nchmix
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! dimension of the charge mixing

        REAL(dbl) :: diis_g1chmix
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! "G1^2" parameter in the charge mixing formula
          ! metric = (G^2 + G1^2) / G^2 , G represents reciprocal lattice vectors

        INTEGER :: diis_nrot(3)
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! start upgrading the charge density every "diis_nrot(1)" steps,
          ! then every "diis_nrot(2)", and at the end every "diis_nrot(3)",
          ! depending on "diis_rothr"

        REAL(dbl) :: diis_rothr(3)
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! threshold on the charge difference between two diis step
          ! when max charge difference is less than "diis_rothr(1)", switch
          ! between the "diis_nrot(1)" upgrade frequency to "diis_nrot(2)",
          ! then when the max charge difference is less than "diis_rothr(2)",
          ! switch between "diis_nrot(2)" and "diis_nrot(3)", upgrade frequency,
          ! finally when the max charge difference is less than "diis_nrot(3)"
          ! convergence is achieved

        REAL(dbl) :: diis_ethr
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! convergence threshold for energy
          ! this criterion is satisfied when the change
          ! in the energy between two diis steps
          ! is less than this threshold
          ! default value is etot_conv_thr

        LOGICAL :: diis_chguess
          ! meaningful only with "electron_dynamics='diis' " and "diis_rot=.TRUE."
          ! if "diis_chguess = .TRUE." enable charge density guess
          ! between two diis step, defaut value is "diis_chguess = .FALSE."

=----------------------------------------------------------------------------=!
  IONS Namelist Input Parameters
=----------------------------------------------------------------------------=!


        CHARACTER(LEN=80) :: ion_dynamics
          ! ion_dynamics = 'sd' | 'cg' | 'damp' | 'verlet' | 'none'*
          ! set how ions should be moved
          ! 'none'   ions are kept fixed
          ! 'sd'     steepest descent algorithm is used to minimize ionic configuration
          ! 'cg'     conjugate gradient algorithm is used to minimize ionic configuration
          ! 'damp'   damped dynamics is used to propagate ions
          ! 'verlet' standard Verlet algorithm is used to propagate ions

        CHARACTER(LEN=80) :: ion_dynamics_allowed(5)
        DATA ion_dynamics_allowed / 'sd', 'cg', 'damp', 'verlet', 'none' /

        REAL(dbl) :: ion_radius(nsx)
          ! pseudo-atomic radius of the i-th atomic species
          ! (for Ewald summation), values between 0.5 and 2.0 are usually used.

        REAL(dbl) :: ion_damping
          ! meaningful only if " ion_dynamics = 'damp' "
          ! damping frequency times delta t, optimal values could be
          ! calculated with the formula
          !        sqrt(0.5*log((E1-E2)/(E2-E3)))
          ! where E1 E2 E3 are successive values of the DFT total energy
          ! in a ionic steepest descent simulation

        CHARACTER(LEN=80) :: ion_positions
          ! ion_positions = 'default'* | 'from_input'
          ! 'default'    restart the simulation with atomic positions read
          !              from the restart file
          ! 'from_input' restart the simulation with atomic positions read
          !              from standard input ( see the card 'ATOMIC_POSITIONS' )

        CHARACTER(LEN=80) :: ion_velocities
          ! ion_velocities = 'zero' | 'default'* | 'random' | 'from_input'
          ! 'default'    restart the simulation with atomic velocities read
          !              from the restart file
          ! 'random'     start the simulation with random atomic velocities
          ! 'from_input' restart the simulation with atomic velocities read
          !              from standard input (see the card 'ATOMIC_VELOCITIES' )
          ! 'zero'       restart the simulation with atomic velocities set to zero

        CHARACTER(LEN=80) :: ion_temperature
          ! ion_temperature = 'nose' | 'not_controlled'* | 'rescaling'
          ! 'nose'           control ionic temperature using Nose thermostat
          !                  see parameters "fnosep" and "tempw"
          ! 'rescaling'      control ionic temperature via velocities rescaling
          !                  see parameter "tolp"
          ! 'not_controlled' ionic temperature is not controlled

        REAL(dbl) :: tempw
          ! meaningful only with "ion_temperature /= 'not_controlled' "
          ! value of the ionic temperature (in Kelvin) forced
          ! by the temperature control

        REAL(dbl) :: fnosep
          ! meaningful only with "ion_temperature = 'nose' "
          ! oscillation frequency of the nose thermostat (in terahertz)

        REAL(dbl) :: tolp
          ! meaningful only with "ion_temperature = 'rescaling' "
          ! tolerance (in Kelvin) of the rescaling. When ionic temperature
          ! differs from "tempw" more than "tolp" apply rescaling.

        LOGICAL   :: tranp(nsx)
          ! tranp(i) control the randomization of the i-th atomic specie
          ! .TRUE.   randomize ionic positions ( see "amprp" )
          ! .FALSE.  do nothing

        REAL(dbl) :: amprp(nsx)
          ! amprp(i) meaningful only if "tranp(i) = .TRUE.", amplitude of the
          ! randomization ( allowed values: 0.0 - 1.0 ) for the i-th atomic specie

        REAL(dbl) :: greasp
          ! same as "grease", for ionic damped dynamics
          ! NOT used in FPMD

        INTEGER   :: ion_nstepe
          ! number of electronic steps for each ionic step

        INTEGER   :: ion_maxstep
          ! maximum number of step in ionic minimization

        INTEGER :: upscale
          ! This variable is NOT used in FPMD


=----------------------------------------------------------------------------=!
  CELL Namelist Input Parameters
=----------------------------------------------------------------------------=!


        CHARACTER(LEN=80) :: cell_parameters
          ! cell_parameters = 'default'* | 'from_input'
          ! 'default'    restart the simulation with cell parameters read
          !              from the restart file or "celldm" if "restart = 'from_scratch'"
          ! 'from_input' restart the simulation with cell parameters
          !              from standard input ( see the card 'CELL_PARAMETERS' )

        CHARACTER(LEN=80) :: cell_dynamics
          ! cell_dynamics = 'sd' | 'pr' | 'none'*
          ! set how cell should be moved
          ! 'none'   cell is kept fixed
          ! 'sd'     steepest descent algorithm is used to minimize the cell
          ! 'pr'     standard Verlet algorithm is used to propagate the cell

        CHARACTER(LEN=80) :: cell_dynamics_allowed(3)
        DATA cell_dynamics_allowed / 'sd', 'pr', 'none' /

        CHARACTER(LEN=80) :: cell_velocities
          ! cell_velocities = 'zero' | 'default'*
          ! 'zero'    restart setting cell velocity to zero
          ! 'default' restart using cell velocity of the previous run

        REAL(dbl) :: press
          ! external pressure (in GPa: 1GPa = 10 kbar)

        REAL(dbl) :: wmass
          ! effective cell mass in the Parrinello-Rahman Lagrangian (in atomic units)
          ! of the order of magnitude of the total atomic mass
          ! (sum of the mass of the atoms) within the simulation cell.
          ! if you do not specify this parameters, the code will compute
          ! its value based on some physical consideration

        CHARACTER(LEN=80) :: cell_temperature
          ! cell_temperature = 'nose' | 'not_controlled'* | 'rescaling'
          ! 'nose'           control cell temperature using Nose thermostat
          !                  see parameters "fnoseh" and "temph"
          ! 'rescaling'      control cell temperature via velocities rescaling
          ! 'not_controlled' cell temperature is not controlled
          ! NOT used in FPMD

        REAL(dbl) :: temph
          ! meaningful only with "cell_temperature /= 'not_controlled' "
          ! value of the cell temperature (in ???) forced
          ! by the temperature control
          ! NOT used in FPMD

        REAL(dbl) :: fnoseh
          ! meaningful only with "cell_temperature = 'nose' "
          ! oscillation frequency of the nose thermostat (in terahertz)
          ! NOT used in FPMD

        REAL(dbl) :: greash
          ! same as "grease", for cell damped dynamics
          ! NOT used in FPMD

        CHARACTER(LEN=80) :: cell_dofree
          ! cell_dofree = 'all'* | 'volume' | 'x' | 'y' | 'z' | 'xy' | 'xz' | 'yz' | 'xyz'
          ! select which of the cell parameters should be moved
          ! 'all'    all axis and angles are propagated (default)
          ! 'volume' the cell is simply rescaled, without changing the shape
          ! 'x'      only the "x" axis is moved
          ! 'y'      only the "y" axis is moved
          ! 'z'      only the "z" axis is moved
          ! 'xy'     only the "x" and "y" axis are moved, angles are unchanged
          ! 'xz'     only the "x" and "z" axis are moved, angles are unchanged
          ! 'yz'     only the "y" and "z" axis are moved, angles are unchanged
          ! 'xyz'    "x", "y" and "z" axis are moved, angles are unchanged

        REAL(dbl) :: cell_factor
          ! NOT used in FPMD





 ----------------------------------------------------------------------

 Description of the allowed input CARDS for FPMD code

 ----------------------------------------------------------------------

 ATOMIC_SPECIES

   set the atomic species been read and their pseudopotential file

 Syntax:

    ATOMIC_SPECIE
      label(1)    mass(1)    psfile(1)
       ...        ...        ...
      label(n)    mass(n)    psfile(n)

 Example:

 ATOMIC_SPECIES
  O 16.0d0 O.BLYP.UPF
  H 1.00d0 H.fpmd.UPF

 Where:

      label(i)  ( character(len=4) )  label of the atomic species
      mass(i)   ( real )              atomic mass ( in a.m.u, carbon mass is 12.0 )
      psfile(i) ( character(len=80) ) file name of the pseudopotential

 ----------------------------------------------------------------

 ATOMIC_POSITIONS

   set the atomic positions in the cell

 Syntax:

   ATOMIC_POSITIONS (units_option)
     label(1) tau(1,1) tau(2,1) tau(3,1) mbl(1,1) mbl(2,1) mbl(3,1)
     label(2) tau(1,2) tau(2,2) tau(3,2) mbl(1,2) mbl(2,2) mbl(3,2)
      ...              ...               ...               ... ...
     label(n) tau(1,n) tau(2,n) tau(3,n) mbl(1,3) mbl(2,3) mbl(3,3)

 Example:

 ATOMIC_POSITIONS (bohr)
    O     0.0099    0.0099    0.0000  0 0 0
    H     1.8325   -0.2243   -0.0001  1 1 1
    H    -0.2243    1.8325    0.0002  1 1 1

 Where:

   units_option == crystal   position are given in scaled units
   units_option == bohr      position are given in Bohr
   units_option == angstrom  position are given in Angstrom
   units_option == alat      position are given in units of alat

   label(k) ( character(len=4) )  atomic type
   tau(:,k) ( real )              coordinates  of the k-th atom
   mbl(:,k) ( integer )           mbl(i,k) > 0 the i-th coord. of the k-th
                                  atom is allowed to be moved

 ----------------------------------------------------------------

 K_POINTS

   use the specified set of k points

 Syntax:

   K_POINTS (mesh_option)
     n
     xk(1,1) xk(2,1) xk(3,1) wk(1)
     ...     ...     ...     ...
     xk(1,n) xk(2,n) xk(3,n) wk(n)

 Example:

 K_POINTS
   10
    0.1250000  0.1250000  0.1250000   1.00
    0.1250000  0.1250000  0.3750000   3.00
    0.1250000  0.1250000  0.6250000   3.00
    0.1250000  0.1250000  0.8750000   3.00
    0.1250000  0.3750000  0.3750000   3.00
    0.1250000  0.3750000  0.6250000   6.00
    0.1250000  0.3750000  0.8750000   6.00
    0.1250000  0.6250000  0.6250000   3.00
    0.3750000  0.3750000  0.3750000   1.00
    0.3750000  0.3750000  0.6250000   3.00

 Where:

   mesh_option == automatic  k points mesh is generated automatically
                             with Monkhorst-Pack algorithm
   mesh_option == crystal    k points mesh is given in stdin in scaled units
   mesh_option == tpiba      k points mesh is given in stdin in units of ( 2 PI / alat )
   mesh_option == gamma      only gamma point is used ( default in CPMD simulation )

   n       ( integer )  number of k points
   xk(:,i) ( real )     coordinates of i-th k point
   wk(i)   ( real )     weights of i-th k point

 ----------------------------------------------------------------

 SETNFI

   Reset the step counter to the specified value

 Syntax:

  SETNFI
     nfi

 Example:

  SETNFI
     100

 Where:

    nfi (integer) new value for the step counter

 ----------------------------------------------------------------

 OCCUPATIONS

   use the specified occupation numbers for electronic states.
   Note that you should specify 10 values per line maximum!

 Syntax (nspin == 1):

   OCCUPATIONS
      f(1)  ....   ....  f(10)
      f(11) .... f(nbnd)

 Syntax (nspin == 2):

   OCCUPATIONS
      u(1)  ....   ....  u(10)
      u(11) .... u(nbnd)
      d(1)  ....   ....  d(10)
      d(11) .... d(nbnd)

 Example:

 OCCUPATIONS
  2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0 2.0
  2.0 2.0 2.0 2.0 2.0 1.0 1.0

 Where:

      f(:) (real)  these are the occupation numbers
                   for LDA electronic states.

      u(:) (real)  these are the occupation numbers
                   for LSD spin == 1 electronic states
      d(:) (real)  these are the occupation numbers
                   for LSD spin == 2 electronic states

      Note, maximum 10 values per line!

 ----------------------------------------------------------------

 VHMEAN

   Calculation of potential average along a given axis

 Syntax:

   VHMEAN
   unit nr rmin rmax asse

 Example:

   ????

 Where:

   ????

 ----------------------------------------------------------------

 OPTICAL

  Enable the calculations of optical properties

 Syntax:

    OPTICAL
      woptical noptical boptical

 Example:

   ???

 Where:

   woptical (REAL) frequency maximum in eV
   noptical (INTEGER) number of intervals
   boptical (REAL) electronic temperature (in K)
        to calculate the fermi distribution function

 ----------------------------------------------------------------

 DIPOLE

   calculate polarizability

 Syntax:

   DIPOLE

 Where:

    no parameters

 ----------------------------------------------------------------

 IESR

   use the specified number of neighbour cells for Ewald summations

 Syntax:

   ESR
    iesr

 Example:

   ESR
    3

 Where:

      iesr (integer)  determines the number of neighbour cells to be
                      considered:
                        iesr = 1 : nearest-neighbour cells (default)
                        iesr = 2 : next-to-nearest-neighbour cells
                        and so on

 ----------------------------------------------------------------

 NEIGHBOURS

   calculate the neighbours of (and the distance from) each atoms below the
   distance specified by the parameter

 Syntax:

   NEIGHBOURS
      cut_radius

 Example:

   NEIGHBOURS
      4.0

 Where:

      cut_radius ( real )  radius of the region where atoms are considered
                           as neighbours ( in a.u. )

 ----------------------------------------------------------------

 PSTAB

   calculate the pseudopotential form factor using an interpolation table

 Syntax:

    PSTAB
      pstab_size

 Example:

    PSTAB
    20000

 Where:

    pstab_size (integer) size of the interpolation table
                         typically values are between 10000 and 50000

 ----------------------------------------------------------------

 CELL_PARAMETERS

   use the specified cell dimensions

 Syntax:

    CELL_PARAMETERS
      HT(1,1) HT(1,2) HT(1,3)
      HT(2,1) HT(2,2) HT(2,3)
      HT(3,1) HT(3,2) HT(3,3)

 Example:

 CELL_PARAMETERS
    24.50644311    0.00004215   -0.14717844
    -0.00211522    8.12850030    1.70624903
     0.16447787    0.74511792   23.07395418

 Where:

      HT(i,j) (real)  cell dimensions ( in a.u. ),
                      note the relation with lattice vectors:
                      HT(1,:) = A1, HT(2,:) = A2, HT(3,:) = A3

 ----------------------------------------------------------------

 TURBO

   allocate space to store electronic states in real space while
   computing charge density, and then reuse the stored state
   in the calculation of forces instead of repeating the FFT

 Syntax:

    TURBO
      nturbo

 Example:

    TURBO
      64

 Where:

      nturbo (integer)  number of states to be stored

 ----------------------------------------------------------------

 ATOMIC_VELOCITIES

   read velocities (in atomic units) from standard input

 Syntax:

   ATOMIC_VELOCITIES
     label(1)  Vx(1) Vy(1) Vz(1)
     ....
     label(n)  Vx(n) Vy(n) Vz(n)

 Example:

   ???

 Where:

   label (character(len=4))      atomic label
   Vx(:), Vy(:) and Vz(:) (REAL) x, y and z velocity components of
                                 the ions

-------------------------------------------------------------------------------

CONSTRAINTS

   Ionic Constraints

 Syntax:

    CONSTRAINTS
      nconstr   { constr_tol }
      constr_type(.)  constr(1,.)  constr(2,.) ... { constr_target(.) }

 Where:

      nconstr     INTEGER, number of constraints
      constr_tol  REAL,    tolerance for keeping the constraints satisfied

      constr_type(.) CHARACTER, type of constrain :
      
        'type_coord'      : constraint on global coordination-number, i.e. the 
                            average number of atoms of type B surrounding the 
                            atoms of type A. The coordination is defined by
                            using a Fermi-Dirac.
                            (four indexes must be specified).
 
        'atom_coord'      : constraint on local coordination-number, i.e. the 
                            average number of atoms of type A surrounding a 
                            specific atom. The coordination is defined by
                            using a Fermi-Dirac.
                            (four indexes must be specified).
                            
        'distance'        : constraint on interatomic distance (two atom indexes
                            must be specified ).
 
        'planar_angle'    : constraint on planar angle (three atom indexes must 
                            be specified).
 
        'torsional_angle' : constraint on torsional angle (four atom indexes 
                            must be specified).

      constr(1,.) constr(2,.) ...  REAL,    these variables have different
                                            meanings for different constraint
                                            types:
                             'type_coord' : constr(1) is the first index of the
                                            atomic type involved
                                            constr(2) is the second index of the
                                            atomic type involved
                                            constr(3) is the cut-off radius for
                                            estimating the coordination
                                            constr(4) is a smoothing parameter
                             'atom_coord' : constr(1) is the atom index of the
                                            atom with constrained coordination
                                            constr(2) is the index of the atomic
                                            type involved in the coordination
                                            constr(3) is the cut-off radius for
                                            estimating the coordination
                                            constr(4) is a smoothing parameter
                               'distance' : atoms indices object of the 
                                            constraint, as they appear in 
                                            the 'POSITION' CARD
        'planar_angle', 'torsional_angle' : atoms indices object of the 
                                            constraint, as they appear in the 
                                            'POSITION' CARD (beware the order)
                                        
      constr_target                 REAL,   target for the constrain ( angles 
                                            are specified in degrees ).
                                            This variable is optional.

-------------------------------------------------------------------------------

 KSOUT

   Enable the printing of Kohn Sham states

 Syntax ( nspin == 2 ):

   KSOUT
     nu
     iu(1) iu(2) iu(3) .. iu(nu)
     nd
     id(1) id(2) id(3) .. id(nd)

 Syntax ( nspin == 1 ):

   KSOUT
     ns
     is(1) is(2) is(3) .. is(ns)

 Example:

   ???

 Where:

   nu (integer)     number of spin=1 states to be printed
   iu(:) (integer)  indexes of spin=1 states, the state iu(k) is saved to file KS_UP.iu(k)
   nd (integer)     number of spin=2 states to be printed
   id(:) (integer)  indexes of spin=2 states, the state id(k) is saved to file KS_DW.id(k)

   ns (integer)     number of LDA states to be printed
   is(:) (integer)  indexes of LDA states, the state is(k) is saved to file KS.is(k)

 ----------------------------------------------------------------

 KSOUT_EMPTY

   Enable the printing of empty Kohn Sham states

 Syntax ( nspin == 2 ):

   KSOUT_EMPTY
     nu
     iu(1) iu(2) iu(3) .. iu(nu)
     nd
     id(1) id(2) id(3) .. id(nd)

 Syntax ( nspin == 1 ):

   KSOUT_EMPTY
     ns
     is(1) is(2) is(3) .. is(ns)

 Example:

   ???

 Where:

   nu (integer)     number of spin=1 empty states to be printed
   iu(:) (integer)  indexes of spin=1 empty states, the state iu(k)
                    is saved to file KS_EMP_UP.iu(k)
   nd (integer)     number of spin=2 empty states to be printed
   id(:) (integer)  indexes of spin=2 empty states, the state id(k)
                    is saved to file KS_EMP_DW.id(k)

   ns (integer)     number of LDA empty states to be printed
   is(:) (integer)  indexes of LDA empty states, the state is(k)
                    is saved to file KS_EMP.is(k)

 Note: the first empty state has index "1" !

 ----------------------------------------------------------------
