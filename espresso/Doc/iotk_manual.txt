
Input/Output Tool Kit (IOTK)
Copyright (C) 2004 Giovanni Bussi

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


-----------------------------------------------------------------------------!
Input/Output Tool Kit (IOTK)
version 0.2.4
-----------------------------------------------------------------------------!

1 DESCRIPTION
This kit is a Fortran90 library intended to provide an easy access to tagged
files formatted using some specific rule.
A tagged file is a file containing tags and data.
Tagged files can be textual, in which case a XML-like format is used,
or binary, in which case a special format is used.
Note that this is not an XML parser, but it can be used as a writer/parser
for a subset of XML language.

1.1 STRONG POINTS
* This library is very simple to use (in author's opinion).
* The interaction with files is obtained with an interface some-what
  similar to standard Fortran I/O.
  As an example, files are accessed through Fortran units, with the
  consequences that the library can be easily integrated with other
  formatting tools.
* A well-written tagged file can be translated form binary to textual
  or vice-versa using a simple translation tool independent from the file
  structure (see TOOLS).
* The library handles directly any intrinsic Fortran datatype.
  Kind conversions are performed transparently.
* The library handles data of any rank (up to 4, but easy increasable)
* Textual files conform to XML standard, and can be browsed using an XML browser
* The library is very easy to compile: the distribution consists in a single
  fortran file plus a configuration file
* Access is fast. No overhead should be expected in writing/reading binary files
  with respect to usual fortran I/O. However, this is not true if one stores
  a large number of very small data
* Files are small. Waste of space is related to tag size, so that if
  one stores large data the waste is usually negligible.
* Aspect of data in textual files is controllable with a format string.
  Then this library can be used also for log files.
* Objects and complex structures can be easily represented

1.2 WEAK POINTS
* This library cannot read standard XML.
  Main lacks are listed here
  - attributes can be stored only with double quotes
  - attributes cannot contain double quotes
  - contents are processed only if they are written as data, using the proper format
    (see routines iotk_write_dat and iotk_scan_dat)
  - "<" and ">" symbols are treated properly only when they delimit a tag
  - ...
* the binary format is not compatible with any standard format
  However, the operation of reading/writing tags is contained in a single routine,
  which could in principle be interfaced with a better XML processor.
* This library has a serial access. If data are written in a given order
  and read in a different order, performance overheads are expected.
* This library does not provide parallel I/O functionalities.

1.3 COMPILATION
Two files are needed for compilation, "iotk_module.F" and "iotk_config.h".
Both are in the $IOTK/source directory.
The configuration file "iotk_config.h" should be edited first to configure
properly the definitions (see comments inside the file).
The fortran file "iotk_module.F" can be compiled with a standard Fortran90
compiler with C preprocessor and then linked to any Fortran90 file.
If one needs to modify the library, he should keep in account the fact that
the large "iotk_module.F" file is obtained from the smaller "iotk_module.PF"
using the sprep preprocessor, in directory $IOTK/sprep.
Then the iotk_module.PF is preprocessed to iotk_module.F with
../sprep/sprep < iotk_module.PF > iotk_module.F
Now the iotk_module.F is refreshed and can be compiled.


2 SHORT REFERENCE
The module 'iotk_module' should be included in the calling routines.
All public names exported from this module has the "iotk_" prefix.
All macros used in configuration has the "IOTK_" prefix.
Communication between users and library is based on
integers, characters and logicals of the default kind;
these kinds can be changed using proper compiler options.
However, the library can handle formatted i/o for
all intrinsic datatypes, kinds and ranks if properly configured.
This is obtained interfacing procedures which acts on all kinds,
types and (in some cases) ranks.
The large number of needed functions is obtained using a simple
loop preprocessor, so that the maximum number of types, kinds and
ranks has to be known before preprocessing. However, configuration of
kinds is obtained with standard C preprocessor, so that they can
be easily configured editing file iotk_config.h .
Backward source compatibility will be mantained (as long as it is possible)
in future version. However, order of optional arguments is not fixed and
one should always use keywords.
Backward file compatibility will be mantained (as long as it is possible) in
future version.
The library writes on files informations about the version, which are checked
on reading. If one tries to read a file written with a version newer than
the used one, an error is issued. Note that the version is a triplet
of integers, but only first two are checked. The reason is that
the last number (patch number) is related to bugs correction and not
to change in the formattation rules.
!!!!!!!!
NOTE ABOUT COMPATIBILITY
since the code is quite young, sudden change are still expected
!!!!!!!!

2.1 ERROR HANDLING
Errors in most iotk routines are handled as explained here.
If the ierr optional argument is present, it returns an error code.
ierr = 0 means that no error has occurred
ierr > 0 means that an error has occurred probably related to file corruption
ierr < 0 means that the item that was searched for has not been found
         (possible only for scanning routines)
In scanning routines, if found is present it returns .true.
if the item has been found, .false. otherwise.

If ierr is not present, the error handling is leaved to the iotk library.
That is, in case of an error of type ierr > 0, the execution stops.
In case of an error of type ierr < 0, if 'found' is not present the execution
stops.
The rule is:
* if you want to handle errors, always use the 'ierr' optional argument
* otherwise, if you scan for optional components use the 'found'
  optional argument,
* otherwise don't use it.

2.2 BINARY/TEXTUAL FILES
Units can be opened on textual or binary files.
The word 'binary' is used instead of the fortran 'unformatted' since
using this libray also binary files have a degree of formattation.
The library automatically detect the format through an INQUIRE and
acts consequently.
Note that the iotk routines check for necessary properties of an opened unit
access="direct"
blank ="null" (only textual i/o)
pad   ="yes"  (only textual i/o)

2.3 BASIC WRITING ROUTINES
iotk_write_begin(unit,name[,attr][,ierr])
iotk_write_end  (unit,name[,ierr])
iotk_write_empty(unit,name[,attr][,ierr])
iotk_write_pi   (unit,name[,attr][,ierr])
integer,      intent(in) :: unit
character(*), intent(in) :: name
character(*), intent(in) :: attr
integer,      intent(out):: ierr
These routines write a tag named 'name' on fortran unit 'unit'.
The type of the tag is determined from the name of the routine:
iotk_write_begin => <name attr>
iotk_write_end   => </name>
iotk_write_empty => <name attr/>
iotk_write_pi    => <?name attr?>
An optional attribute string can be supplied in 'attr'
In end tags, no attribute is allowed.
To build the attribute string, use iotk_write_attr

2.4 BASIC SCANNING ROUTINES
iotk_scan_begin(unit,name[,attr][,found][,ierr])
iotk_scan_end  (unit,name[,found][,ierr])
iotk_scan_empty(unit,name[,attr][,found][,ierr])
iotk_scan_pi   (unit,name[,attr][,found][,ierr])
integer,      intent(in) :: unit
character(*), intent(in) :: name ! len less or equal iotk_namlenx
character(*), intent(out):: attr ! len possibily equal iotk_attlenx
logical,      intent(out):: found
integer,      intent(out):: ierr
These routines scan for a tag named 'name' on fortran unit 'unit'.
The type of the tag is determined from the name of the routine:
iotk_scan_begin => <name attr>
iotk_scan_end   => </name>
iotk_scan_empty => <name attr/>
iotk_scan_pi    => <?name attr?>
The attribute string can be read using the 'attr' argument.
To decode the attribute string, use iotk_scan_attr

2.5 WRITING ATTRIBUTES
iotk_write_attr (attr,name,val[,first][,ierr])
character(*), intent(out):: attr ! len less or equal iotk_namlenx
character(*), intent(in) :: name ! len less or equal iotk_attlenx
TYPE(KIND),   intent(in) :: val !any type, any kind, any rank [but only scalars for character]
logical,      intent(in) :: first
integer,      intent(out):: ierr
This routine adds one attribute to the 'attr' string.
To clean the string (for the first attribute) use first=.true.
The attribute is added in the form
name="value", where "value" is a string containing a textual representation
of the val variable.

2.6 SCANNING ATTRIBUTES
iotk_scan_attr  (attr,name,val[,found][,default][,ierr])
character(*), intent(in) :: attr ! len possibily equal iotk_attlenx
character(*), intent(in) :: name ! len less or equal iotk_namlenx
TYPE(KIND),   intent(out):: val !any type, any kind, only scalars
logical,      intent(out):: found
TYPE(KIND),   intent(in) :: default RANK !same type, kinad and rank as val
integer,      intent(out):: ierr
This routine scans for one attribute from the 'attr' string.
If the attribute is found, it is read to variable val.
If it is not found and default is present, default is copied onto val.

2.7 WRITING DATA
iotk_write_dat  (unit,name,dat[,fmt][,ierr])
integer,      intent(in) :: unit
character(*), intent(in) :: name ! len less or equal iotk_namlenx
TYPE(KIND),   intent(in) :: dat RANK !any type, any kind, any rank
character(*), intent(out):: fmt
integer,      intent(out):: ierr
This routines write a data object, that is a self-described
object containg fortran data.
A single data object has the following form
<name type="TYPE" kind="KIND" size="SIZE" len="LEN" fmt="FMT">
.. DATA ...
</name>
where
TYPE is the intrinsic type (logical,integer,real,complex or character),
KIND is the data kind (present only in binary files)
SIZE is the array size (shape informations are not stored)
LEN  is the string length (present only for character type)
FMT  is a fortran format string used to write data
If the optional 'fmt' is not passed, default format is used and the fmt attribute
is not written.
Default format means one element per line. For complex, two comma separated elements
per line.
Otherwise, 'fmt' is used as a formatting string. Note that fmt="*" means
an usual write(unit,*) statement. Note also the presently the library do not deals
with double quote, so FORMAT SHOULD NOT CONTAIN DOUBLE QUOTES

2.8 SCANNING DATA
iotk_scan_dat  (unit,name,dat[,found][,default][,ierr])
integer,      intent(in) :: unit
character(*), intent(in) :: name ! len less or equal iotk_namlenx
TYPE(KIND),   intent(out):: dat RANK !any type, any kind, any rank
logical,      intent(out):: found
TYPE(KIND),   intent(in) :: default RANK !same type, kinad and rank as dat
integer,      intent(out):: ierr
A data object written with iotk_write_dat is read.
If it is not found and default is present, default is copied onto dat.
If a keyword is absent in the file, the value is deduced from the
dat formal argument and no check is performed. This allows to write
rapidly by hand data objects.
If fmt is not present on file, the default format is used.
Types and sizes are checked. Different kinds (for binary i/o) are automatically
converted.
Length (for characters) are not checked. If strings on files
are longer then len(dat), only the first characters are read; if strings
on files are shorter, dat is padded with blanks.

2.10 OPENING AND CLOSING FILES
iotk_open_write(unit[,file][,binary][,new][,root][,ierr])
integer,      intent(in)  :: unit
character(*), intent(in)  :: file
logical,      intent(in)  :: binary
logical,      intent(in)  :: new
character(*), intent(in)  :: root ! len less or equal iotk_namlenx
integer,      intent(out) :: ierr
If file is present, this routines opens file 'file' on
unit 'unit' with the proper options.
If binary is present and true, the file is binary.
If new is present and true, the file must not exist
If file is not present, unit is assumed to be already connected;
If root is present, it is used as the name of the root
begin/end pair. If it is absent, the default "Root" is used.
Also informations about iotk version and binary format are written as
pi informations.

iotk_open_read(unit[,file][,binary][,root][,ierr])
integer,      intent(in)  :: unit
character(*), intent(in)  :: file
logical,      intent(in)  :: binary
logical,      intent(in)  :: new
character(*), intent(out) :: root ! len possibly equal iotk_namlenx
integer,      intent(out) :: ierr
If file is present, this routines opens file 'file' on
unit 'unit' with the proper options.
If binary is present and true, the file is binary.
If file is not present, unit is assumed to be already connected.
If root is present, the name of root in file is read onto that variable.

iotk_close_write(unit[,ierr])
iotk_close_read(unit[,ierr])
integer,      intent(in)  :: unit
integer,      intent(out) :: ierr
This routines close a file opened (or connected after opening) with iotk_open_*


2.11 OTHER UTILITIES

iotk_index      (index)
character(*)        :: iotk_index
integer, intent(in) :: index ! scalar or rank 1
Returns a string representing the index in an array.
Example: index = (/1,2,3/) => iotk_index = ".1.2.3"
iotk_index is large enough but should be trimmed
(i.e. always use trim(iotk_index(index))
The correct way for writing an array of derived types is
to build the names as follows
! ONE-DIMENSIONAL ARRAY
do i = 1 , n
  call iotk_write_begin(unit,"dummy"//trim(iotk_index(i)))
! WRITE THE OBJECT HERE
  call iotk_write_end  (unit,"dummy"//trim(iotk_index(i)))
end do
do i = 1 , n
  do j = 1 , m
! NOTE THE ORDER OF INDEXES, THE FASTER IS THE LAST
    call iotk_write_begin(unit,"dummy"//trim(iotk_index((/i,j/))))
! WRITE THE OBJECT HERE
    call iotk_write_end  (unit,"dummy"//trim(iotk_index((/i,j/))))
  end do
end do

iotk_last_iostat()
integer :: iotk_last_iostat
Returns the last iostat value in an file I/O operation.
It can be used to detect the low-level origin of an error.

iotk_free_unit(unit[,ierr])
integer, intent(out) :: unit
integer, intent(out) :: ierr
This routine returns the number of a free fortran unit.


THIS ROUTINE HAVE BEEN TEMPORARILY REMOVED:
  iotk_magic(file[,binary][,ierr])
  character(*), intent(in) :: file
  logical,      intent(out):: binary
  integer,      intent(out):: ierr
  This routine hopefully understand if a file on the disk is
  binary or textual. The result is returned in the binary argument.
  It works only if begin/end pairs are present.






