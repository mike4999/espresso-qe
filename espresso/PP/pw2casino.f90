! #include "machine.h"

! This subroutine writes the file pwfn.data containing the plane wave
! coefficients and other stuff needed by the QMC code CASINO. 
program pw2casino
 
  use pwcom
  use io_files, only: nd_nmbr,prefix,nwordwfc,iunwfc
  USE wavefunctions_module, ONLY : evc
  use becmod
  implicit none
  integer :: ig, ibnd, ik, io, na, j, ispin, nbndup, nbnddown, &
       nk, ngtot, ig7, ikk, nt
  integer, allocatable :: index(:), igtog(:)
  logical :: exst, found
  real(kind=DP) :: ek, eloc, enl,charge
  complex(kind=DP), allocatable :: aux(:), hpsi(:,:)
  integer :: ios
  REAL (KIND=DP), EXTERNAL :: ewald

  namelist / inputpp / prefix

  read (5, inputpp, err=200, iostat=ios)
200 call errore('pw2casino', 'reading inputpp namelist', abs(ios))
  call start_postproc(nd_nmbr)
  call read_file
  call openfil
  
 call init_us_1

  io = 77

  write (6,'(/,5x,''Writing file pwfn.data for program CASINO'')')

  call seqopn( 77, 'pwfn.data', 'formatted',exst)  

  allocate (hpsi(npwx, nbnd))
  allocate (aux(nrxx))
  ! four times npwx should be enough
  allocate (index (4*npwx) )
  allocate (igtog (4*npwx) )

  hpsi (:,:) = (0.d0, 0.d0)
  index(:) = 0
  igtog(:) = 0

  if( lsda ) then
     nbndup = nbnd
     nbnddown = nbnd
     nk = nks/2
!     nspin = 2
  else
     nbndup = nbnd
     nbnddown = 0
     nk = nks
!     nspin = 1
  endif

!  if(nks > 1) rewind(iunigk)
!  do ik=1,nks
!     if(nks > 1) read(iunigk) npw, igk
!     do ig =1, npw
!        if( igk(ig) > 4*npwx ) & 
!             call errore ('pw2casino','increase allocation of index', ig)
!        index( igk(ig) ) = 1
!     enddo
!  enddo
!  ngtot = 0
!  do ig = 1, 4*npwx
!     if( index(ig) == 1 ) then
!        ngtot = ngtot + 1
!        igtog(ngtot) = ig
!     endif
!  enddo

!  if(nks > 1) rewind(iunigk)
  ek  = 0.d0
  eloc= 0.d0
  enl = 0.d0
  do ispin = 1, nspin 
     !
     ! calculate the local energy
     !
     !      bring rho to G-space
     !
     aux(:) = DCMPLX ( rho(:,ispin), 0.d0)
     call cft3(aux,nr1,nr2,nr3,nrx1,nrx2,nrx3,-1)
     !
     !     calculate the local contribution to the total energy
     !
     do nt=1,ntyp
        do ig = 1, ngm
           eloc = eloc + vloc(igtongl(ig),nt) * strf(ig,nt) &
                * conjg(aux(nl(ig)))
        enddo
     enddo
     eloc = eloc * omega 
#ifdef PARA
     call reduce(1,eloc)
#endif
  do ik = 1, nk
     ikk = ik + nk*(ispin-1)
     call gk_sort (xk (1, ikk), ngm, g, ecutwfc / tpiba2, npw, igk, g2kin)
     call davcio (evc, nwordwfc, iunwfc, ikk, - 1)
     call init_us_2 (npw, igk, xk (1, ikk), vkb)
     call ccalbec (nkb, npwx, npw, nbnd, becp, vkb, evc)

     

!        ikk = ik + nk*(ispin-1)
!       if( nks > 1 ) then
!           read(iunigk) npw, igk
!           call davcio(evc,nwordwfc,iunwfc,ikk,-1)
!        endif
!        call init_vkb_2(npw,igk,xk(1,ikk),vkb)
        !
        ! calculate the kinetic energy
        !
!        do ig = 1, npw
!           g2kin(ig) = ( ( xk(1,ikk)+g(1,igk(ig)) )**2 + &
!                ( xk(2,ikk)+g(2,igk(ig)) )**2 + &
!                ( xk(3,ikk)+g(3,igk(ig)) )**2 ) * tpiba2
!        enddo
        do ibnd = 1, nbnd
           do j = 1, npw
              hpsi(j,ibnd) =  g2kin(j) * evc(j,ibnd)
              ek = ek +  conjg(evc(j,ibnd))*hpsi(j,ibnd) * wg(ibnd,ikk)
           end do
           do nt=1,ntyp
              do j=1,nkb
                 enl=enl+abs(becp(j,ibnd))**2*wg(ibnd,ikk)*dion(j,j,nt)
              enddo
           enddo
        enddo
        ek = ek * tpiba2
#ifdef PARA
        call reduce(1,ek)
#endif
        print *,ek
        !
        ! calculate the non-local energy
        !
 !       call compute_enl (npwx, npw, evc, nbnd, enl, ikk)
     enddo
  enddo

#ifdef PARA
  call poolreduce(1,ek)
  call poolreduce(1,enl)
#endif

!Compute ewald contribution
  ewld = ewald( alat, nat, ntyp, ityp, zv, at, bg, tau, omega, &
       g, gg, ngm, gcutm, gstart, gamma_only, strf )

!compute hartree and xc contribution

  CALL v_of_rho( rho, rho_core, nr1, nr2, nr3, nrx1, nrx2, nrx3, &
       nrxx, nl, ngm, gstart, nspin, g, gg, alat, omega, &
       ehart, etxc, vtxc, charge, vnew )

etot=(ek + (etxc-etxcc)+ehart+eloc+enl+ewld)

  write(io,'(a)') title
  write(io,'(a)')
  write(io,'(a)') ' BASIC INFO'
  write(io,'(a)') ' ----------'
  write(io,'(a)') ' Generated by:'
  write(io,'(a)') ' PWSCF'                    
  write(io,'(a)') ' Method:'
  write(io,'(a)') ' DFT'
  write(io,'(a)') ' DFT Functional:'         
  write(io,'(a)') ' unknown'
  write(io,'(a)') ' Pseudopotential'
  write(io,'(a)') ' unknown'
  write(io,'(a)') ' Plane wave cutoff (au)'              
  write(io,*) ecutwfc/2
  write(io,'(a)') ' Spin polarized:'
  write(io,*)lsda 
  write(io,'(a)') ' Total energy (au per primitive cell)' 
  write(io,*)etot/2                
  write(io,'(a)') ' Kinetic energy (au per primitive cell)' 
  write(io,*)ek/2              
  write(io,'(a)') ' Local potential energy (au per primitive cell)' 
  write(io,*)eloc/2 
  write(io,'(a)') ' Non local potential energy(au per primitive cel)'
  write(io,*)enl/2
  write(io,'(a)') ' Electron electron energy (au per primitive cell)' 
  write(io,*)ehart/2    
  write(io,'(a)') ' Ion ion energy (au per primitive cell)' 
  write(io,*)ewld/2
  write(io,'(a)') ' Number of electrons per primitive cell'                 
  write(io,*)nint(nelec)
  write(io,'(a)') ' '                 
  write(io,'(a)') ' GEOMETRY'
  write(io,'(a)') ' -------- '
  write(io,'(a)') ' Number of atoms per primitive cell '
  write(io,*) nat
  write(io,'(a)')' Atomic number and position of the atoms(au) '
  do na = 1, nat
     write(io,'(i6,3f20.14)') int(zmesh(ityp(na))), (alat*tau(j,na),j=1,3)
  enddo
  write(io,'(a)') ' Primitive lattice vectors (au) '
  write(io,*) alat*at(1,1), alat*at(2,1), alat*at(3,1)
  write(io,*) alat*at(1,2), alat*at(2,2), alat*at(3,2)
  write(io,*) alat*at(1,3), alat*at(2,3), alat*at(3,3)
  write(io,'(a)') ' '
  write(io,'(a)') ' G VECTORS'
  write(io,'(a)') ' ---------'
  write(io,'(a)') ' Number of G-vectors'
  write(io,*) ngm
  write(io,'(a)') ' Gx Gy Gz (au)'
  do ig = 1, ngm
     write(io,*) tpi/alat*g(1,ig), tpi/alat*g(2,ig), &
          tpi/alat* g(3,ig)
  enddo
  write(io,'(a)') ' '
  write(io,'(a)') ' WAVE FUNCTION'
  write(io,'(a)') ' -------------'
  write(io,'(a)') ' Number of k-points'
  write(io,*) nks
!  if(nks > 1) rewind(iunigk)
  do ispin = 1, nspin 
     do ik = 1, nks
        ikk = ik + nks*(ispin-1)
        if( nks > 1 ) then
!           read(iunigk) npw, igk
           call davcio(evc,nwordwfc,iunwfc,ikk,-1)
        endif

        write(io,'(a)') ' k-point # ; # of bands (up spin/down spin); &
             &           k-point coords (au)'
        write(io,'(3i4,3f20.16)') ik, nbndup, nbnddown, &
             (tpi/alat*xk(j,ikk),j=1,3)
        do ibnd = 1, nbnd
           write(io,'(a)') ' Band, spin, eigenvalue (au)'
           write(io,*) ibnd, ispin, et(ibnd,ikk)/2 
           write(io,'(a)') ' Eigenvectors coefficients'
           do ig=1, ngm
              ! now for all G vectors find the PW coefficient for this k-point
              found = .false.
              do ig7 = 1, npw
                 if( igk(ig7) == ig )then
                    write(io,*) evc(ig7,ibnd)
                    found = .true.
                    goto 17
                 endif
              enddo
              ! if can't find the coefficient this is zero
17            if( .not. found ) write(io,*) (0.d0, 0.d0)
           enddo
        enddo
     enddo
  enddo

  print *,'Kinetic energy', ek/2
  print *,'Local energy', eloc/2
  print *,'Non-Local energy', enl/2
  print *,'Ewald energy', ewld/2
  print *,'xc contribution',(etxc-etxcc)/2
  print *,'hartree contribution', ehart/2
  print *, 'Total energy', (ek + (etxc-etxcc)+ehart+eloc+enl+ewld)/2


end program pw2casino






