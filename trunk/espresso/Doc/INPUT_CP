Input data format: { } = optional, [ ] = it depends

All quantities whose dimensions are not explicitly specified are in
HARTREE ATOMIC UNITS

===============================================================================
&CONTROL
  ...
/
&SYSTEM
 ...
/
&ELECTRONS
...
/
[ &IONS
  ...
 / ]
[ &CELL
  ...
 / ]
[ &WANNIER
  ...
 / ]
ATOMIC_SPECIES
 X  Mass_X  PseudoPot_X
 Y  Mass_Y  PseudoPot_Y
 Z  Mass_Z  PseudoPot_Z
ATOMIC_POSITIONS { alat | bohr | crystal | angstrom }
if ( calculation = 'neb' )
  first_image
  X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
  Y 0.5  0.0  0.0
  Z O.0  0.2  0.2
 { intermediate_image 1
   X 0.0  0.0  0.0
   Y 0.9  0.0  0.0
   Z O.0  0.2  0.2
   intermediate_image ...
   X 0.0  0.0  0.0
   Y 0.9  0.0  0.0
   Z O.0  0.2  0.2 }
  last_image
  X 0.0  0.0  0.0
  Y 0.7  0.0  0.0
  Z O.0  0.5  0.2 
else
  X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
  Y 0.5  0.0  0.0
  Z O.0  0.2  0.2
[ CELL_PARAMETERS { cubic | hexagonal }
   a(1,1) a(2,1) a(3,1)
   a(1,2) a(2,2) a(3,2)
   a(1,3) a(2,3) a(3,3) ]
[ OCCUPATIONS
   f_inp(1,1)  f_inp(2,1)  f_inp(3,1) ... f_inp(10,1)
   f_inp(11,1) f_inp(12,1) ... f_inp(nbnd,1)
 [ f_inp(1,2)  f_inp(2,2)  f_inp(3,2) ... f_inp(10,2)
   f_inp(11,2) f_inp(12,2) ... f_inp(nbnd,2) ] ]
[ CLIMBING_IMAGES
   list of images, separated by a comma ]   
[ CONSTRAINTS
   nconstr   constr_tol
   constr_type(.)   constr(1,.)   constr(2,.) { constr_target(.) } ]

===============================================================================
NAMELIST &CONTROL

calculation    CHARACTER ( default = 'cp' )
               a string describing the task to be performed:
               'cp', 'scf', 'nscf', 'relax', 'vc-relax', 'vc-cp', 'neb', 
               'smd', 'cp-wf'
               where :               
               cp       = Car-Parrinello MD (includes cases 'scf' and 'relax')
               scf      = electron minimization
               nscf     = non-selfconsistent calculation of KS states:
                          reads the charge density previously saved to disk,
                          sets occupancies to a bogus nonzero value
               relax    = ionic minimization
               vc-relax = ionic + cell minimization
               vc-cp    = variable-cell Car-Parrinello (-Rahman) dynamics
               neb      = Nudged Elastc Band method
               smd      = String Method Dynamics
               cp-wf    = Car-Parrinello MD with Wannier functions

title          CHARACTER ( default = 'MD Simulation' )
               reprinted on output.

prefix         CHARACTER ( default = 'cp' )
               basename prepended to input/output filenames. 
               
restart_mode   CHARACTER ( default = 'restart' )
               from_scratch    = from scratch
	                         NEB only: the starting path is obtained
                                 with a linear interpolation between the images
                                 specified in the ATOMIC_POSITIONS card.
			         Note that in the linear interpolation
                                 periodic boundary conditions ARE NON USED.
               restart         = continue a previous simulation,
                                 and performs  "nstep" new steps,
               reset_counters  = continue a previous simulation,
                                 performs  "nstep" new steps, resetting
                                 the counter and averages
               upto            = continue a previous simulation and stops 
                                 swhen the counter value is equal "nstep"

verbosity      CHARACTER
               'high' | 'default' | 'low' | 'minimal'

nstep          INTEGER                         
               number of ionic + electronic steps
               default =    1 if calculation = 'scf', 'nscf'
	               =    0 if calculation = 'neb', 'smd'
                       =   50 for the other cases

iprint         INTEGER ( default = 10 )
               Number of steps between successive writings of relevant 
               physical quantities to standard output and to files "fort.3?" 
               or "prefix.???" depending on "prefix" parameter

isave          INTEGER ( default = 100 )
               Number of steps between successive savings of
               information needed to restart the run ( see also ndr, ndw ).

tstress        LOGICAL ( default = .FALSE. )
               This flag controls the printing of the stress, always .TRUE.
               when the cell is moving.
               .TRUE.    = write the stress tensor to standard output 
                           every "iprint" steps.
               .FALSE.   = do not write the stress tensor stdout.

tprnfor        LOGICAL ( default = .FALSE. )
               This flag controls the printing of the interatomic forces, 
               always .TRUE. when the ions are moving.
               .TRUE.    =  write the atomic forces to standard output every 
                            "iprint" steps.
               .FALSE.   =   do not write atomic forces to stdout.

dt             REAL ( default = 1.D0 )
               time step for molecular dynamics, in Hartree atomic units.
               ( 1 a.u. of time = 2.4189 * 10^-17 s )

outdir         CHARACTER ( default = current directory ('./') )
               input, temporary, output files are found in this directory.

disk_io        CHARACTER
               'high', 'default', 'low', 'minimal'

pseudo_dir     CHARACTER ( default = current directory ('./') )
               directory containing pseudopotential files.

ekin_conv_thr  REAL ( default = 1.D-6 )
               convergence criterion for electron minimization:
               convergence is achieved when "ekin < ekin_conv_thr".
               See also etot_conv_thr - both criteria must be satisfied.

etot_conv_thr  REAL ( default = 1.D-4 )
               convergence criteria for ion minimization:
               "etot(n+1)-etot(n) < etot_conv_thr", where "n" is the step 
               index, and "etot" the DFT energy.
               See also ekin_conv_thr for electron minimization and 
               forc_conv_thr for ion minimization - both criteria must be 
               satisfied.

forc_conv_thr  REAL ( default = 1.D-3 )
               "MAXVAL(fion) < forc_conv_thr", where fion are the atomic 
               forces.
               See also etot_conv_thr - both criteria must be satisfied.

ndr, ndw       INTEGER ( default = 50 )
               Units for input and output restart file.


===============================================================================
NAMELIST &SYSTEM

ibrav          INTEGER
               bravais-lattice index (must be specified)
               see at the end of this file

celldm(i)      REAL, DIMENSION(6)                        
               crystallographic constants - see at the end of this file
               alat = celldm(1) is the lattice parameter "a" (in BOHR)
               only needed celldm (depending on ibrav) must be specified

a, b, c, cosab, cosac, cosbc: 
               REAL
	       traditional crystallographic constants (a,b,c in ANGSTROM)
               specify either these or celldm  but not both
 
nat            INTEGER
               number of atoms in the unit cell - must be specified

ntyp           INTEGER
               number of types of atoms in the unit cell - must be specified

nelec          INTEGER
               number of electron in the unit cell. If not specified it is
               read from the pseudopotential

nbnd           INTEGER ( default = nelec / 2 )
               number of electronic states (bands) to be calculated.

ecutwfc        REAL
               kinetic energy cutoff (Ry) for wavefunctions
               (must be specified)
	       
ecutrho        REAL ( default = 4 * ecutwfc )
               kinetic energy cutoff (Ry) for charge density and potential
               May be larger ( for ultrasoft PP ) or somewhat smaller 
               ( but not much smaller ) than the default value

nr1,nr2,nr3    INTEGER
               three-dimensional FFT mesh (hard grid) for charge
               density (and scf potential). If not specified
               the grid is calculated based on the cutoff for
               charge density (see also "ecutrho")

nr1s,nr2s,nr3s INTEGER
               three-dimensional mesh for wavefunction FFT and for the smooth 
               part of charge density ( smooth grid ). 
               Coincides with nr1, nr2, nr3 if ecutrho = 4 * ecutwfc ( default )


nr1b, nr2b, nr3b 
               INTEGER
               dimensions of the "box" grid for Ultrasoft pseudopotentials
               must be specified if Ultrasoft PP are present

nspin          INTEGER ( default = 1 )
               nspin = 1 :   non-polarized calculation
               nspin = 2 :  spin-polarized calculation

nelup, neldw   REAL
               number of spin-up and spin-down electrons, respectively.
               The sum must yield nelec that must also be specified
               explicitely in this case.

ecfixed        REAL ( default = 0.0 )
qcutz          REAL ( default = 0.0 )
q2sigma        REAL ( default = 0.1 )
               parameters for modified functional to be used in
               variable-cell molecular dynamics (or in stress calculation)
               "ecfixed" is the value (in Rydberg) of the constant-cutoff 
               "qcutz" and "q2sigma" are the height and the width (in Rydberg) 
               of the energy step for reciprocal vector whose square modulus 
               is grather than "ecfixed"


===============================================================================
NAMELIST &ELECTRONS

electron_maxstep  
               INTEGER ( default = 100 )
               maximum number of iterations in a scf step

electron_dynamics 
               CHARACTER ( default = 'none' )
               set how electrons shold be moved
               none    = electronic degrees of freedom (d.o.f.) are kept fixed 
               sd      = steepest descent algorithm is used to minimize 
                         electronic d.o.f. 
               damp    = damped dynamics is used to propagate electronic d.o.f. 
               verlet  = standard Verlet algorithm is used to propagate 
                         electronic d.o.f. 
               cg      = conjugate gradient is used to converge the 
                         wavefunction at each ionic step. 'cg' can be used 
                         interchangeably with 'verlet' for a couple of ionic
                         steps in order to "cool down" the electrons and
                         return them back to the BO surface. Then 'verlet' can 
                         be restarted again. This procedure is useful when
                         electronic adiabaticity in CP is lost yet the ionic 
                         velocities need to be preserved.

emass          REAL ( default = 400.D0 )
               effective electron mass in the CP Lagrangian, in atomic units 
               ( 1 a.u. of mass = 1/1822.9 a.m.u. = 9.10939 * 10^-31 kg )

emass_cutoff   REAL ( default = 2.5D0 )
               mass cut-off (in Rydberg) for the Fourier acceleration
               effective mass is rescaled for "G" vector components with 
               kinetic energy above "emass_cutoff" 

orthogonalization 
               CHARACTER ( default = 'ortho' )
               selects the orthonormalization method for electronic wave 
               functions
               ortho         = use iterative algorithm - if it doesn't converge, 
                               reduce the timestep, or use options ortho_max 
                               and ortho_eps, or use Gram-Schmidt instead just 
                               to start the simulation
               Gram-Schmidt  = use Gram-Schmidt algorithm - to be used ONLY in 
                               the first few steps. 
                               YIELDS INCORRECT ENERGIES AND EIGENVALUES.

ortho_eps      REAL ( default = 1.D-8 )
               tolerance for iterative orthonormalization
               meaningful only if orthogonalization = 'ortho'
            
ortho_max      INTEGER ( default = 20 )
               maximum number of iterations for orthonormalization
               meaningful only if orthogonalization = 'ortho'

electron_damping 
               REAL ( default = 0.1D0 )
               damping frequency times delta t, optimal values could be
               calculated with the formula :
                        SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) )
               where E1, E2, E3 are successive values of the DFT total energy 
               in a steepest descent simulations.
               meaningful only if " electron_dynamics = 'damp' "

electron_velocities
               CHARACTER
               zero      = restart setting electronic velocities to zero
               default   = restart using electronic velocities of the 
                           previous run

electron_temperature
               CHARACTER ( default = 'not_controlled' )
               nose            = control electronic temperature using Nose 
                                 thermostat. see parameter "fnosee" and "ekincw"
               rescaling       = control electronic temperature via velocities 
                                 rescaling 
               not_controlled  = electronic temperature is not controlled

ekincw         REAL ( default = 0.001D0 )
               value of the average kinetic energy (in atomic units) forced
               by the temperature control
               meaningful only with " electron_temperature /= 'not_controlled' "

fnosee         REAL ( default = 1.D0 )
               oscillation frequency of the nose thermostat (in terahertz) 
               meaningful only with " electron_temperature = 'nose' "

startingwfc    CHARACTER ( default = 'random' )
               random  = randomize electronic wave functions ( see "ampre" )
               atomic  = from superposition of atomic state 
                         (NOT YET IMPLEMENTED)

ampre          REAL ( default = 0.D0 )
               amplitude of the randomization ( allowed values: 0.0 - 1.0 )
               meaningful only if " startingwfc = 'random' "

grease         REAL ( default = 1.D0 )
               a number <= 1, very close to 1: the damping in electronic
               damped dynamics is multiplied at each time step by "grease"
               (avoids overdamping close to convergence: Obsolete ?)
               grease = 1 : normal damped dynamics

===============================================================================
NAMELIST &IONS  ( only if calculation = 'cp', 'relax',
                                        'vc-relax', 'vc-cp', 'neb', 'smd' )

ion_dynamics   CHARACTER ( default = 'none' )
               set how ions shold be moved
               none    = ions are kept fixed 
               sd      = steepest descent algorithm is used to minimize ionic 
                         configuration
               cg      = conjugate gradient algorithm is used to minimize ionic 
                         configuration
               damp    = damped dynamics is used to propagate ions
               verlet  = standard Verlet algorithm is used to propagate ions

ion_nstepe     INTEGER ( default = 1 )
               number of electronic steps between for each ionic step.

ion_radius(i)  REAL ( default = 0.5D0 )
               pseudo-atomic radius of the i-th atomic species for Ewald 
               summation (une for each atomic type). 
               values between 0.5 and 2.0 are usually used.

ion_damping    REAL ( default = 0.1D0 )
               damping frequency times delta t, optimal values could be
               calculated with the formula:
                          SQRT( 0.5 * LOG( ( E1 - E2 ) / ( E2 - E3 ) ) )
               where E1 E2 E3 are successive values of the DFT total energy 
               in a ionic steepest descent simulation.
               meaningful only if " ion_dynamics = 'damp' "

ion_positions  CHARACTER
               default     = restart the simulation with atomic positions read
                             from the restart file.
               from_input  = restart the simulation with atomic positions read
                             from standard input.
                             ( see also the card 'ATOMIC_POSITIONS' )

ion_velocities CHARACTER
               initial ionic velocities
               default     = restart the simulation with atomic velocities read
                             from the restart file
               random      = start the simulation with random atomic velocities
               from_input  = restart the simulation with atomic velocities read
                             from standard input 
                             ( see the card 'ATOMIC_VELOCITIES' )
               zero        = restart the simulation with atomic velocities set 
                             to zero

ion_temperature  
               CHARACTER ( default = 'not_controlled' )
               nose            = control ionic temperature using Nose-Hoover
                                 thermostat  see parameters "fnosep", "tempw",
                                 "nhpcl", "ndega", "nhptyp"
               rescaling       = control ionic temperature via velocities 
                                 rescaling. see parameter "tolp"
               not_controlled  = ionic temperature is not controlled


tempw          REAL ( default = 300.D0 )
               value of the ionic temperature (in Kelvin) forced by the 
               temperature control.
               meaningful only with " ion_temperature /= 'not_controlled' "
               "ndega" controls number of degrees of freedom used in 
               temperature calculation

fnosep         REAL ( default = 1.0D0 )
               oscillation frequency of the nose thermostat (in terahertz)
               [note that 3 terahertz = 100 cm^-1]
               meaningful only with " ion_temperature = 'nose' "
               for Nose-Hoover chain one can set frequencies of all thermostats
               ( fnosep = X Y Z etc. ) If only first is set, the defaults for 
               the others will be same.

nhpcl          INTEGER ( default = 1 )
               number of thermostats in the Nose-Hoover chain
               currently maximum allowed is 4

nhptyp         INTEGER ( default = 0 )
               type of the "massive" Nose-Hoover chain thermostat
               nhptyp=1 uses a NH chain per each atomic type
               nhptyp=2 uses a NH chain per atom, this one is useful
               for extremely rapid equipartitioning (equilibration is a 
               different beast)
               NOTE: if using more than 1 thermostat per system there will
               be a common thermostat added on top of them all, to disable
               this common thermostat specify nhptyp=-X instead of nhptyp=X

ndega          INTEGER ( default = 0 )
               number of degrees of freedom used for temperature calculation
               ndega <= 0 sets the number of degrees of freedom to 
               [3*nat-abs(ndega)], ndega > 0 is used as the target number

tolp           REAL ( default = 100.D0 )
               tolerance (in Kelvin) of the rescaling. When ionic temperature
               differs from "tempw" more than "tolp" apply rescaling.
               meaningful only with " ion_temperature = 'rescaling' "

tranp(i)       LOGICAL ( default = .FALSE. )
               If .TRUE. randomize ionic positions ( see "amprp" ) for the
               atomic type corresponding to the index i.

amprp(i)       REAL ( default = 0.D0 )
               amplitude of the randomization for the atomic type corresponding
               to the index i ( allowed values: 0.0 - 1.0 ).
               meaningful only if " tranp(i) = .TRUE.".

greasp         REAL ( default = 1.D0 )
               same as "grease", for ionic damped dynamics.

!
! ... keywords used only in NEB calculations
!

num_of_images  INTEGER ( default = 0 )
               number of points used to discrtize the path 
               (it must be larger than 3)

opt_scheme     
               CHARACTER ( default = "quick-min" )
               specify the type of optimization scheme      
               "sd"         = steepest descent
               "broyden"    = quasi-Newton Broyden's second method (suggested)
	       "quick-min"  = a minimization algorithm based on
	                      molecular dynamics
               "damped-dyn" = damped molecular dynamics. See also the 
	                      keyword damp
               "mol-dyn"    = constant temperature molecular dynamics. See 
	                      also the keyword temp_req.
	                      Note that, in order to perform such molecular 
			      dynamics, spring forces are NOT projected 
			      along the path.
               "langevin"   = finite temperature langevin dynamics of the 
                              string (smd only). It is used to compute the
                              average path and the free-energy profile.

CI_scheme      CHARACTER. ( default = "no-CI" )
               specify the type of Climbing Image scheme
               "no-CI"      = climbing image is not used
               "highest-TS" = original CI scheme. The image highest in energy 
	                      does not feel the effect of springs and is 
			      allowed to climb along the path
               "manual"     = images that have to climb are manually selected. 
	                      See also CLIMBING_IMAGES card 

first_last_opt LOGICAL ( default = .FALSE. )
               also the first and the last configurations are optimised
               "on the fly" 
	       (these images do not feel the effect of the springs)

damp           REAL ( default = 1.D0 )
               Damping coefficent. Ignored when "opt_scheme" is different 
               from "damped-dyn"

temp_req       REAL ( default = 0.D0 Kelvin )
               temperature used for the langevin dynamics of the string.

ds             REAL ( default = 1.D0 )
               optimisation step length ( Hartree atomic units ).
               If opt_scheme="broyden" ds is used as a guess for the diagonal
               Jacobian matrix.
	              
k_max, k_min   REAL ( default = 0.1D0 Hartree atomic units )
               set them to use a Variable Elastic Constants scheme 
	       elastic constants are in the range [ k_min, k_max ] 
	       this is useful to rise the resolution around the saddle point

path_thr       REAL ( default = 0.05D0 eV / Angstrom )
               the simulation stops when the error ( the norm of the force 
	       orthogonal to the path in eV/A ) is less than path_thr.

use_fourier    LOGICAL ( default = .FALSE. )
               In the string method the path is described by its 
               Fourier components.

use_freezing   LOGICAL ( default = .FALSE. )
               if. TRUE. the images are optimised according to their error:
               only those images with an error larger than half of the largest
               are optimised. The other images are kept forzen.
               
free_energy    LOGICAL ( default = .FALSE. )
               Used in the evaluation of the free-energy profile with
               finite-temperature string dynamics.


===============================================================================
NAMELIST &CELL ( only if calculation = 'vc-relax', 'vc-cp' )

cell_parameters  
               CHARACTER
               default      = restart the simulation with cell parameters read
                              from the restart file or "celldm" if 
                              "restart = 'from_scratch'"
               from_input   = restart the simulation with cell parameters
                              from standard input.
                              ( see the card 'CELL_PARAMETERS' )

cell_dynamics  CHARACTER ( default = 'none' )
               set how cell shold be moved
               none      = cell is kept fixed 
               sd        = steepest descent algorithm is used to optimise the 
                           cell
               damp-pr   = damped dynamics is used to optimise the cell 
                           ( Parrinello-Rahman method ).
               pr        = standard Verlet algorithm is used to propagate 
                           the cell ( Parrinello-Rahman method ).

cell_velocities
               CHARACTER
               zero      = restart setting cell velocitiy to zero
               default   = restart using cell velocity of the previous run

press          REAL ( default = 0.D0 )
               external pressure (in GPa: 1GPa = 10 kbar)

wmass          REAL ( default = 0.D0 )
               effective cell mass in the Parrinello-Rahman Lagrangian 
               (in atomic units) of the order of magnitude of the total atomic 
               mass (sum of the mass of the atoms) within the simulation cell.

cell_temperature  
               CHARACTER ( default = 'not_controlled )
               nose            = control cell temperature using Nose thermostat
                                 see parameters "fnoseh" and "temph".
               rescaling       = control cell temperature via velocities 
                                 rescaling.
               not_controlled  = cell temperature is not controlled.

temph          REAL ( default = 0.D0 )
               value of the cell temperature (in ???) forced
               by the temperature control.
               meaningful only with " cell_temperature /= 'not_controlled' "

fnoseh         REAL ( default = 1.D0 )
               oscillation frequency of the nose thermostat (in terahertz)
               meaningful only with " cell_temperature = 'nose' "

greash         REAL ( default = 1.D0 )
               same as "grease", for cell damped dynamics

cell_dofree    CHARACTER ( default = 'all' )
               select which of the cell parameters should be moved
               all     = all axis and angles are propagated
               volume  = the cell is simply rescaled, without changing the shape
               x       = only the x axis is moved
               y       = only the y axis is moved
               z       = only the z axis is moved
               xy      = only the x and y axis are moved, angles are unchanged
               xz      = only the x and z axis are moved, angles are unchanged
               yz      = only the y and z axis are moved, angles are unchanged
               xyz     = x, y and z axis are moved, angles are unchanged


===============================================================================
NAMELIST &WANNIER ( only if calculation = 'cp-wf' )

wf_efield      LOGICAL ( default = .FALSE. )
               If dynamics will be done in the presence of a field          

wf_switch      LOGICAL ( default = .FALSE. )
               Whether to turn on the field adiabatically (adiabatic switch)
               if true, then nbeg is set to 0.				  

sw_len         INTEGER ( default = 1 )
               No. of iterations over which the field will be turned on     
               to its final value. Starting value is 0.0                     
               If sw_len < 0, then it is set to 1. 			  
	       If you want to just optimize structures on the presence of a 
	       field, then you may set this to 1 and run a regular geometry 
 	       optimization.						  

efx0 efy0 efz0 REAL ( default = 0.D0 )
               Initial values of the field along x, y, and z directions  

efx1 efy1 efz1 REAL ( default = 0.D0 )
               Final values of the field along x, y, and z directions   

wfsd           LOGICAL ( default = .FALSE. )
               Whether to do Steepest-Descent / Conjugate-Gradient          
               localization for the Wannier function calculation            
               if TRUE, then yes, else damped dynamics.                     
               Remember, this is consistent with all the calwf options      
               as well as the tolw (see below).                            
               Not a good idea to Wannier dynamics with this if you are     
               using restart='from_scratch' option, since the spreads       
               converge fast in the beginning and ortho goes bananas.

wfdt           REAL ( default = 5.0D0 )
               The minimum step size to take in the SD/CG direction

maxwfdt        REAL ( default = 0.3D0 )
               The maximum step size to take in the SD/CG direction         
               The code calculates an optimum step size, but that may be    
               either too small (takes forever to converge)  or too large   
               (code goes crazy) . This option keeps the step size between  
               wfdt and maxwfdt. In my experience 0.1 and 0.5 work quite    
               well. (but dont blame me if it doesnt work for you           

nit            INTEGER ( default = 10 )
               Number of iterations to do for Wannier convergence.

nsd            INTEGER ( default = 10 )
               Out of a total of NIT iteratons, NSD will be Steepest-Descent
               and ( nit - nsd ) will be Conjugate-Gradient.

wf_q	       REAL ( default = 1500.0D0 )
               Fictitious mass of the A matrix used for obtaining 	  
	       maximally localized Wannier functions. The unitary
	       transformation matrux U is written as exp(A) where 	  
	       A is a anti-hermitian matrix. The Damped-Dynamics is performed
	       in terms of the A matrix, and then U is computed from A.	  
	       Usually a value between 1500 and 2500 works fine, but should 
	       be tested.

wf_friction    REAL ( default = 0.3D0 )
               Damping coefficient for Damped-Dynamics.			  

nsteps         INTEGER ( default = 20 )
               Number of Damped-Dynamics steps to be performed per CP       
               iteration.

tolw           REAL ( default = 1.D-8 )
               Convergence criterion for localization.

adapt          LOGICAL ( default = .FALSE. )
               Whether to adapt the damping parameter dynamically.

calwf          INTEGER ( default = 3 )
               Wannier Function Options, can be 1,2,3,4,5
                                                                         
               1. Output the Wannier function density, nwf and wffort
                  are used for this option. see below.		          
               2. Output the Overlap matrix O_i,j=<w_i|exp{iGr}|w_j>. O is    
	          written to unit 38. For details on how O is constructed,    
                  see below.						  
               3. Perform nsteps of Wannier dynamics per CP iteration, the    
	          orbitals are now Wannier Functions, not Kohn-Sham orbitals. 
	          This is a Unitary transformation of the occupied subspace   
                  and does not leave the CP Lagrangian invariant. Expectation  
	          values remain the same. So you will **NOT** have a constant 
	          of motion during the run. Don't freak out, its normal.      
               4. This option starts for the KS states and does 1 CP iteration
                  and nsteps of Damped-Dynamics to generate  maximally         
 	          localized wannier functions. Its useful when you have the   
	          converged KS groundstate and want to get to the converged   
	          Wannier function groundstate in 1 CP Iteration.
               5. This option is similar to calwf 1, except that the output is
	          the Wannier function/wafefunction, and not the orbital      
                  density. See nwf below.
									  
nwf            INTEGER ( default = 0 )
               This option is used with calwf 1 and calwf 5. with calwf=1,  
	       it tells the code how many Orbital densities are to be       
 	       output. With calwf=5, set this to 1(i.e calwf=5 only writes  
	       one state during one run. so if you want 10 states, you have 
	       to run the code 10 times). With calwf=1, you can print many  
	       orbital densities in a singel run.
               See also the PLOT_WANNIER card for specifying the states to 
               be printed.

wffort	       INTEGER ( default = 40 )
               This tells the code where to dump the orbital densities. Used
               only with CALWF=1. for e.g. if you want to print 2 orbital   
               densities, set calwf=1, nwf=2 and wffort to an appropriate   
               number (e.g. 40) then the first orbital density will be      
               output to fort.40, the second to fort.41 and so on. Note that
               in the current implementation, the following units are used  
               21,22,24,25,26,27,28,38,39,77,78 and whatever you define as  
               ndr and ndw. so use number other than these.                 

writev         LOGICAL ( default = .FALSE. )
               Output the charge density (g-space) and the list of g-vectors
               This is useful if you want to reconstruct the electrostatic  
               potential using the poisson equation. If .TRUE. then the     
	       code will output the g-space charge density and the list     
               if G-vectors, and STOP.                                      
               Charge density is written to : CH_DEN_G_PARA.ispin (1 or 2   
               depending on the number of spin types) or CH_DEN_G_SERL.ispin
               depending on if the code is being run in parallel or serial  
               G-vectors are written to G_PARA or G_SERL.                   
                                                                         
Nota Bene 1:   For calwf = 5, wffort is not used. The 			  
	       Wannier/Wave(function) coefficients are written to unit 22 
	       and the corresponding g-vectors (basis vectors) are        
 	       written to unit 21. This option gives the g-vecs and       
	       their coeffs. in reciprocal space, and the coeffs. are     
               complex. You will have to convert them to real space       
               if you want to plot them for visualization. calwf=1 gives  
	       the orbital densities in real space, and this is usually   
               good enough for visualization.
									  
Output files used by Wannier Function options are the following

      fort.21: Used only when calwf=5, contains the full list of g-vecs. 
      fort.22: Used Only when calwf=5, contains the coeffs. corresponding
               to the g-vectors in fort.21				  
      fort.24: Used with calwf=3,contains the average spread 	          
      fort.25: Used with calwf=3, contains the individual Wannier        
               Function Spread of each state 		                  
      fort.26: Used with calwf=3, contains the wannier centers along a   
               trajectory.
      fort.27: Used with calwf=3 and 4,  contains some general runtime   
               information from ddyn, the subroutine that actually       
               does the localization of the orbitals.                    
      fort.28: Used only if efield=.TRUE. , contains the polarization    
               contribution to the total energy.			  
									  
Also, The center of mass is fixed during the Molecular Dynamics.        
									  
BEWARE : THIS WILL ONLY WORK IF THE NUMBER OF PROCESSORS IS LESS THAN OR
         EQUAL TO THE NUMBER OF STATES.                                 
                                                                         

===============================================================================
CARDS: { } = optional

-------------------------------------------------------------------------------

ATOMIC_SPECIES

Syntax:

ATOMIC_SPECIES
 X(1)     Mass_X(1)     PseudoPot_X(ntyp)
 X(2)     Mass_X(2)     PseudoPot_X(ntyp)
 ...
 X(ntyp)  Mass_X(ntyp)  PseudoPot_X(ntyp)

Description:
 X           CHARACTER : label of the atom
 Mass_X      REAL      : mass of the atomic species [amu: mass of C = 12]
                         not used if calculation='scf', 'nscf', 'phonon'
 PseudoPot_X CHARACTER:  file containing PP for this species

 The pseudopotential file is assumed to be in the new UPF format.
 If it doesn't work, the pseudopotential format is determined by
 the file name:
     *.vdb or *.van     Vanderbilt US pseudopotential code
     *.RRKJ3            Andrea Dal Corso's code (old format)
     none of the above  old PWscf norm-conserving format
 
-------------------------------------------------------------------------------

ATOMIC_POSITIONS { alat | bohr | crystal | angstrom }

   alat    : atomic positions are in units of alat (default)
   bohr    : atomic positions are in a.u.
   crystal : atomic positions are in crystal coordinates (see below)
   angstrom: atomic positions are in A

if calculation = 'neb' .OR. 'smd' there are many cards like the following
  
  identifier
  X  x y z   {if_pos(1) if_pos(2) if_pos(3)}
  
  One for the first image ( identifier="first_image" must be followed by "nat" 
  position cards ) and one for the last image ( identifier="last_image" must 
  be followed by "nat" position cards )
  There is also the possibility of specifying intermediate images; in this case
  their coordinates must be set between the first_image and the last_image.
  ( identifier="intermediate_image" must be followed by "nat" position cards ). 
  
  Image configurations must be specified in the following order:
  
  first_image                                           <= mandatory
   X 0.0  0.0  0.0  { if_pos(1) if_pos(2) if_pos(3) }
   Y 0.5  0.0  0.0  { if_pos(1) if_pos(2) if_pos(3) }
   Z 0.0  0.2  0.2  { if_pos(1) if_pos(2) if_pos(3) }
  intermediate_image 1                                  <= optional
   X 0.0  0.0  0.0
   Y 0.9  0.0  0.0
   Z 0.0  0.2  0.2
  intermediate_image ...                                <= optional
   X 0.0  0.0  0.0
   Y 0.9  0.0  0.0
   Z 0.0  0.2  0.2
  last_image                                            <= mandatory
   X 0.0  0.0  0.0
   Y 0.7  0.0  0.0
   Z 0.0  0.5  0.2  
   
  IMPORTANT: the total number of configurations specified in the input file 
             must be less than num_of_images (as specified in &IONS).
             The initial path is obtained interpolatig between the specified
             configurations so that all images are equispaced (only the
             coordinates of the first and last images are not changed). 

otherwise

  There are "nat" cards like the following
  
  X  x y z   {if_pos(1) if_pos(2) if_pos(3)}

where :

  identifier  String: a string that identifies image coordinates.
  X           Character: label of the atom as specified in ATOMIC_SPECIES
  x, y, z     Real: atomic positions 
  if_pos:     Integer: component i of the force for this atom is multiplied
              by if_pos(i), which must be 0 or 1. Used to keep selected atoms
              and/or selected components fixed in neb, smd, MD dynamics or 
              structural optimization run

-------------------------------------------------------------------------------

ATOMIC_VELOCITIES

  optional card :  reads velocities (in atomic units) from standard input
  
  Syntax:
  
   ATOMIC_VELOCITIES
     label(1)  Vx(1) Vy(1) Vz(1)
     ....
     label(n)  Vx(n) Vy(n) Vz(n)

  Where:
  
     label                     CHARACTER(LEN=4) atomic label
     Vx(:), Vy(:) and Vz(:)    REAL             x, y and z components of the 
                                                ionic velocities

  IMPORTANT:  when starting with ion_velocities="from_input" is convenient
              to perform few steps (~5-10) with a smaller time step (0.5 a.u.)

-------------------------------------------------------------------------------

CELL_PARAMETERS

  optional card, needed only if ibrav = 0 is specified

  Syntax:
  
    CELL_PARAMETERS
      a(1,1) a(2,1) a(3,1)
      a(1,2) a(2,2) a(3,2)
      a(1,3) a(2,3) a(3,3)

  a(:,1) = crystal axis 1    alat units   if celldm(1) was specified
      2                 2    a.u.         if celldm(1)=0
      3                 3

-------------------------------------------------------------------------------

CLIMBING_IMAGES

  optional card, needed only if calculation = 'neb' and CI_scheme = 'manual'
  
  Syntax:
  
   CLIMBING_IMAGES
     index1, index2, ..., indexN
  
  where index1, index2, ..., indexN are the indices of the images to which 
  apply the Climbing Image procedure. If more than an image is specified they
  must be separated by a comma
       
-------------------------------------------------------------------------------

CONSTRAINTS

   Ionic Constraints

 Syntax:

    CONSTRAINTS
      nconstr   constr_tol
      constr_type(.)  constr(1,.)  constr(2,.) ... { constr_target(.) }

 Where:

      nconstr                      INTEGER, number of constraints

      constr_tol                   REAL,    tolerance for keeping the 
                                            constraints satisfied

      constr_type(.)               INTEGER, type of constrain :
                                         0: for fixed coordination:
                                            four indexes must be specified
                                         1: for fixed distances: 
                                            two atom indexes must be specified 
                                         2: for fixed planar angles: 
                                            three atom indexes must be specified

      constr(1,.) constr(2,.) ...  REAL,    these variables have different 
                                            meanings for different constraint
                                            types:
                                         0: constr(1) is the atom index of the
                                            atom with constrained coordination
                                            constr(2) is the cut-off radius for
                                            estimating the coordination
                                            constr(3) is a smoothing parameter
                                            constr(4) is the index of the atomic
                                            type involved in the coordination
                                       1,2: atoms indices object of the 
                                            constraint, as they appear in 
                                            the 'POSITION' CARD
                                        
      constr_target                 REAL,   target for the constrain ( planar 
                                            angles are specified in degrees ).
                                            This variable is optional.

-------------------------------------------------------------------------------

PLOT_WANNIER

  Indices of the states that have to be printed (only for calf=1 and calf=5).

 Syntax:

    PLOT_WANNIER
      iwf(1)  iwf(2) ...

 Where:


      iwf(:)   INTEGER
               These are the indices of the state that you want to output.  
	       Also used with calwf = 1 and 5. If calwf = 1, then you need 
               nwf indices here (each in a new line). If CALWF=5, then just 
               one index in needed.     					  


-------------------------------------------------------------------------------

  ibrav is the structure index:

    ibrav        structure                   celldm(2)-celldm(6)

      0          "free", see above                 not used
      1          cubic P (sc)                      not used
      2          cubic F (fcc)                     not used   
      3          cubic I (bcc)                     not used
      4          Hexagonal and Trigonal P        celldm(3)=c/a
      5          Trigonal R                      celldm(4)=cos(aalpha)
      6          Tetragonal P (st)               celldm(3)=c/a
      7          Tetragonal I (bct)              celldm(3)=c/a
      8          Orthorhombic P                  celldm(2)=b/a,celldm(3)=c/a
      9          Orthorhombic base-centered(bco) celldm(2)=b/a,celldm(3)=c/a
     10          Orthorhombic face-centered      celldm(2)=b/a,celldm(3)=c/a
     11          Orthorhombic body-centered      celldm(2)=b/a,celldm(3)=c/a
     12          Monoclinic P                    celldm(2)=b/a,celldm(3)=c/a,
                                                 celldm(4)=cos(ab)
     13          Monoclinic base-centered        celldm(2)=b/a,celldm(3)=c/a,
                                                 celldm(4)=cos(ab)
     14          Triclinic P                     celldm(2)= b/a,
                                                 celldm(3)= c/a,
                                                 celldm(4)= cos(bc),
                                                 celldm(5)= cos(ac),
                                                 celldm(6)= cos(ab)

  The special axis is the z-axis, one basal-plane vector is along x, 
  and the other basal-plane vector is at angle beta for monoclinic 
  (beta is not actually used), at 120 degrees for trigonal and hexagonal(p)
  groups, and at 90 degrees for remaining groups, excepted fcc, bcc, 
  tetragonal(i), for which the crystallographic vectors are as follows:

  fcc bravais lattice.
  ====================

  a1=(a/2)(-1,0,1), a2=(a/2)(0,1,1), a3=(a/2)(-1,1,0).

  bcc bravais lattice.
  ====================

  a1=(a/2)(1,1,1), a2=(a/2)(-1,1,1), a3=(a/2)(-1,-1,1).

  tetragonal (i) bravais lattices.
  ================================
  a1=(a/2,a/2,c/2), a2=(a/2,-a/2,c/2), a3=(-a/2,-a/2,c/2).

  trigonal(r) groups.
  ===================

  for these groups, the z-axis is chosen as the 3-fold axis, but the
  crystallographic vectors form a three-fold star around the z-axis,
  and the primitive cell is a simple rhombohedron. if c is the cosine
  of the angle between any pair of crystallographic vectors, and if
  tx=sqrt((1-c)/2), ty=sqrt((1-c)/6), tz=sqrt((1+2c)/3), the crystal-
  lographic vectors are:

        a1=a(0,2ty,tz),  a2=a(tx,-ty,tz),  a3=a(-tx,-ty,tz).

  bco base centered orthorhombic
  =============================
  a1=(a/2,b/2,0), a2=(-a/2,b/2,0), a3=(0,0,c)
-------------------------------------------------------------------------------
