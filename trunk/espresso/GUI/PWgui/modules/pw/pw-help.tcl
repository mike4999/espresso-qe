# ------------------------------------------------------------------------
#
# This File is the HELP file for the PWSCF.
#
# ------------------------------------------------------------------------


# =============================================================================
# NAMELIST &CONTROL
# =============================================================================

help calculation -vartype character -helpfmt html -helptext {
    A string describing the task to be performed.
    <p>
    <b>Allowed values:</b> 'scf', 'nscf', 'phonon', 'relax', 
                           'md', 'vc-relax', 'vc-md', 'neb', 
                           'smd' (vc = variable-cell). 
    <b> ( default = 'scf' )
}

help title -vartype character -helpfmt txt2html -helptext {
             reprinted on output. 
<p> ( default = ' ' )
}

help verbosity    -vartype character -helpfmt txt2html -helptext { 
             Allowed values: 'high' | 'default' | 'low' | 'minimal'
}

help restart_mode -vartype character -helpfmt txt2html -helptext { 
             'from_scratch'  : from scratch 
	                       NEB and SMD only: the starting path is obtained
                               with a linear interpolation between the images
                               specified in the ATOMIC_POSITIONS card.
			       Note that in the linear interpolation
                               periodic boundary conditions ARE NON USED.
             'restart'       : from previous interrupted run
<p> ( default = 'from_scratch' )
}

help wf_collect -vartype logical -helpfmt txt2html -helptext { 
               This flag controls the way in which wave functions are stored
               to disk :
               .TRUE.  collect wave functions from all processors and store 
                       them in a single restart file ( outdir/prefix.save )
               .FALSE. do not collect wave function and leave them in temporary
                       local files (one per processor)
<p> ( default = .FALSE. )


}

help nstep        -vartype integer -helpfmt txt2html -helptext {                          
             number of ionic+electronic steps
<p>
             default:  1 if calculation = 'scf', 'nscf'
                       0 if calculation = 'neb', 'smd'
                      50 for the other cases
}

help iprint       -vartype integer -helpfmt txt2html -helptext { 
             band energies are written every iprint iterations
<p> ( default = write only at convergence )
}

help tstress      -vartype logical -helpfmt txt2html -helptext { 
             calculate stress. Set to .TRUE. if calculation = 'vc-md'
}

help tprnfor      -vartype logical -helpfmt txt2html -helptext { 
             print forces. Set to .TRUE. if calculation = 'relax', 'md', 'vc-md'
}
            
help dt           -vartype real -helpfmt txt2html -helptext { 
             time step for molecular dynamics, in Rydberg atomic units
             (1 a.u.=4.8378 * 10^-17 s : beware, CP and FPMD codes use
              Hartree atomic units, half that much!!!)
}

help outdir       -vartype character -helpfmt txt2html -helptext { 
             input, temporary, output files are found in this directory
<p> ( default = current directory, i.e. './' )
}

help wfcdir       -vartype character -helpfmt txt2html -helptext { 
             this directory specifies where to store files generated by
             each processor (*.wfc{N}, *.igk{N}, etc.). The idea here is
             to be able to separately store the largest files, while 
             the files necessary for restarting still go into 'outdir'
             (for now only works for stand alone PW )

<p> ( default = same as <em>outdir</em> )
}
            
help prefix       -vartype character -helpfmt txt2html -helptext { 
             prepended to input/output filenames: 
             prefix.wfc, prefix.rho, etc. 
<p> ( default = 'pwscf' )
}

help max_seconds  -vartype integer -helpfmt txt2html -helptext { 
             jobs stops after max_seconds CPU time
}

help etot_conv_thr     -vartype real -helpfmt txt2html -helptext { 
             convergence threshold on total energy (a.u)
             for ionic minimization. 
             See also <i>forc_conv_thr</i> - both criteria must be satisfied
<p> ( default = 1.D-4 )
}

help forc_conv_thr     -vartype real -helpfmt txt2html -helptext { 
             convergence threshold on forces (a.u)
             for ionic minimization. 
             Ssee also <i>etot_conv_thr</i> - both criteria must be satisfied
<p> ( default = 1.D-3 )
}

help disk_io      -vartype character -helpfmt txt2html -helptext { 
             'high', 'default', 'low', 'minimal'
}

help pseudo_dir   -vartype character -helpfmt txt2html -helptext {
             directory containing pseudopotential files
<p> ( default = '$HOME/pw/pseudo/' )
}
	
help tefield      -vartype logical -helpfmt txt2html -helptext {  
             If .TRUE. a sawlike potential is added to the 
               bare ionic potential.  
<p> ( default = .FALSE. )
}	

help lelfield      -vartype logical -helpfmt txt2html -helptext {  
               If .TRUE. a homogeneous finite electric field
               described through the modern theory of the polarization
               is applied. 
<p> ( default = .FALSE. )
}	


help lberry   -vartype logical -helpfmt txt2html -helptext {  
               If .TRUE. perform a Berry phase calculation
               See the header of PW/bp_c_phase.f90 for documentation
<p> ( default = .FALSE. )
}

help gdir  -vartype integer -helpfmt txt2html -helptext {          
               For Berry phase calculation: direction of the k-point
               strings in reciprocal space. Allowed values: 1, 2, 3 
               1=first, 2=second, 3=third reciprocal lattice vector
}

help nppstr  -vartype integerl -helpfmt txt2html -helptext {        
               For Berry phase calculation: number of k-points to be 
               calculated along each symmetry-reduced string
}

help nberrycyc  -vartype integerl -helpfmt txt2html -helptext {        
               In the case of a finite electric field  (lelfield==.true.)
               it defines the number of iterations for converging the
               wavefunctions in the electric field Hamiltonian, for each
               external iteration on the charge density  
<p> ( default = 1 )
}


# =============================================================================
# NAMELIST &SYSTEM
# =============================================================================

set ibravCelldm {
The specification of the <b>celldm</b> dimension depends on the value
of <b>ibrav</b> variable.

<pre>
     ibrav        structure                       celldm(2)-celldm(6)

       0          "free", see cards 2bis above      not used
       1          cubic P (sc)                      not used
       2          cubic F (fcc)                     not used   
       3          cubic I (bcc)                     not used

       4          Hexagonal and Trigonal P        celldm(3)=c/a
       5          Trigonal R                      celldm(4)=cos(aalpha)
       6          Tetragonal P (st)               celldm(3)=c/a
       7          Tetragonal I (bct)              celldm(3)=c/a
       8          Orthorhombic P                  celldm(2)=b/a,
                                                  celldm(3)=c/a

       9          Orthorhombic base-centered(bco) celldm(2)=b/a,
	                                          celldm(3)=c/a

      10          Orthorhombic face-centered      celldm(2)=b/a,
	                                          celldm(3)=c/a

      11          Orthorhombic body-centered      celldm(2)=b/a,
                                                  celldm(3)=c/a

      12          Monoclinic P                    celldm(2)=b/a,
                                                  celldm(3)=c/a,
                                                  celldm(4)=cos(ab)

      13          Monoclinic base-centered        celldm(2)=b/a,
                                                  celldm(3)=c/a,
                                                  celldm(4)=cos(ab)

      14          Triclinic P                     celldm(2)= b/a,
                                                  celldm(3)= c/a,
                                                  celldm(4)= cos(bc),
                                                  celldm(5)= cos(ac),
                                                  celldm(6)= cos(ab)
</pre>

   The special axis is the z-axis, one basal-plane vector is along x, 
   and the other basal-plane vector is at angle beta for monoclinic 
   (beta is not actually used), at 120 degrees for trigonal and hexagonal(p)
   groups, and at 90 degrees for remaining groups, excepted fcc, bcc, 
   tetragonal(i), for which the crystallographic vectors are as follows:

<h2>FCC bravais lattice:</h2>

   a1=(a/2)(-1,0,1), a2=(a/2)(0,1,1), a3=(a/2)(-1,1,0).

<h2>BCC bravais lattice:</h2>

   a1=(a/2)(1,1,1), a2=(a/2)(-1,1,1), a3=(a/2)(-1,-1,1).

<h2>TETRAGONAL (I) bravais lattices:</h2>

   a1=(a/2,a/2,c/2), a2=(a/2,-a/2,c/2), a3=(-a/2,-a/2,c/2).

<h2>TRIGONAL(R) groups:</h2>

   For these groups, the z-axis is chosen as the 3-fold axis, but the
   crystallographic vectors form a three-fold star around the z-axis,
   and the primitive cell is a simple rhombohedron. if c is the cosine
   of the angle between any pair of crystallographic vectors, and if
   tx=sqrt((1-c)/2), ty=sqrt((1-c)/6), tz=sqrt((1+2c)/3), the crystal-
   lographic vectors are:

<p>
         a1=a(0,2ty,tz),  a2=a(tx,-ty,tz),  a3=a(-tx,-ty,tz).

<h2>BCO base centered orthorombic:</h2>

   a1=(a/2,b/2,0), a2=(-a/2,b/2,0), a3=(0,0,c)
}

help ibrav  -vartype integer -helpfmt html -helptext $ibravCelldm
help celldm -vartype real    -helpfmt html -helptext $ibravCelldm

foreach var {A B C cosAB cosAC cosBC} {
    help $var -vartype real -helpfmt txt2html -helptext { 
	     Traditional crystallographic constants (A,B,C in ANGSTROM)
             specify either these or celldm but not both.
    }
}
 
help nat          -vartype integer -helpfmt txt2html -helptext { 
             number of atoms in the unit cell - must be specified
}


help ntyp         -vartype integer -helpfmt txt2html -helptext { 
             number of types of atoms in the unit cell - must be specified
}

help nbnd -vartype integer -helpfmt html -helptext {
	Number of electronic states (bands) to be calculated.
	<p>
	<b>Default:</b>
        <ul>
        <li>for an insulator, nbnd = "number of valence bands"
                      (nbnd=nelec/2, see below for nelec)</li>
        <li>for a metal, 20% more (minimum 4 more) for a metal</li>
	</ul>
        Note that in spin-polarized calculations the number of
        k-point, not the number of bands per k-point, is doubled
}

help nelec        -vartype real -helpfmt txt2html -helptext { 
             number of electron in the unit cell
             (may be noninteger if you wish)
             Default: the same as ionic charge (neutral cell)
             A compensating jellium background is inserted
             to remove divergencies if the cell is not neutral
}


help tot_charge -vartype real -helpfmt txt2html -helptext { 
               Total system charge. Used only if nelec is unspecified,
               otherwise it is ignored.
<p> ( default = 0.0 )
}




help ecutwfc      -vartype real -helpfmt txt2html -helptext { 
             kinetic energy cutoff (Ry) for wavefunctions
             (must be specified)
}

help ecutrho      -vartype real -helpfmt txt2html -helptext { 
             kinetic energy cutoff (Ry) for charge density and potential
             Default: 4*ecutwfc . May be larger (for ultrasoft PP)
             or somewhat smaller (but not much smaller) than this.
}

foreach var {nr1 nr2 nr3} {
    help $var  -vartype integer -helpfmt txt2html -helptext { 
             three-dimensional FFT mesh (hard grid) for charge
             density (and scf potential). If not specified
             the grid is calculated based on the cutoff for
             charge density (see also "ecutrho")
    }
}

foreach var {nr1s nr2s nr3s} {
    help $var  -vartype integer -helpfmt txt2html -helptext {
             three-dimensional mesh for wavefunction FFT
             and for the smooth part of charge density
             (smooth grid). Coincides with nr1,nr2,nr3 if
             ecutrho=4*ecutwfc (default)
    }
}

help nosym        -vartype logical -helpfmt txt2html -helptext { 
             if (.TRUE.) symmetry is not used. Note that a k-point grid
             provided in input is used "as is"; an automatically generated
             k-point grid will contain only points in the irreducible BZ 
             of the lattice.  Use with care in low-symmetry large cells 
             if you cannot afford a k-point grid with the correct symmetry.
<p> ( default = .FALSE. )
}

help starting_magnetization -vartype real -helpfmt txt2html -helptext { 
               Starting spin polarization (values between -1 and 1)
               on atomic type 'i' in a spin-polarized calculation. 
               Breaks the symmetry and provides a starting point for 
               self-consistency. The default value is zero, BUT a value 
               MUST be specified for AT LEAST one atomic type in spin 
               polarized calculations. Note that if start from zero 
               initial magnetization, you will get zero final magnetization
               in any case. If you desire to start from an antiferromagnetic
               state, you may need to define two different atomic species
               corresponding to sublattices of the same atomic type.
               If you fix the magnetization with "nelup/neldw" or with
               "multiplicity" or with "tot_magnetization", you should
               not specify starting_magnetization.
}

help multiplicity -vartype  integer -helpfmt txt2html -helptext { 
               Spin multiplicity (2s+1). 1 is singlet, 2 for doublet etc.
               Note that this fixes the final value of the magnetization.
               if unspecified or a non-zero value is specified in nelup/neldw
               then multiplicity variable is ignored.
               Do not specify both multiplicity and tot_magnetization.
<p>  ( default = 0 [unspecified] )
}

help tot_magnetization -vartype integer -helpfmt txt2html -helptext {
               Total magnetization: majority spin - minority spin (nelup - neldw).
               If unspecified or a non-zero value is specified in nelup/neldw
               then tot_magnetization variable is ignored.
               Do not specify both multiplicity and tot_magnetization.
               YES, there is redundancy! nelup/neldw are enough to specify
               the spin state. However these variables are not very convenient
               and will be eliminated from the input in future versions.
               It is recommended to use either 'multiplicity' or equivalently
               'tot_magnetization' to specify the spin state.
 ( default = -1 [unspecified] )
}

help noncolin -vartype logical -helpfmt txt2html -helptext {
    if .true. the program will perform a noncollinear calculation.
<p> ( default = .false. )

}

help angle1  -vartype real -helpfmt txt2html -helptext {
             for each atomic type it defines the  angle, expressed in
             degrees, between the initial magnetization and the z-axis.
             I.e. the azimutal (Theta) angle in polar coordinates
}

help angle2  -vartype real -helpfmt txt2html -helptext {
             for each atomic type it defines the  angle, expressed in
             degrees, between the projection of the initial magnetization 
             on x-y plane and the x-axis. 
             I.e. the Phi angle in polar coordinates.
}

help constrained_magnetization -vartype character -helpfmt txt2html -helptext {
               Used to perform constrained calculations in magnetic systems
               Currently available choices:

               'none' : no constraint

               'total': total magnetization is constrained
                        If nspin=4 (noncolin=.True.) constraint is imposed by
                        adding a penalty functional to the total energy: 
     - LAMBDA * SUM_{i} ( magnetization(i) - fixed_magnetization(i) )**2
                        where the sum over i runs over the three components of
                        the magnetization. Lambda is a real number (see below).                         
                        If nspin=2 constraint is imposed by defining two Fermi
                        energies for spin up and down.
                        Only fixed_magnetization(3) can be defined in this case.

               'atomic': atomic magnetization are constrained to the defined 
                        starting magnetization adding a penalty
     - LAMBDA * SUM_{i,itype} ( magnetic_moment(i,itype) - mcons(i,itype) )**2
                        where i runs over the components (1-3) and itype over 
                        the types (1-ntype).  
                        mcons(:,:) array is defined from starting_magnetization,
                        angle1 and angle2 variables. lambda is a real number

               'atomic direction': not all the components of the atomic 
                        magnetic moment are constrained but only the cosinus 
                        of angle1, and the penalty functional is:
     - LAMBDA * SUM_{itype} ( mag_mom(3,itype)/mag_mom_tot - cos(angle1(ityp) )**2

<p> ( default = 'none' ) 
}

help fixed_magnetization -vartype real -helpfmt txt2html -helptext {
               value of the total magnetization to be mantained fixed when 
               constrained_magnetization='total'
<p> ( default = 0.0 )
}

help B_field -vartype real -helpfmt txt2html -helptext {
               A fixed magnetic field defined by the vector B_field is added 
               to the exchange and correlation magnetic field. 
               The three components of the magnetic field are given in Ry.
               Only B_field(3) can be used if nspin=2.

               In all calculations with a finite magnetic field,
               we print the total energy WITHOUT the B dot M term.
               In the calculations with the penalty functional we write
               only the total energy, NOT the penalty functional.

<p> ( default = 0.0 )
}

help lambda -vartype real -helpfmt txt2html -helptext {
               parameter used for constrained_magnetization calculations
               NB: LAMBDA is reduced in the first iterations and is increased 
                   slowly up to the input value.
}

help report -vartype integer -helpfmt txt2html -helptext {
               It's the number of iterations after which the program
               write all the atomic magnetic moments.
}

help lspinorb -vartype logical -helpfmt txt2html -helptext {
               if .true. the noncollinear code can use a pseudopotential with
               spin-orbit.
}


help occupations  -vartype character -helpfmt txt2html -helptext { 
             'smearing':    gaussian smearing for metals
                            requires a value for degauss
             'tetrahedra' : for metals and DOS calculation
                            (see PRB49, 16223 (1994))
                            Requires uniform grid of k-points,
                            automatically generated (see below)
             'fixed' :      for insulators with a gap
             'from_input':  The occupation are read from input file.
                            Presently works only with one k-point 
                            (LSDA allowed). 
}

help degauss      -vartype real -helpfmt txt2html -helptext { 
             value of the gaussian spreading (Ry) for brillouin-zone
             integration in metals. 
<p> ( default = 0.D0 )
}


help smearing     -vartype character -helpfmt txt2html -helptext { 
             'gaussian', 'gauss':  
                  ordinary Gaussian spreading 
             'methfessel-paxton', 'm-p', 'mp':
                  Methfessel-Paxton first-order spreading
                  (see PRB 40, 3616 (1989)).
             'marzari-vanderbilt', 'cold', 'm-v', 'mv':
                  Marzari-Vanderbilt cold smearing
                  (see PRL 82, 3296 (1999))
             'fermi-dirac', 'f-d', 'fd':
                  smearing with Fermi-Dirac function
<p> ( default = 'gaussian' )
}

foreach var {nelup neldw} {
    help $var      -vartype real -helpfmt txt2html -helptext { 
             Number of spin-up and spin-down electrons, respectively.
             The sum must yield nelec !!! NOT YET USED !!!
    }
}

help nspin        -vartype integer -helpfmt txt2html -helptext { 
             nspin=1 :  non-polarized calculation 
             nspin=2 : spin-polarized calculation
             nspin=4 : non-collinear spin-polarized calculation
<p> ( default = 1 )
}

help ecfixed      -vartype real -helpfmt txt2html -helptext { 
             parameters for modified functional to be used in
             variable-cell molecular dynamics (or in stress calculation)
 	     Deafult:      40.0
}
help qcutz        -vartype real -helpfmt txt2html -helptext {
             parameters for modified functional to be used in
             variable-cell molecular dynamics (or in stress calculation)
             Deafult:       0.0
}
help q2sigma      -vartype real -helpfmt txt2html -helptext {
             parameters for modified functional to be used in
             variable-cell molecular dynamics (or in stress calculation)
             Deafult:       0.1
}

help xc_type      -vartype character -helpfmt txt2html -helptext { 
             Exchange-correlation functional.
             Presently unused: XC functional is read from PP files
}

set _hubbard {
             parameters for LDA+U calculations
             If lda_plus_u = .TRUE. you must specify, for species I,
             the parameters U and (optionally) alpha of the Hubbard 
             model (both in eV). See:
             Anisimov, Zaanen, and Andersen, PRB 44, 943 (1991);
             Anisimov et al., PRB 48, 16929 (1993);
             Liechtenstein, Anisimov, and Zaanen, PRB 52, R5467 (1994); 
             Cococcioni and de Gironcoli (to be published)
}
help lda_plus_u     -vartype logical -helpfmt txt2html -helptext "$_hubbard\n          (default: .false.)"
help Hubbard_U      -vartype real -helpfmt txt2html -helptext "$_hubbard\n             (default: 0.0 for all species)"
help Hubbard_alpha  -vartype real -helpfmt txt2html -helptext "$_hubbard\n             (default: 0.0 for all species)"
help U_projection_type -vartype character -helpfmt txt2html -helptext {
    Only active when lda_plus_U is .true., specifies the type
    of projector on localized orbital to be used in the LDA+U
    scheme.

    Currently available choices:
    'atomic': use atomic wfc's (as they are) to build the projector 
    'ortho-atomic': use Lowdin orthogonalized atomic wfc's
    'file': use the information from file "prefix".atwfc that must
        have been generated previously, for instance by pmw.x
        (see PP/poormanwannier.f90 for details)

    NB: forces and stress currently implemented only for the
    'atomic' choice.
}

help edir         -vartype integer -helpfmt txt2html -helptext { 
             1, 2 or 3. Used only if tefield is .TRUE. The direction of the
             electric field is parallel to the bg(.,edir) reciprocal 
             lattice vector (So the potential is constant in planes 
             defined by the mesh points).
}

help emaxpos      -vartype real -helpfmt txt2html -helptext { 
             Position of the maximum of the sawlike potential within the 
             unit cell (0<emaxpos<1). 
<p> ( default = 0.5D0 )
}

help eopreg       -vartype real -helpfmt txt2html -helptext { 
             Part of the unit cell where the sawlike potential decreases.
             ( 0 < eopreg < 1 ). 
<p> ( default = 0.1D0 )
}

help eamp         -vartype real -helpfmt txt2html -helptext { 
             Amplitude of the electric field (in a.u.) ( 1 a.u. = 51.44 10^11 V/m )
<p> ( default = 0.001 a.u. )
}



# =============================================================================
# NAMELIST &ELECTRONS
# =============================================================================

help electron_maxstep  -vartype integer -helpfmt txt2html -helptext { 
             maximum number of iterations in a scf step
<p> ( default = 50)
}

help conv_thr     -vartype real -helpfmt txt2html -helptext { 
             Convergence threshold for selfconsistency: 
             estimated energy error < conv_thr 
<p> ( default = 1.D-6 )
}

help mixing_mode  -vartype character -helpfmt txt2html -helptext { 
             'plain'    : charge density Broyden mixing 
             'TF'       : as above, with simple Thomas-Fermi screening
                          (for highly homogeneous systems)
             'local-TF' : as above, with local-density-dependent TF screening
                          (for highly inhomogeneous systems)
             'potential': (obsolete) potential mixing
<p> ( default = 'plain' )
}

help mixing_beta  -vartype real -helpfmt txt2html -helptext { 
             mixing factor for self-consistency 
<p> ( default = 0.7D0 )
}

help mixing_ndim  -vartype integer -helpfmt txt2html -helptext { 
             number of iterations used in mixing scheme 
<p> ( default = 8 )
}

help mixing_fixed_ns   -vartype integer -helpfmt txt2html -helptext { 
             For LDA+U : number of iterations with fixed ns (ns is the
             atomic density appearing in the Hubbard term) 
<p> ( default = 0 )
}

help diagonalization   -vartype character -helpfmt txt2html -helptext { 
            'david': Davidson iterative diagonalization with overlap matrix
            'diis' : DIIS-like diagonalization
            'cg'   : conjugate-gradient-like band-by-band diagonalization
<p> ( default = 'david' )
}

help diago_thr_init -vartype real -helpfmt txt2html -helptext {
               Convergence threshold for the firts iterative diagonalization.
               The threshold (ethr) is automatically updated along the
               self consistency loop.
<p> ( default = 1.D-2 )
}

help diago_full_acc -vartype logical -helpfmt txt2html -helptext {
               If .TRUE. all the empty states are diagonalized at the same level
               of accuracy of the occupied ones. Otherwise the empty states are
               diagonalized using a larger threshold (this should not affect
               total energy, forces, and other ground-state properties).
<p> ( default = .FALSE. )
}

help diago_cg_maxiter  -vartype integer -helpfmt txt2html -helptext { 
             For conjugate gradient diagonalization:
             max number of iterations
}

help diago_david_ndim  -vartype integer -helpfmt txt2html -helptext { 
             For Davidson diagonalization: dimension of workspace 
             (number of wavefunction packets, at least 2 needed). 
             A larger value may yield a faster algorithm but uses 
             more memory.
<p> ( default = 4 )
}

#help diago_diis_ndim   -vartype integer -helpfmt txt2html -helptext { 
#             For DIIS: dimension of the reduced space.
#<p> ( default = 3 )
#}


help startingpot  -vartype character -helpfmt txt2html -helptext { 
             'atomic': starting potential from atomic charge superposition
                       (default for scf,*relax,*md)
             'file'  : start from existing "prefix".pot file
                       (default and only possibility for nscf and phonon)
}

help startingwfc  -vartype character -helpfmt txt2html -helptext { 
             'atomic': start from superposition of atomic orbitals 
                       If not enough atomic orbitals are available,
                       fill with random numbers the remaining wfcs
             'random': start from random wfcs
             'file'  : start from a wavefunction file
<p> ( default = 'atomic' )
}


help efield -vartype real -helpfmt txt2html -helptext { 
               For finite electric field calculations (lelfield == .true.), 
               it defines the intensity of the field in a.u.

<p> ( default = 0.0 )
}

# =============================================================================
# NAMELIST &IONS
# =============================================================================

help ion_dynamics      -vartype character -helpfmt txt2html -helptext { 
               specify the type of ionic dynamics. 
               For different type of calculation different possibilities are 
               allowed and different default values apply:
               
	       CASE ( calculation = 'relax' )
                 'bfgs' :   (default)   a new BFGS quasi-newton algorithm, based
                                        on the trust radius procedure, is used 
                                        for structural relaxation.
		 'damp' :               use damped dynamics (quick-min Verlet) 
                                        for structural relaxation
                 'constrained-damp' :   use damped dynamics (quick-min Verlet) 
                                        for structural relaxation with the 
                                        constraints specified in the 
                                        CONSTRAINTS CARD
               CASE ( calculation = 'md' )
                 'verlet' : (default)   use Verlet algorithm to integrate 
                                        Newton's equation of motion
                 'constrained-verlet' : use Verlet algorithm to do molecular 
                                        dynamics with the constraint
                                        specified in the CONSTRAINTS CARD 
               CASE ( calculation = 'vc-relax' )
                 'damp' :   (default)   use damped (Beeman) dynamics for 
		                        structural relaxation
               CASE ( calculation = 'vc-md' )
                 'beeman' : (default)   use Beeman algorithm to integrate 
                                        Newton's equation
}

help phase_space   -vartype character -helpfmt txt2html -helptext { 
               'full' :           the full phase-space is used for the ionic 
                                  dynamics.
               'coarse-grained' : a coarse-grained phase-space, defined by a set
                                  of constraints, is used for the ionic dynamics
                                  (used for meta-dynamics).
}

help ion_temperature   -vartype character -helpfmt txt2html -helptext { 
             'nose'          : Nose' thermostat, not implemented
             'rescaling'     : velocity rescaling (sort of implemented)
             'not_controlled': default
}

help tempw        -vartype real -helpfmt txt2html -helptext { 
             starting temperature in MD runs
}

help tolp         -vartype real -helpfmt txt2html -helptext { 
             tolerance for velocity rescaling. Velocities are
             not rescaled if the ratio of the run-averaged and 
             target temperature differs from unit less than tolp
<p> ( default = 1.D-3 )
}

help delta_t  -vartype real -helpfmt txt2html -helptext { 
               delta_t = 1                 : every 'nraise' step the actual 
                                             temperature is rescaled to tempw
               delta_t /= 1 && delta_T > 0 : at each step the temperature is 
                                             multiplied by delta_t; this is 
                                             done rescaling all the velocities.
               delta_t < 0                 : every 'nraise' steps temperature
                                             is reduced by -delta_T
               This keyword is NOT used in the case of variable cell
               calculations.
<p> ( default = 1.D0 )
}

help nraise       -vartype  integer -helpfmt txt2html -helptext {
               The temperature is reduced of -delta_T every 'nraise' steps.
               This keyword is NOT used in the case of variable cell
               calculations.
<p>  ( default = 100 )
}
#help monitor_constr -vartype logical -helpfmt txt2html -helptext {
#               This keyword applies only when one or more constraints are 
#               defined in the CONSTRAINTS card (see below). 
#               If true, the values of the constraints are monitored, but the
#               constraints are not imposed.
#<p> ( default = .FALSE. )
#}

help refold_pos -vartype logical -helpfmt txt2html -helptext {
               This keyword applies only in the case of molecular dynamics or
               damped dynamics. If true the ions are refolded at each step into
               the supercell.
<p> ( default = .FALSE. )
}

help upscale      -vartype real -helpfmt txt2html -helptext { 
               max reduction factor for conv_thr during structural optimization
               conv_thr is automatically reduced when the relaxation 
               approaches convergence so that forces are still accurate,
               but conv_thr will not be reduced to less that 
               conv_thr / upscale. 
<p> ( default = 10.D0 )
}

help pot_extrapolation     -vartype character -helpfmt txt2html -helptext { 
               used to extrapolate the potential from preceding ionic step(s)
               
               'none':          no extrapolation
               'atomic':        extrapolate the potential as if it was a sum of
                                atomic-like orbitals (default for calculation='relax')
               'first_order':   extrapolate the potential with first-order formula
                                (default for calcualtion = 'md', 'neb', 'smd')
               'second_order':  as above, with second order formula
}

help wfc_extrapolation     -vartype character -helpfmt txt2html -helptext { 
               used to extrapolate the wave-functions from preceding ionic step(s)
               
               'none':   no extrapolation
               'first_order':   extrapolate the wave-functions with first-order formula
                                (default for calcualtion = 'md', 'neb', 'smd')
               'second_order':  as above, with second order formula
}

help bfgs_ndim    -vartype integer -helpfmt txt2html -helptext {
               Number of old forces and displacements vectors used in the
	       linear scaling BFGS algorithm. When lbfgs_ndim = 1 the complete
	       inverse Hessian is stored (suggested for small/medium-size 
	       systems).<p>
	       On large systems (some hundreds of atoms) a good performance can 
	       be achieved with only 4 or 6 old vectors 
               (bfgs only)
<p> ( default = 1 )
}

help trust_radius_max -vartype  real -helpfmt txt2html -helptext {
               maximum ionic displacement in the structural relaxation 
	       (bfgs only)
<p> ( default = 0.5D0 BOHR ) 
}

help trust_radius_min -vartype  real -helpfmt txt2html -helptext {
	       minimum ionic displacement in the structural relaxation
               BFGS is reset when trust_radius < trust_radius_min
	       (bfgs only)
<p> ( default = 1.D-5 BOHR )
}

help trust_radius_ini -vartype real -helpfmt txt2html -helptext {
               initial ionic displacement in the structural relaxation
               (bfgs only)
<p> ( default = 0.5D0 BOHR )
}

set _w12 {
	       parameters used in line search based on the Wolfe conditions
	       (bfgs only)
<p> ( default : w_1 = 1.D-5, w_2 = 0.2D0 )

}     
foreach var {w_1 w_2} {
    help $var -vartype real -helpfmt txt2html -helptext $_w12
}

help num_of_images -vartype integer -helpfmt txt2html -helptext {
               number of points used to discrtize the path
<p> ( default = 0 )
}

help CI_scheme    -vartype   character -helpfmt txt2html -helptext {
               specify the type of Climbing Image scheme
               "no-CI"      : climbing image is not used
               "highest-TS" : original CI scheme. The image highest in energy 
	                      does not feel the effect of springs and is 
			      allowed to climb along the path
               "manual"     : images that have to climb are manually selected. 
	                      See also CLIMBING_IMAGES card 
<p> ( default = "no-CI" )
}

help first_last_opt  -vartype  logical -helpfmt txt2html -helptext {
               also the first and the last configurations are optimized
               "on the fly" 
	       (these images do not feel the effect of the springs)
<p> ( default = .FALSE. )
}

help opt_scheme  -vartype    character -helpfmt txt2html -helptext {
               specify the type of optimization scheme      
               "sd"         : steepest descent
	       "quick-min"  : a minimization algorithm based on
	                      molecular dynamics (suggested).
               "broyden"    : quasi-Newton Broyden's second method.
               "damped-dyn" : damped molecular dynamics. See also the 
	                      keyword damp
               "mol-dyn"    : constant temperature molecular dynamics. See 
	                      also the keyword temp_req.
	                      Note that, in order to perform such molecular 
			      dynamics, spring forces are NOT projected 
			      along the path. 
<p> ( default = "quick-min" )
}

#help damp        -vartype    real -helpfmt txt2html -helptext {
#               Damping coefficent. Ignored when "minimization_scheme"
#               is different from "damped-verlet"
#<p> ( default = 1.D0 )
#}

help temp_req      -vartype  real -helpfmt txt2html -helptext {
               temperature associated to the elastic band. Each image has its 
	       own thermostat. The temperature in the output is the average 
	       temperature of the elastic band computed before the 
	       thermalization
               ignored when "minimization_scheme" is different from
               "mol-dyn"
<p> ( default = 0.D0 Kelvin )
}

help ds          -vartype    real -helpfmt txt2html -helptext {
               optimization step length ( Hartree atomic units )
<p> ( default = 1.5D0 )
}
	
set _k {              
               set them to use a Variable Elastic Constants scheme 
	       elastic constants are in the range [ k_min, k_max ] 
	       this is useful to rise the resolution around the saddle point
<p> ( default = 0.1D0 Hartree atomic units )
}
foreach var {k_max k_min} {
    help $var -vartype real -helpfmt txt2html -helptext $_k
}

help path_thr      -vartype   real -helpfmt txt2html -helptext {
               the simulation stops when the error ( the norm of the force 
	       orthogonal to the path in eV/A ) is less than path_thr.
<p> ( default = 0.05D0 eV / Angstrom )
}


#help write_save    -vartype logical -helpfmt txt2html -helptext {
#               used to write the prefix.save file for each image needed for
#               post-processing
#<p> ( default = .FALSE. )
#}

help use_freezing  -vartype logical -helpfmt txt2html -helptext {
               if. TRUE. the images are optimised according to their error:
               only those images with an error larger than half of the largest
               are optimised. The other images are kept forzen.
<p> ( default = .FALSE. )
}

#help use_fourier   -vartype logical -helpfmt txt2html -helptext {
#               Used in the evaluation of the free-energy profile with
#               finite-temperature string dynamics.
#<p> ( default = .FALSE. )
#}

#help use_multistep -vartype logical -helpfmt txt2html -helptext {
#               In the string method images are sequentially added to the path: 
#               new images are added as soon as the pervious path is converged 
#               (this starting from 3 images up to num_of_images).
#<p> ( default = .FALSE. )
#}

help use_masses -vartype logical -helpfmt txt2html -helptext {
               If. TRUE. the optimisation of the path is performed using 
               mass-weighted coordinates.
<p> ( default = .FALSE. )
}

#help free_energy -vartype logical -helpfmt txt2html -helptext {
#               Used in the evaluation of the free-energy profile with
#               finite-temperature string dynamics.
#<p> ( default = .FALSE. )               
#}

help fe_step -vartype logical -helpfmt txt2html -helptext {
               meta-dinamics step length (in principle different for each
               collective variable), defined using the same units used 
               to define the colletive variables (constraints).
<p> ( default = 0.04 )
}

help g_amplitude -vartype logical -helpfmt txt2html -helptext {
               Amplitude of the gaussians used in meta-dinamics.
<p> ( default = 0.005 Hartree )
}
                
#help g_sigma -vartype logical -helpfmt txt2html -helptext {
#               Spread  of the gaussians used in meta-dinamics, defined using the
#               same units used to define the colletive variables (constraints).
#<p>  ( default = 0.04 )
#}

help fe_nstep -vartype logical -helpfmt txt2html -helptext {
               Maximum number of steps used to evaluate the potential of
               mean force.
<p> ( default = 100 )
}

#help shake_nstep -vartype logical -helpfmt txt2html -helptext {
#               Number of steps used to switch to the new values of the
#               collective variables (constraints).
#<p> ( default = 10 )
#}

# =============================================================================
# NAMELIST &CELL
# =============================================================================

help cell_dynamics     -vartype character -helpfmt txt2html -helptext { 
               specify the type of dynamics for the cell. 
               For different type of calculation different possibilities 
               are allowed and different default values apply:

               CASE ( calculation = 'vc-relax' )
                 'none':    default 
                 'sd':      steepest descent ( not implemented )
                 'damp-pr': damped (Beeman) dynamics of the Parrinello-Raman 
                            extended lagrangian
                 'damp-w':  damped (Beeman) dynamics of the new Wentzcovitch
                            extended lagrangian
               CASE ( calculation = 'vc-md' )
                 'none': default 
                 'pr':      (Beeman) molecular dynamics of the Parrinello-Raman 
                            extended lagrangian
                 'w':       (Beeman) molecular dynamics of the new Wentzcovitch
                            extended lagrangian
}

help press        -vartype real -helpfmt txt2html -helptext { 
             target pressure [KBar] in a variable-cell md simulation
<p> ( default = 0.D0 )
}

help wmass        -vartype real -helpfmt txt2html -helptext { 
             ficticious cell mass for variable-cell md simulations
}

help press_conv_thr -vartype real -helpfmt txt2html -helptext {
               Convergence threshold on the pressure for variable cell
               relaxation ('vc-relax' : note that the other convergence
               thresholds for ionic relaxation apply as well).
<p>  ( default = 0.5D0 Kbar )
}

help cell_factor  -vartype real -helpfmt txt2html -helptext { 
             used in the construction of the pseudopotential tables. 
             It should exceed the maximum linear contraction of the
             cell during a simulation. 
<p> ( default = 1.2D0 )
}


# =============================================================================
# NAMELIST &PHONON
# =============================================================================

help modenum      -vartype integer -helpfmt txt2html -helptext { 
             for single-mode phonon calculation (default:0)
}

help xqq       -vartype real -helpfmt txt2html -helptext { 
             q-point (units 2pi/a) for phonon calculation
}


# ==============================================================================
# CARD: CELL_PARAMETERS
# ==============================================================================

set _lattice {
CELL_PARAMETERS { cubic | hexagonal }
  optional card, needed only if ibrav = 0 is specified
  cubic    : assume cubic symmetry or a subset (default)  
  hexagonal: assume hexagonal symmetry or a subset
  Next cards:
    a(1,1) a(2,1) a(3,1)
    a(1,2) a(2,2) a(3,2)
    a(1,3) a(2,3) a(3,3)

  a(:,1) = crystal axis 1    alat units if celldm(1) was specified
      2                 2    a.u. if celldm(1)=0
      3                 3
}
help lattice -vartype {real, real, real} -helpfmt txt2html -helptext $_lattice
help lattice_type -vartype character -helpfmt txt2html -helptext $_lattice


# ==============================================================================
# CARD: ATOMIC_SPECIES
# ==============================================================================

help atomic_species -vartype {character, real, character} -helpfmt txt2html -helptext {
Syntax:

ATOMIC_SPECIES
 X(1)     Mass_X(1)     PseudoPot_X(ntyp)
 X(2)     Mass_X(2)     PseudoPot_X(ntyp)
 ...
 X(ntyp)  Mass_X(ntyp)  PseudoPot_X(ntyp)


Description:
 X           Character: label of the atom
 Mass_X      Real     : mass of the atomic species
                        not used if calculation='scf', 'nscf', 'phonon'
 PseudoPot_X Character: file containing PP for this species
}


# ==============================================================================
# CARD: ATOMIC_POSITIONS
# ==============================================================================

set _pos {
    Atomic positions can be loaded by pressing the 
    "Load atomic coordinates from file ..." button. The coordinates 
    should be written in PW.X syntax. This means that the "ATOMIC_POSITIONS"
    card will be parsed. Below is the description of its syntax.
    
    Syntax:
    
    ATOMIC_POSITIONS { alat | bohr | crystal | angstrom }
    if ( calculation = 'neb' .OR. 'smd' )
      first_image
      X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
      Y 0.5  0.0  0.0
      Z O.0  0.2  0.2
      last_image
      X 0.0  0.0  0.0
      Y 0.7  0.0  0.0
      Z O.0  0.5  0.2 
    else
      X 0.0  0.0  0.0  {if_pos(1) if_pos(2) if_pos(3)}
      Y 0.5  0.0  0.0
      Z O.0  0.2  0.2
    
    Description:
    
       alat    : atomic positions are in units of alat (default)
       bohr    : atomic positions are in a.u.
       crystal : atomic positions are in crystal coordinates (see below)
       angstrom: atomic positions are in ANGSTROMS    
}
help atomic_coordinates \
    -vartype {character, real, real, real, \[ingeter, ingteger, integer\]} \
    -helpfmt txt2html -helptext $_pos
help atomic_coordinates_last \
    -vartype {character, real, real, real} \
    -helpfmt txt2html -helptext $_pos

# BEWARE: it is assumed that 50 intermediate images is the
# largest allowed number (this is dirty)
for {set i 1} {$i <= 50} {incr i} {
    help atomic_coordinates_${i}_inter \
	-vartype {character, real, real, real} \
	-helpfmt txt2html -helptext $_pos
}



# ==============================================================================
# CARD: K_POINTS 
# ==============================================================================

set _kpoints0 {
    K-points coordinates can be loaded by pressing the 
    "Load K-point coordinates from file ..." button. The coordinates 
    should be written in PW.X syntax. This means that the "K_POINTS"
    card will be parsed. Below is the description of its syntax.
}
set _kpoints {
Syntax:

K_POINTS { tpiba | automatic | crystal | gamma }
if (gamma)
   nothing to read
elseif (automatic) 
   nk1  nk2  nk3  sk1  sk2  sk3
else
   nks
   xk_x(1)    xk_y(1)    xk_z(1)     wk(1)
   xk_x(2)    xk_y(3)    xk_z(4)     wk(5)
   ...
   xk_x(nks)  xk_y(nks)  xk_z(nks)   wk(nks)
 

Description:

K_POINTS { tpiba | automatic | crystal | gamma }

   gamma    : use k = 0 ( do not read anything after this card )
              Note that a set of subroutines optimized for clculations at 
              the gamma point are used so that both memory and cpu requirements
              are reduced
   automatic: automatically generated uniform grid of k-points
              next card:
   nk1, nk2, nk3, sk1, sk2, sk3 :
              generates ( nk1, nk2, nk3 ) mesh with ( sk1, sk2, sk3 ) offset
              nk1, nk2, nk3 as in Monkhorst-Pack grids
              sk1, sk2, sk3 must be 0 ( no offset ) or 1 ( grid displaced 
              by half a grid step in the corresponding direction )
              The mesh with offset may not work with tetrahedra.
   crystal  : read k-points in crystal coordinates
   tpiba    : read k-points in 2pi/a units ( default )
              next card:
   nks
              number of supplied special points
   do i=1,nks
   ! xk_x, xk_y, xk_z, wk      : k-point coordinates and weight
   !           special points in the irreducible Brillouin Zone
   !           of the lattice (with all symmetries) and weights
   !           If the symmetry is lower than the full symmetry 
   !           of the lattice, additional points with appropriate
   !           weights are generated
   enddo 
}
help kpoint_type -vartype character -helpfmt txt2html -helptext $_kpoints
foreach var {nks nk1 nk2 nk3 sk1 sk2 sk3} {
    help $var -vartype integer -helpfmt txt2html -helptext $_kpoints
}
help kpoints -vartype {real, real, real, real} -helpfmt txt2html -helptext ${_kpoints0}\n$_kpoints


# ==============================================================================
# CARD: CLIMBING_IMAGES
# ==============================================================================

help climbing_images_list -vartype {list of comma-separated integers} -helpfmt txt2html -helptext {
Syntax:

CLIMBING_IMAGES
   index1, index2, ..., indexN

Description:
  Optional card, needed only if calculation = 'neb' and CI_scheme = 'manual',    
  where index1, index2, ..., indexN are the indices of the images to which 
  apply the Climbing Image procedure. If more than an image is specified they
  must be separated by a comma
}

# ==============================================================================
# CARD: CONSTRAINTS
# ==============================================================================

set constraints_help {

   Ionic Constraints

 Syntax:

    CONSTRAINTS
      nconstr   constr_tol
      constr_type(.)   constr(1,.)   constr(2,.)

 Where:

      nconstr (INTEGER)         INTEGER, number of constraints
      constr_tol                REAL,    tolerance for keeping the constraints 
                                         satisfied
      constr_type(.)            INTEGER, type of constrain
      constr(1,.) constr(2,.)   INTEGER, atoms indices object of the constraint.
                                        
                          I.E.: 1 ia1 ia2 "1" is the constrain type 
                                (fixed distance) "ia1 ia2" are the 
                                indices of the atoms (as they appear 
                                in the 'ATOMIC_POSITION' CARD) whose 
                                distance has to be kept constant

}

foreach var { nconstr constr_tol constraints_table } { 
    help $var -helpfmt txt2html -helptext $constraints_help 
}
