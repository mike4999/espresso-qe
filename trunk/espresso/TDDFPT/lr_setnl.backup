!
! Copyright (C) 2001-2006 Quantum-ESPRESSO group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!
! OBM
!  010708 npps -> dffts%npp
!         atom r moved to rgrid 
!         uspp_param moved to upf betar->beta, checked from init_us
#include "f_defs.h"
!
!----------------------------------------------------------------------------
MODULE real_beta
  !----------------------------------------------------------------------------
  !
  USE kinds, ONLY : DP
  !
  ! ... module written by Dario Rocca
  !
  INTEGER,  ALLOCATABLE :: box_beta(:,:), maxbox_beta(:)
  REAL(DP), ALLOCATABLE :: betasave(:,:,:)
  REAL(DP), ALLOCATABLE :: boxrad_beta(:)
  REAL(DP), ALLOCATABLE :: boxdist_beta(:,:), xyz_beta(:,:,:)     
  REAL(DP), ALLOCATABLE :: spher_beta(:,:,:)
  LOGICAL               :: tnlr
  !
  !
  CONTAINS
    !
    !------------------------------------------------------------------------
!    SUBROUTINE deallocatenewdreal()
      !------------------------------------------------------------------------
      !
!      IF ( ALLOCATED( box_beta ) )     DEALLOCATE( box_beta )
!      IF ( ALLOCATED( maxbox_beta ) )  DEALLOCATE( maxbox_beta )
!      IF ( ALLOCATED( betasave ) )   DEALLOCATE( betasave )
!      IF ( ALLOCATED( boxrad_beta ) )  DEALLOCATE( boxrad_beta )
      !
!    END SUBROUTINE deallocatenewdreal
    !
    !------------------------------------------------------------------------
    SUBROUTINE betapointlist()
      !------------------------------------------------------------------------
      !
      ! ... This subroutine is the driver routine of the box system in this 
      ! ... implementation of US in real space.
      ! ... All the variables common in the module are computed and stored for 
      ! ... reusing. 
      ! ... This routine has to be called every time the atoms are moved and of
      ! ... course at the beginning.
      ! ... A set of spherical boxes are computed for each atom. 
      ! ... In boxradius there are the radii of the boxes.
      ! ... In maxbox the upper limit of leading index, namely the number of
      ! ... points of the fine mesh contained in each box.
      ! ... In xyz there are the coordinates of the points with origin in the
      ! ... centre of atom.
      ! ... In boxdist the distance from the centre.
      ! ... In spher the spherical harmonics computed for each box
      ! ... In qsave the q value interpolated in these boxes.
      !
      ! ... Most of time is spent here; the calling routines are faster.
      !
      USE constants,  ONLY : pi, eps8, eps16
      USE ions_base,  ONLY : nat, nsp, ityp, tau
      USE cell_base,  ONLY : at, bg, omega, alat
      USE gsmooth,    ONLY : nr1s, nr2s, nr3s, nrx1s, nrx2s, nrx3s, nrxxs
      USE uspp,       ONLY : okvan, indv, nhtol, nhtolm, ap
      USE uspp_param, ONLY : upf, lmaxq, nh, nhm
      USE atom,       ONLY : rgrid
      !USE pffts,      ONLY : npps
      USE fft_base,   ONLY : dffts
      USE mp_global,  ONLY : me_pool
      USE splinelib,  ONLY : spline, splint
USE ions_base,             ONLY : ntyp => nsp
      !
      IMPLICIT NONE
      !
      INTEGER               :: betasdim, ia, it, mbia, iqs
      INTEGER               :: indm, inbrx, idimension, &
                               ilm, ih, jh, iih, ijh
      INTEGER               :: roughestimate, goodestimate, lamx2, l, nt
      INTEGER,  ALLOCATABLE :: buffpoints(:,:)
      REAL(DP), ALLOCATABLE :: buffdist(:,:)
      REAL(DP)              :: distsq, qtot_int, first, second
      INTEGER               :: index0, index, indproc, ir
      INTEGER               :: i, j, k, i0, j0, k0, ipol, lm, nb, mb, ijv, ilast
      REAL(DP)              :: posi(3)
      REAL(DP), ALLOCATABLE :: rl(:,:), rl2(:)
      REAL(DP), ALLOCATABLE :: tempspher(:,:), qtot(:,:,:), &
                               xsp(:), ysp(:), wsp(:)
      REAL(DP)              :: mbr, mbx, mby, mbz, dmbx, dmby, dmbz
      REAL(DP)              :: inv_nr1s, inv_nr2s, inv_nr3s, tau_ia(3), boxradsq_ia
      !
      !
      IF ( .NOT. okvan ) RETURN
      !
      CALL start_clock( 'betapointlist' )
      !
      ! ... qsave is deallocated here to free the memory for the buffers
      !
      IF ( ALLOCATED( betasave ) ) DEALLOCATE( betasave )
      !
      IF ( .NOT. ALLOCATED( boxrad_beta ) ) THEN
         !
         ! ... here we calculate the radius of each spherical box ( one
         ! ... for each non-local projector )
         !
         ALLOCATE( boxrad_beta( nsp ) )
         !
         boxrad_beta(:) = 0.D0
         !
         DO it = 1, nsp
            DO inbrx = 1, upf(it)%nbeta
               DO indm = upf(it)%kkbeta, 1, -1
                  !
                  IF ( ABS( upf(it)%beta(indm,inbrx) ) > 0.d0 ) THEN
                     !
                     boxrad_beta(it) = MAX( rgrid(it)%r(indm), boxrad_beta(it) )
                     !
                     CYCLE
                     !
                  END IF
                  !
               END DO
            END DO
         END DO
         !
         boxrad_beta(:) = boxrad_beta(:) / alat
         !
      END IF
      !
      ! ... a rough estimate for the number of grid-points per box
      ! ... is provided here
      !
      mbr = MAXVAL( boxrad_beta(:) )
      !
      mbx = mbr*SQRT( bg(1,1)**2 + bg(1,2)**2 + bg(1,3)**2 )
      mby = mbr*SQRT( bg(2,1)**2 + bg(2,2)**2 + bg(2,3)**2 )
      mbz = mbr*SQRT( bg(3,1)**2 + bg(3,2)**2 + bg(3,3)**2 )
      !
      dmbx = 2*ANINT( mbx*nrx1s ) + 2
      dmby = 2*ANINT( mby*nrx2s ) + 2
      dmbz = 2*ANINT( mbz*nrx3s ) + 2
      !
      roughestimate = ANINT( DBLE( dmbx*dmby*dmbz ) * pi / 6.D0 )
      !
      CALL start_clock( 'realus:boxes' )
      !
      ALLOCATE( buffpoints( roughestimate, nat ) )
      ALLOCATE( buffdist(   roughestimate, nat ) )
      !
      ALLOCATE( xyz_beta( 3, roughestimate, nat ) )
      !
      buffpoints(:,:) = 0
      buffdist(:,:) = 0.D0
      !
      IF ( .NOT.ALLOCATED( maxbox_beta ) ) ALLOCATE( maxbox_beta( nat ) )
      !
      maxbox_beta(:) = 0
      !
      ! ... now we find the points
      !
      index0 = 0
      !
#if defined (__PARA)
      !
      DO i = 1, me_pool
         index0 = index0 + nrx1s*nrx2s*dffts%npp(i)
      END DO
      !
#endif
      !
      inv_nr1s = 1.D0 / DBLE( nr1s )
      inv_nr2s = 1.D0 / DBLE( nr2s )
      inv_nr3s = 1.D0 / DBLE( nr3s )
      !
      DO ia = 1, nat
         !
         IF ( .NOT. upf(ityp(ia))%tvanp ) CYCLE
         !
         boxradsq_ia = boxrad_beta(ityp(ia))**2
         !
         tau_ia(1) = tau(1,ia)
         tau_ia(2) = tau(2,ia)
         tau_ia(3) = tau(3,ia)
         !
         DO ir = 1, nrxxs
            !
            ! ... three dimensional indexes
            !
            index = index0 + ir - 1
            k     = index / (nrx1s*nrx2s)
            index = index - (nrx1s*nrx2s)*k
            j     = index / nrx1s
            index = index - nrx1s*j
            i     = index
            !
            DO ipol = 1, 3
               posi(ipol) = DBLE( i )*inv_nr1s*at(ipol,1) + &
                            DBLE( j )*inv_nr2s*at(ipol,2) + &
                            DBLE( k )*inv_nr3s*at(ipol,3)
            END DO
            !
            posi(:) = posi(:) - tau_ia(:)
            !
            ! ... minimum image convenction
            !
            CALL cryst_to_cart( 1, posi, bg, -1 )
            !
            posi(:) = posi(:) - ANINT( posi(:) )
            !
            CALL cryst_to_cart( 1, posi, at, 1 )
            !
            distsq = posi(1)**2 + posi(2)**2 + posi(3)**2
            !
            IF ( distsq < boxradsq_ia ) THEN
               !
               mbia = maxbox_beta(ia) + 1
               !
               maxbox_beta(ia)     = mbia
               buffpoints(mbia,ia) = ir
               buffdist(mbia,ia)   = SQRT( distsq )*alat
               xyz_beta(:,mbia,ia) = posi(:)*alat
               !
            END IF
         END DO
      END DO
      !
      goodestimate = MAXVAL( maxbox_beta )
      !
      IF ( goodestimate > roughestimate ) &
         CALL errore( 'betapointlist', 'rough-estimate is too rough', 2 )
      !
      ! ... now store them in a more convenient place
      !
      IF ( ALLOCATED( box_beta ) )     DEALLOCATE( box_beta )
      IF ( ALLOCATED( boxdist_beta ) ) DEALLOCATE( boxdist_beta )
      !
      ALLOCATE( box_beta    ( goodestimate, nat ) )
      ALLOCATE( boxdist_beta( goodestimate, nat ) )
      !
      box_beta(:,:)     = buffpoints(1:goodestimate,:)
      boxdist_beta(:,:) = buffdist(1:goodestimate,:)
      !
      DEALLOCATE( buffpoints )
      DEALLOCATE( buffdist )
      !
      CALL stop_clock( 'realus:boxes' )
      CALL start_clock( 'realus:spher' )
      !
      ! ... now it computes the spherical harmonics
      !
      lamx2 = lmaxq*lmaxq
      !
      IF ( ALLOCATED( spher_beta ) ) DEALLOCATE( spher_beta )
      !
      ALLOCATE( spher_beta( goodestimate, lamx2, nat ) )
      !
      spher_beta(:,:,:) = 0.D0
      !
      DO ia = 1, nat
         !
         IF ( .NOT. upf(ityp(ia))%tvanp ) CYCLE
         !
         idimension = maxbox_beta(ia)
         !
         ALLOCATE( rl( 3, idimension ), rl2( idimension ) )
         !
         DO ir = 1, idimension
            !
            rl(:,ir) = xyz_beta(:,ir,ia)
            !
            rl2(ir) = rl(1,ir)**2 + rl(2,ir)**2 + rl(3,ir)**2
            !
         END DO
         !
         ALLOCATE( tempspher( idimension, lamx2 ) )
         !
         CALL ylmr2( lamx2, idimension, rl, rl2, tempspher )
         !
         spher_beta(1:idimension,:,ia) = tempspher(:,:)
         !
         DEALLOCATE( rl, rl2, tempspher )
         !
      END DO
      !
      DEALLOCATE( xyz_beta )
      !
      CALL stop_clock( 'realus:spher' )
      CALL start_clock( 'realus:qsave' )
      !
      ! ... let's do the main work
      !
      betasdim = 0
      DO ia = 1, nat
         mbia = maxbox_beta(ia)
         IF ( mbia == 0 ) CYCLE
         nt = ityp(ia)
         IF ( .NOT. upf(nt)%tvanp ) CYCLE
         DO ih = 1, nh(nt)
               betasdim = betasdim + mbia
         END DO
      END DO
      !      
      PRINT *, "BETASAVE SIZE : ", betasdim
      !
      ALLOCATE( betasave( nat, nhm, goodestimate )  )
      !
      betasave = 0.D0
      !
      ! ... the source is inspired by init_us_1
      !
      ! ... we perform two steps: first we compute for each l the qtot
      ! ... (radial q), then we interpolate it in our mesh, and then we
      ! ... add it to qsave with the correct spherical harmonics
      !
      ! ... Q is read from pseudo and it is divided into two parts:
      ! ... in the inner radius a polinomial representation is known and so
      ! ... strictly speaking we do not use interpolation but just compute
      ! ... the correct value
      !
      iqs   = 0
      !
      DO ia = 1, nat
         !
         mbia = maxbox_beta(ia)
         !
         IF ( mbia == 0 ) CYCLE
         !
         nt = ityp(ia)
         !
         IF ( .NOT. upf(nt)%tvanp ) CYCLE
         !
         ALLOCATE( qtot( upf(nt)%kkbeta, upf(nt)%nbeta, upf(nt)%nbeta ) )
         !
         ! ... variables used for spline interpolation
         !
         ALLOCATE( xsp( upf(nt)%kkbeta ), ysp( upf(nt)%kkbeta ), wsp( upf(nt)%kkbeta ) )
         !
         ! ... the radii in x
         !
         xsp(:) = rgrid(nt)%r(1:upf(nt)%kkbeta)
         !
         DO ih = 1, nh (nt)
            !
            lm = nhtolm(ih, nt)
            nb = indv(ih, nt)
            !
            !OBM rgrid(nt)%r(1) == 0 ????? attempting correction
            if (rgrid(nt)%r(1)==0) then 
             ysp(2:) = upf(nt)%beta(2:upf(nt)%kkbeta,nb) / rgrid(nt)%r(2:upf(nt)%kkbeta)
             ysp(1)=0.d0
            else
             ysp(:) = upf(nt)%beta(1:upf(nt)%kkbeta,nb) / rgrid(nt)%r(1:upf(nt)%kkbeta)
            endif
            !print *, "ysp1",ysp(1),"=",upf(nt)%beta(1,nb),"//",rgrid(nt)%r(1)
            
            !
            first = (ysp(2) - ysp(1)) / (xsp(2) - xsp(1))
            !print *,"first",first
!            first = 0.d0
            !
            CALL spline( xsp, ysp, first, 0.d0, wsp )
            !
            DO ir = 1, mbia
               !
               ! ... spline interpolation
               !
               qtot_int = splint( xsp, ysp, wsp, boxdist_beta(ir,ia) )
               !
               iqs = iqs + 1
               !
               betasave(ia,ih,ir) = qtot_int*spher_beta(ir,lm,ia)
               !print *, "qtot check=",qtot_int
               !
            END DO
         END DO
         !
         DEALLOCATE( qtot )
         DEALLOCATE( xsp )
         DEALLOCATE( ysp )
         DEALLOCATE( wsp )
         !
      END DO
      !
      DEALLOCATE( boxdist_beta )
      DEALLOCATE( spher_beta )
      !
      CALL stop_clock( 'realus:qsave' )
      CALL stop_clock( 'betapointlist' )
      !
    END SUBROUTINE betapointlist
    !
    !--------------------------------------------------------------------------
    SUBROUTINE ccalbecr_gamma ( ibnd, m )
    !--------------------------------------------------------------------------
    ! Calculates rbecp in real space
    !ibnd is an index that runs over the number of bands, which is given by m
    ! So you have to call this subroutine inside a cycle with index ibnd
    ! In this cycle you have to perform a Fourier transform of the orbital
    ! corresponding to ibnd, namely you have to transform the orbital to
    ! real space and store it in the global variable psic. 
    ! Remember that in the gamma_only case you
    ! perform two fast Fourier transform at the same time, and so you have
    ! that the real part correspond to ibnd, and the imaginary part to ibnd+1
      USE kinds,                 ONLY : DP
      USE cell_base,             ONLY : omega
      USE wavefunctions_module,  ONLY : psic
      USE ions_base,             ONLY : nat, ntyp => nsp, ityp
      USE gsmooth,               ONLY : nr1s, nr2s, nr3s
      USE uspp_param,            ONLY : nh, nhm
      USE control_flags,         ONLY : gamma_only
      USE becmod,                ONLY : rbecp, becp
      !
      IMPLICIT NONE
      !
      INTEGER, intent(in) :: ibnd, m
      INTEGER :: iqs, iqsp, ikb, nt, ia, ih, mbia
      REAL(DP) :: fac
      REAL(DP), allocatable, dimension(:) :: wr, wi
      REAL(DP) :: bcr, bci
!COMPLEX(DP), allocatable, dimension(:) :: bt
!integer :: ir, k
      !
      REAL(DP), external :: DDOT
      !
      CALL start_clock( 'ccalbecr' )
      !
      fac = SQRT(omega) / (nr1s*nr2s*nr3s)
      !
      rbecp(:,ibnd)=0.d0
      IF ( ibnd+1 .le. m ) rbecp(:,ibnd+1)=0.d0
      ! Clearly for an odd number of bands for ibnd=nbnd=m you don't have
      ! anymore bands, and so the imaginary part equal zero
      !
      !! IF ( gamma_only ) then !we dont like ifs in for loops dont we?
         !
         iqs = 1
         ikb = 0
         !
         DO nt = 1, ntyp
            !
             DO ia = 1, nat
               !
               IF ( ityp(ia) == nt ) then
                  !
                  mbia = maxbox_beta(ia)
                  
                  ! maxbox_beta contains the maximum number of real space points necessary
                  ! to describe the beta function corresponding to the atom ia
                  ! Namely this is the number of grid points for which beta is
                  ! different from zero
                  !
                  ALLOCATE( wr(mbia), wi(mbia) )
                  ! just working arrays
                  !
                  DO ih = 1, nh(nt)
                     ! nh is the number of beta functions, or something similar
                     !
                     ikb = ikb + 1
                     iqsp = iqs+mbia-1
                     wr(:) = DBLE ( psic( box_beta(1:mbia,ia) ) )
                     wi(:) = AIMAG( psic( box_beta(1:mbia,ia) ) )
                     !print *, "betasave check", betasave(ia,ih,:)
                     ! box_beta contains explictly the points of the real space grid in
                     ! which the beta functions are differet from zero. Remember
                     ! that dble(psic) corresponds to ibnd, and aimag(psic) to ibnd+1:
                     ! this is the standard way to perform fourier transform in pwscf
                     ! in the gamma_only case
                     bcr  = DDOT( mbia, betasave(ia,ih,:), 1, wr(:) , 1 )
                     bci  = DDOT( mbia, betasave(ia,ih,:), 1, wi(:) , 1 )
                     ! in the previous two lines the real space integral is performed, using
                     ! few points of the real space mesh only
                     rbecp(ikb,ibnd)   = fac * bcr
                     IF ( ibnd+1 .le. m ) rbecp(ikb,ibnd+1) = fac * bci
                     ! It is necessary to multiply by fac which to obtain the integral in real
                     ! space
                     iqs = iqsp + 1
                     !
                  END DO
                  !
                  DEALLOCATE( wr, wi )
                  !
               END IF
               !
            END DO
            !
         END DO
         !
         ! 
      CALL stop_clock( 'ccalbecr' )
      !
      RETURN 

    END SUBROUTINE ccalbecr_gamma
    !--------------------------------------------------------------------------
    SUBROUTINE ccalbecr_k ( ibnd, m )
    !--------------------------------------------------------------------------
    ! ccalbecr, k point generalised case.   DOES NOT WORK
    !
      USE kinds,                 ONLY : DP
      USE cell_base,             ONLY : omega
      USE wavefunctions_module,  ONLY : psic
      USE ions_base,             ONLY : nat, ntyp => nsp, ityp
      USE gsmooth,               ONLY : nr1s, nr2s, nr3s
      USE uspp_param,            ONLY : nh, nhm
      USE control_flags,         ONLY : gamma_only
      USE becmod,                ONLY : rbecp, becp
      !
      IMPLICIT NONE
      !
      INTEGER, intent(in) :: ibnd, m
      INTEGER :: iqs, iqsp, ikb, nt, ia, ih, mbia
      REAL(DP) :: fac
      REAL(DP), allocatable, dimension(:) :: wr, wi
      REAL(DP) :: bcr, bci
!COMPLEX(DP), allocatable, dimension(:) :: bt
!integer :: ir, k
      !
      REAL(DP), external :: DDOT

      !ELSE
         !
         ! The k points part is not supposed to work
         !
         iqs = 1
         ikb = 0
         !
         DO nt = 1, ntyp
            !
            DO ia = 1, nat
               !
               IF ( ityp(ia) == nt ) then
                  !
                  mbia = maxbox_beta(ia)
                  ALLOCATE( wr(mbia), wi(mbia) )
                  !
                  DO ih = 1, nh(nt)
                     !
                     ikb = ikb + 1
                     iqsp = iqs+mbia-1
                     wr(:) = DBLE ( psic( box_beta(1:mbia,ia) ) )
                     wi(:) = AIMAG( psic( box_beta(1:mbia,ia) ) )
!                     bcr  = DDOT( mbia, betasave(iqs:iqsp), 1, wr(:) , 1 )
!                     bci  = DDOT( mbia, betasave(iqs:iqsp), 1, wi(:) , 1 )
!                     bec(ikb) = fac * CMPLX( bcr(ih), bci(ih) )
                     iqs = iqsp
                     !
                  END DO
                  !
                  DEALLOCATE( wr, wi )
                  !
               END IF
               !
            END DO
            !
         END DO
         !
      !END IF
      !
      CALL stop_clock( 'ccalbecr' )
      !
      RETURN 
      !
    END SUBROUTINE ccalbecr_k
    !
    !--------------------------------------------------------------------------
    SUBROUTINE fft_orbital_gamma (orbital, ibnd, nbnd)
    !--------------------------------------------------------------------------
    !
    ! OBM 110908
    ! This driver subroutine transforms the given orbital using fft and puts the result in psic
    ! Warning! In order to be fast, no checks on the supplied data are performed!
    ! orbital: the orbital to be transformed
    ! ibnd: band index
    ! nbnd: total number of bands
    use wavefunctions_module,     only : psic
    use gsmooth,                  only : nr1s,nr2s,nr3s,nrx1s,nrx2s,&
       nrx3s,nrxxs,nls,nlsm,doublegrid
    use lr_variables,             only : igk_k,npw_k
    USE kinds,                  ONLY : DP
    
    implicit none
     
    integer, intent(in) :: ibnd,nbnd
    complex(DP),intent(in) :: orbital(:,:)
   
    integer :: ig
    ! Based on an algorithm found somewhere in the TDDFT codes
       psic(:) =(0.0d0,0.0d0)
       if(ibnd<nbnd) then
          do ig=1,npw_k(1)
             !
             psic(nls(igk_k(ig,1)))=orbital(ig,ibnd)+&
                  (0.0d0,1.0d0)*orbital(ig,ibnd+1)
             psic(nlsm(igk_k(ig,1)))=conjg(orbital(ig,ibnd)-&
                  (0.0d0,1.0d0)*orbital(ig,ibnd+1))
             !
          enddo
       else
          do ig=1,npw_k(1)
             !
             psic(nls(igk_k(ig,1)))=orbital(ig,ibnd)
             psic(nlsm(igk_k(ig,1)))=conjg(orbital(ig,ibnd))
             !
          enddo
       endif
       !
       call cft3s(psic,nr1s,nr2s,nr3s,nrx1s,nrx2s,nrx3s,2)

    END SUBROUTINE fft_orbital_gamma
    ! 
    !
    !--------------------------------------------------------------------------
    SUBROUTINE bfft_orbital_gamma (orbital, ibnd, nbnd)
    !--------------------------------------------------------------------------
    !
    ! OBM 170908
    ! This driver subroutine -back- transforms the given orbital using fft using the already existent data
    ! in psic. Warning! This subroutine does not reset the orbital, use carefully! 
    ! Warning 2! In order to be fast, no checks on the supplied data are performed!
    ! Variables:
    ! orbital: the orbital to be transformed
    ! ibnd: band index
    ! nbnd: total number of bands
    use wavefunctions_module,     only : psic
    use gsmooth,                  only : nr1s,nr2s,nr3s,nrx1s,nrx2s,&
       nrx3s,nrxxs,nls,nlsm,doublegrid
    use lr_variables,             only : igk_k,npw_k
    USE kinds,                  ONLY : DP
    

    implicit none
     
    integer, intent(in) :: ibnd,nbnd
    complex(DP),intent(out) :: orbital(:,:)
   
    integer :: ig
    complex(kind=dp) :: fp, fm
    ! Based on the algorithm found in lr_apply_liovillian
    call cft3s(psic,nr1s,nr2s,nr3s,nrx1s,nrx2s,nrx3s,-2)
    !
    if (ibnd<nbnd) then
       !
       do ig=1,npw_k(1)
          !
          fp=(psic(nls(igk_k(ig,1)))&
               +psic(nlsm(igk_k(ig,1))))*(0.50d0,0.0d0)
          !
          fm=(psic(nls(igk_k(ig,1)))&
               -psic(nlsm(igk_k(ig,1))))*(0.50d0,0.0d0)
          !
          orbital(ig,ibnd)=cmplx(dble(fp),aimag(fm),dp)
          !
          orbital(ig,ibnd+1)=cmplx(aimag(fp),-dble(fm),dp)
          !
       enddo
       !
    else
       !
       do ig=1,npw_k(1)
          !
          orbital(ig,ibnd)=psic(nls(igk_k(ig,1)))
          !
       enddo
       !
    endif
    !
    !
    END SUBROUTINE bfft_orbital_gamma
    !
    !--------------------------------------------------------------------------
    SUBROUTINE add_vuspsir ( ibnd, m )
    !--------------------------------------------------------------------------
    !
    !    This routine applies the Ultra-Soft Hamiltonian to a
    !    vector psic. 
    !    ibnd is an index that runs over the number of bands, which is given by m
    !    Requires the products of psi with all beta functions
    !    in array rbecp(nkb,m) (calculated by calbecr)
    !
    ! OBM: Notices :
    !      This routine stores the data in PSIC in a gamma only form, backtransform accordingly
    !      and work on k point parrelization
      USE kinds,                  ONLY : DP
      USE cell_base,              ONLY : omega
      USE wavefunctions_module,   ONLY : psic
      USE ions_base,              ONLY : nat, ntyp => nsp, ityp
      USE uspp_param,             ONLY : nh
      USE lsda_mod,               ONLY : current_spin
      USE uspp,                   ONLY : deeq
      USE becmod,                 ONLY : rbecp, becp
      !
      IMPLICIT NONE
      !
      INTEGER, intent(in) :: ibnd, m
      !
      INTEGER :: ih, jh, iqs, jqs, ikb, jkb, nt, ia, ir, mbia
      REAL(DP) :: fac
      REAL(DP), allocatable, dimension(:) :: w1, w2, bcr, bci
      ! 
      real(DP), external :: DDOT
      !
      CALL start_clock( 'add_vuspsir' )
      !
      fac = sqrt(omega)
      !
      ikb = 0
      iqs = 0
      jqs = 0
      !
      DO nt = 1, ntyp
         !
         DO ia = 1, nat
            !
            IF ( ityp(ia) == nt ) THEN
               !
               mbia = maxbox_beta(ia)
               ALLOCATE( w1(nh(nt)),  w2(nh(nt)) )
               w1 = 0.D0
               w2 = 0.D0
               !
               DO ih = 1, nh(nt)
                  !
                  DO jh = 1, nh(nt)
                     !
                     jkb = ikb + jh
                     !
                     w1(ih) = w1(ih) + deeq(ih,jh,ia,current_spin) * rbecp(jkb,ibnd) 
                     IF ( ibnd+1 .le. m )  w2(ih) = w2(ih) + deeq(ih,jh,ia,current_spin) * rbecp(jkb,ibnd+1) 
                     !
                  END DO
                  !
               END DO
               !
               w1 = w1 * fac
               w2 = w2 * fac
               ikb = ikb + nh(nt)
               !
               DO ih = 1, nh(nt)
                  !
                  DO ir = 1, mbia
                     ! 
                     iqs = jqs + ir
                     psic( box_beta(ir,ia) ) = psic(  box_beta(ir,ia) ) + betasave(ia,ih,ir)*CMPLX( w1(ih), w2(ih) )
                     ! 
                  END DO
                     !
                  jqs = iqs
                  !
               END DO
               !
               DEALLOCATE( w1, w2 )
               !
            END IF
            !
         END DO
         !
      END DO
      !
      CALL stop_clock( 'add_vuspsir' )
      !
      RETURN
      !
    END SUBROUTINE add_vuspsir
    !
    !--------------------------------------------------------------------------
    SUBROUTINE s_psir ( ibnd, m )
    !--------------------------------------------------------------------------
    !  
    ! ... This routine applies the S matrix to m wavefunctions psi
    ! ... and puts the results in spsi.
    ! ... Requires the products of psi with all beta functions
    ! ... in array becp(nkb,m) (calculated in h_psi or by calbec)
    !

      USE kinds,                  ONLY : DP
      USE cell_base,              ONLY : omega
      USE wavefunctions_module,   ONLY : psic
      USE ions_base,              ONLY : nat, ntyp => nsp, ityp
      USE uspp_param,             ONLY : nh
      USE lsda_mod,               ONLY : current_spin
      USE uspp,                   ONLY : qq
      USE becmod,                 ONLY : rbecp, becp
      !
      IMPLICIT NONE
      !
      INTEGER, intent(in) :: ibnd, m
      !
      INTEGER :: ih, jh, iqs, jqs, ikb, jkb, nt, ia, ir, mbia
      REAL(DP) :: fac
      REAL(DP), allocatable, dimension(:) :: w1, w2, bcr, bci
      !
      real(DP), external :: DDOT
      !
      CALL start_clock( 's_psir' )
      !
      fac = sqrt(omega)
      !
      ikb = 0
      iqs = 0
      jqs = 0
      !
      DO nt = 1, ntyp
         !
         DO ia = 1, nat
            !
            IF ( ityp(ia) == nt ) THEN
               !
               mbia = maxbox_beta(ia)
               ALLOCATE( w1(nh(nt)),  w2(nh(nt)) )
               w1 = 0.D0
               w2 = 0.D0
               !
               DO ih = 1, nh(nt)
                  !
                  DO jh = 1, nh(nt)
                     !
                     jkb = ikb + jh
                     w1(ih) = w1(ih) + qq(ih,jh,nt) * rbecp(jkb, ibnd) 
                     IF ( ibnd+1 .le. m ) w2(ih) = w2(ih) + qq(ih,jh,nt) * rbecp(jkb, ibnd+1) 
                     !
                  END DO
                  !
               END DO
               !
               w1 = w1 * fac
               w2 = w2 * fac
               ikb = ikb + nh(nt)
               !
               DO ih = 1, nh(nt)
                  !
                  DO ir = 1, mbia
                     !
                     iqs = jqs + ir
                     psic( box_beta(ir,ia) ) = psic(  box_beta(ir,ia) ) + betasave(ia,ih,ir)*CMPLX( w1(ih), w2(ih) )
                     !
                  END DO
                  !
                  jqs = iqs
                  !
               END DO
               !
               DEALLOCATE( w1, w2 )
               !
            END IF
            !
         END DO
         !
      END DO
      !
      CALL stop_clock( 's_psir' )
      !
      RETURN
      !
    END SUBROUTINE s_psir
    !
END MODULE real_beta
